<!-- Creator     : groff version 1.21 -->
<!-- CreationDate: Sat May  5 10:27:17 2012 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Ns_ConnContent</title>

</head>
<body>

<h1 align="center">Ns_ConnContent</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CONTENT PRE-READ">CONTENT PRE-READ</a><br>
<a href="#RESOURCE MANAGEMENT">RESOURCE MANAGEMENT</a><br>
<a href="#DESIGN NOTES AND LARGE CONTENT CONSIDERATIONS">DESIGN NOTES AND LARGE CONTENT CONSIDERATIONS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p style="margin-top: 1em">______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Ns_ConnContent,
Ns_ConnContentLength, Ns_ConnContentFd, Ns_ConnContentOnDisk
&minus; Routines to access request content</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&quot;ns.h&quot;</b></p>

<p style="margin-left:11%; margin-top: 1em">char * <b><br>
Ns_ConnContent</b>(<i>Ns_Conn *conn</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Ns_ConnContentLength</b>(<i>Ns_Conn *conn</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Ns_ConnContentFd</b>(<i>Ns_Conn *conn</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Ns_ConnContentOnDisk</b>(<i>Ns_Conn *conn</i>)</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p style="margin-top: 1em">Ns_Conn <i>*conn</i> (in)</p></td>
<td width="9%"></td>
<td width="43%">


<p style="margin-top: 1em">Pointer to given connection.</p></td>
<td width="3%">
</td></tr>
</table>


<p style="margin-left:54%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These
procedures provide access to the request content sent with a
request. <br>
char *<b>Ns_ConnContent</b></p>

<p style="margin-left:22%;">Returns a pointer to the
content in memory. The result of <b>Ns_ConnContent</b> is
not guarenteed to be null-terminated. Safe code should be
careful to use the result of <b>Ns_ConnContentLength</b> to
avoid overrun.</p>

<p style="margin-left:11%;">int <b>Ns_ConnContentFd</b></p>

<p style="margin-left:22%;">Returns a file descriptor to an
open temporary file which contains the content.</p>

<p style="margin-left:11%;">int
<b>Ns_ConnContentLength</b></p>

<p style="margin-left:22%;">Returns the length of the
memory buffer and/or the size of thesent beyond the content
from open temporary file. Any trailing common browsers on a
POST request is not included.</p>

<p style="margin-left:11%;">int
<b>Ns_ConnContentOnDisk</b></p>

<p style="margin-left:22%;">Returns 1 if the content is
currently on disk, such that a call to Ns_ConnContentFd will
not cause a new file to be created. When it returns 0, a
call to Ns_ConnContent will not require a mmap() call.</p>

<h2>CONTENT PRE-READ
<a name="CONTENT PRE-READ"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">While receiving
the request before connection processing, the server will
pre-read the entire content body and either copy the content
to memory or spool it to an open file depending on virtual
server config settings. Requests with content beyond the
<i>maxcontent</i> virtual server setting are rejected,
requests with content between <i>maxinput</i> and
<i>maxcontent</i> are spooled to a temp file, and small
requests (the majority of simple POST&rsquo;s) are copied to
memory.</p>

<p style="margin-left:11%; margin-top: 1em">There is no
need for a request processing extension to consider possible
delays in reading content from the client as all content is
available before connection processing begins. The rationale
for this approach is that the driver thread can efficiently
multiplex reading content for serveral request, tolerating
any network delays. Legacy direct content reading routines,
for example, <b>Ns_ConnRead</b>, are now emulated on top of
the <b>Ns_ConnContent</b>.</p>

<h2>RESOURCE MANAGEMENT
<a name="RESOURCE MANAGEMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Ns_ConnContentFd</b>
returns an open file descriptor allocated by a call
<b>Ns_GetTemp</b> and must not be closed as it is owned by
the server core and will be closed at the end of the
connection. In addition, there is no filename for the open
file as the file is removed when opened for security reasons
and to ensure garbage collection. In practice, the open file
should be used to verify, parse, and copy content elsewhere
as required. Access at the Tcl level is also available via
the <b>ns_conn contentchannel</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">On a call to
<b>Ns_ConnContent</b>, either the existing memory buffer
will be returned or the temp file will be memory mapped on
the first call. This will require temporary virtual memory
to support the mapping until the end of the connection.
Likewise, on the first call to <b>Ns_ConnContentFd</b>, if a
temp file does not already exists one will be allocated and
the memory content will be spooled to the file. These
semantics allow one to access the content in either mode,
assuming resources are available, regardless of the original
location of the content.</p>

<h2>DESIGN NOTES AND LARGE CONTENT CONSIDERATIONS
<a name="DESIGN NOTES AND LARGE CONTENT CONSIDERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The design goal
of the server is to support the ordinary case of reasonably
small content requests (i.e., POST forms and small file
uploads) in a convienent way without limiting a custom app
to support very large requests. In particular, a call to
<b>Ns_ConnGetQuery</b> for a <i>multipart/file-upload</i>
POST will result in an implicit call to
<b>Ns_ConnContent</b> to parse the fields. This could
require significant temporary virtual memory plus dynamic
memory to copy non-file fields into the resulting
<i>Ns_Set</i>. See the <i>ns_limits</i> command to control
maximum resource requirements.</p>

<p style="margin-left:11%; margin-top: 1em">For custom
apps, an extension could work with the underlying open file
via <b>Ns_ConnContentFd</b> or <b>ns_connn
contentchannel</b> to avoid large virtual memory
requirements subject to disk space availability. To avoid
inadvertant memory mapping of a large upload by other
extensions calling <b>Ns_ConnGetQuery</b>, consider using a
HTTP method other than <i>GET</i> or <i>POST</i> required by
<b>Ns_ConnGetQuery</b>, e.g., <i>PUT</i>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Ns_Conn(3),
Ns_ConnRead(3), ns_limits(n), ns_conn(n)</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">connection,
content</p>
<hr>
</body>
</html>
