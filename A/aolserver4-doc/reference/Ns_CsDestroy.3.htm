<!-- Creator     : groff version 1.21 -->
<!-- CreationDate: Sat May  5 10:27:20 2012 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Ns_CritSec</title>

</head>
<body>

<h1 align="center">Ns_CritSec</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p style="margin-top: 1em">______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">, Ns_CsDestroy,
Ns_CsEnter, Ns_CsInit, Ns_CsLeave &minus; Manage and use
critical section locks</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&quot;ns.h&quot;</b></p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Ns_CsDestroy</b>(<i>Ns_Cs *csPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Ns_CsEnter</b>(<i>Ns_Cs *csPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Ns_CsInit</b>(<i>Ns_Cs *csPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Ns_CsLeave</b>(<i>Ns_Cs *csPtr</i>)
_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Critical
section locks are used to prevent more than one thread from
executing a specific section of code at one time. They are
implemented as &quot;objects&quot;, which simply means that
memory is allocated to hold the lock state. They can also be
called &quot;sychronization objects&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">While a thread
is executing a critical section of code, all other threads
that want to execute that same section of code must wait
until the lock surrounding that critical section has been
released.</p>

<p style="margin-left:11%; margin-top: 1em">This is crucial
to prevent race conditions which could put the server into
an unknown state. For example, if a section of code frees a
pointer and then decrements a counter that stores how many
pointers exist, it is possible that the counter value and
the actual number of pointers may be different. If another
section of the server relies on this counter and reads it
when the pointer has been freed, but the counter has not yet
been decremented, it could crash the server or put it into
an unknown state.</p>

<p style="margin-left:11%; margin-top: 1em">Critical
section locks should be used sparingly as they will
adversely impact the performance of the server or module.
They essentially cause the section of code they enclose into
behaving in a single-threaded manner. If a critical section
executes slowly or blocks, other threads that must execute
that section of code will begin to block as well until the
critical section lock is released.</p>

<p style="margin-left:11%; margin-top: 1em">You will
normally want to wrap sections of code that are used to both
read and write values, create and destroy pointers and
structures or otherwise look at or modify data in the
system. Use the same named lock for both read and write
operations on the same data.</p>

<p style="margin-left:11%; margin-top: 1em">Threads that
are waiting for a critical section lock to be released do
not have to poll the lock. The critical section lock
functions use thread condition functions to signal when a
lock is released. <b><br>
Ns_CsDestroy</b>(<i>csPtr</i>)</p>

<p style="margin-left:22%; margin-top: 1em">Destroy a
critical section object. Note that you would almost never
need to call this function as synchronization objects are
typically created at startup and exist until the server
exits.</p>

<p style="margin-left:22%; margin-top: 1em">The underlying
objects in the critical section are destroyed and the
critical section memory returned to the heap.</p>


<p style="margin-left:11%;"><b>Ns_CsEnter</b>(<i>csPtr</i>)</p>

<p style="margin-left:22%; margin-top: 1em">Lock a critical
section object, initializing it first if needed. If the
critical section is in use by another thread, the calling
thread will block until it is no longer so.</p>

<p style="margin-left:22%; margin-top: 1em">Note that
critical sections are recursive and must be exited the same
number of times as they were entered.</p>


<p style="margin-left:11%;"><b>Ns_CsInit</b>(<i>csPtr</i>)</p>

<p style="margin-left:22%; margin-top: 1em">Initialize a
critical section object. Memory will be allocated to hold
the object&rsquo;s state.</p>


<p style="margin-left:11%;"><b>Ns_CsLeave</b>(<i>csPtr</i>)</p>

<p style="margin-left:22%; margin-top: 1em">Unlock a
critical section once. A count of threads waiting to enter
the critical section is kept, and a condition is signaled if
this is the final unlock of the critical section so that
other threads may enter the critical section.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">nsd(1),
info(n), Ns_MasterLock(3), Ns_MasterUnlock(3),
Ns_CondDestroy(3), Ns_CondSignal(3), Ns_CondWait(3),
Ns_MutexLock(3), Ns_MutexUnlock(3)</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>
<hr>
</body>
</html>
