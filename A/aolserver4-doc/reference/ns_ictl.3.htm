<!-- Creator     : groff version 1.21 -->
<!-- CreationDate: Sat May  5 10:27:41 2012 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ns_ictl</title>

</head>
<body>

<h1 align="center">ns_ictl</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#INTERPRETER ALLOCATION">INTERPRETER ALLOCATION</a><br>
<a href="#INTERPRETER TRACES">INTERPRETER TRACES</a><br>
<a href="#VIRTUAL SERVER TCL INITIALIZATION">VIRTUAL SERVER TCL INITIALIZATION</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p style="margin-top: 1em">______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">ns_ictl &minus;
Facility to control AOLserver multi-threaded Tcl
interpreters</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>ns_ictl
addmodule</b> <i>module</i> <b><br>
ns_ictl cancel</b> <i>thread</i> <b><br>
ns_ictl cleanup <br>
ns_ictl epoch <br>
ns_ictl get <br>
ns_ictl getmodules <br>
ns_ictl gettraces</b> <i>which</i> <b><br>
ns_ictl once</b> <i>key script</i> <b><br>
ns_ictl oncleanup</b> <i>script</i> <b><br>
ns_ictl oncreate</b> <i>script</i> <b><br>
ns_ictl ondelete</b> <i>script</i> <b><br>
ns_ictl oninit</b> <i>script</i> <b><br>
ns_ictl package</b> <i>?-exact? package ?version?</i>
<b><br>
ns_ictl runtraces</b> <i>which</i> <b><br>
ns_ictl save</b> <i>script</i> <b><br>
ns_ictl threads <br>
ns_ictl trace</b> <i>when script</i> <b><br>
ns_ictl update</b>
_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This command
provides access to the internal facilities to control and
configure multi-threaded Tcl interpreters in the context of
AOLserver virtual servers. It is normally used in startup
initialization scripts to define how new interpreters are
initialized when created and to support cleanup and
re-initalization between transactions (e.g., HTTP
connections). <b><br>
ns_ictl addmodule</b> <i>module</i></p>

<p style="margin-left:22%;">Add a module to the list of
modules to be initialized at startup. This command is not
normally required as each module specified in the AOLserver
modules config section for the corresponding server (e.g.,
<i>ns/server/server1/modules</i>) is automatically added to
the list.</p>

<p style="margin-left:11%;"><b>ns_ictl cancel</b>
<i>thread</i></p>

<p style="margin-left:22%;">Send an asynchronous interrupt
request to the specified thread, cancelling any script
currently executing on any AOLserver created interpreter
(note the interrupt is not virtual-server specific). This
command utilizes the facilities of <b>Tcl_AsyncMark</b> to
mark as ready a callback registered with
<b>Tcl_AsyncCreate</b>. The callback places an error message
in the interpreter result and returns <b>TCL_ERROR</b> to
unwind the call stack. The underlying Tcl facility has
limitations, e.g., the interrupt will only be noticed when
Tcl checks via <b>Tcl_AsyncReady</b> calls between commands
and the interrupt can be caught with a <b>catch</b> command.
See the man page for <b>Tcl_AsyncCreate</b> for details.</p>

<p style="margin-left:11%;"><b>ns_ictl cleanup</b></p>

<p style="margin-left:22%;">This command invokes any
callbacks registered during a transaction via the C-level
<b>Ns_TclRegisterDefer</b> routine. Unlike callbacks
registered with the <b>ns_ictl trace deallocate</b> command
or <b>Ns_TclRegisterTrace</b> routine, these callbacks are
executed only once and there is no Tcl-level access to the
underlying <b>Ns_TclRegisterDefer</b> routine.</p>

<p style="margin-left:11%;"><b>ns_ictl epoch</b></p>

<p style="margin-left:22%;">This command returns the unique
id for the current duplication script for the virtual
server. The id starts as 0 when the virtual server is
created and is incremented each time a new script is saved
via the <b>ns_ictl save</b> command.</p>

<p style="margin-left:11%;"><b>ns_ictl get</b></p>

<p style="margin-left:22%;">Return the current duplication
script for the virtual server. This command is useful to
view the duplication script created by the initialization
script at startup.</p>

<p style="margin-left:11%;"><b>ns_ictl getmodules</b></p>

<p style="margin-left:22%;">Return the list of modules to
be initialized at startup. This list corresponds to the
names of modules specified in the virtual server modules
config section, e.g., <i>ns/server/server1/modules</i>
unless additional modules are added via the <b>ns_ictl
addmodule</b> command.</p>

<p style="margin-left:11%;"><b>ns_ictl gettraces</b>
<i>which</i></p>

<p style="margin-left:22%;">Return the list of traces which
will be invoked at the specified time. The <i>which</i>
argument can be one of <i>create, delete, allocate,
deallocate, getconn</i>, or <i>freeconn</i>. The traces are
returned in the order in which they will be executed. Script
level traces are returns as strings to evaluate and C-level
traces are returned with strings which specify the address
of the underlying C procedure and argument.</p>

<p style="margin-left:11%;"><b>ns_ictl once</b> <i>key
script</i></p>

<p style="margin-left:22%;">Evaluate given script once in
the virtual server. The given key is a string name which
uniquely identifies the corresponding script. This command
is useful in a Tcl package which includes one-time
initialization routines, e.g., calls to
<b>ns_register_proc</b> or initialization of shared
variables using <b>nsv_set</b> (see <b>EXAMPLES</b>
below).</p>

<p style="margin-left:11%;"><b>ns_ictl oncleanup</b>
<i>script</i></p>

<p style="margin-left:22%;">This command is equivalent to
<b>ns_ictl trace deallocate</b> <i>script</i>.</p>

<p style="margin-left:11%;"><b>ns_ictl oncreate</b>
<i>script</i></p>

<p style="margin-left:22%;">This command is equivalent to
<b>ns_ictl trace create</b> <i>script</i>.</p>

<p style="margin-left:11%;"><b>ns_ictl ondelete</b>
<i>script</i></p>

<p style="margin-left:22%;">This command is equivalent to
<b>ns_ictl trace delete</b> <i>script</i>.</p>

<p style="margin-left:11%;"><b>ns_ictl oninit</b>
<i>script</i></p>

<p style="margin-left:22%;">This command is equivalent to
<b>ns_ictl trace allocate</b> <i>script</i>.</p>

<p style="margin-left:11%;"><b>ns_ictl package</b>
<i>?-exact? package ?version?</i></p>

<p style="margin-left:22%;">This command is used to require
a package in the calling interpreter and, if successfully
loaded, in all other interpreters for the virtual server. In
addition to ensuring version consistency for the package, it
is equivalent to:</p>

<p style="margin-left:22%; margin-top: 1em"><b>set version
[package require</b> <i>package ?version?</i><b>] <br>
ns_ictl trace allocate [list package require</b>
<i>package</i> <b>$version]</b></p>

<p style="margin-left:11%;"><b>ns_ictl runtraces</b>
<i>which</i></p>

<p style="margin-left:22%;">This command runs the requested
traces. The <i>which</i> argument must be one of
<b>create</b>, <b>delete</b>, <b>allocate</b>,
<b>deallocate</b>, <b>getconn</b>, or <b>freeconn</b>.
Direct calls to this command are not normally necessary as
the underlying C code will invoke the callbacks at the
required times. Exceptions include calling <b>ns_ictl
runtraces</b> or testing purposes or to mimic the normal
cleanup and initialization work performed on between
transactions in a long running thread (see <b>EXAMPLES</b>
below).</p>

<p style="margin-left:11%;"><b>ns_ictl save</b>
<i>script</i></p>

<p style="margin-left:22%;">Save the given script as the
duplication script, incrementing the virtual server epoch
number. This command is normally called by the bootstrap
script after constructing the script to duplicate the
procedures defined by sourcing the various module
initialization script files.</p>

<p style="margin-left:11%;"><b>ns_ictl threads</b></p>

<p style="margin-left:22%;">Return a list of all threads
with interpreters for the virtual server. The ids return are
small strings which represent the underlying thread ids and
can be passed to the <b>ns_ictl cancel</b> command to send
an asynchronous cancel request.</p>

<p style="margin-left:11%;"><b>ns_ictl trace create</b>
<i>script</i></p>

<p style="margin-left:22%;">Register <i>script</i> to be
called when an interpreter is first created. This is useful
to create procedures, require packages, or initialize other
state to be used during the lifetime of the interpreter.</p>

<p style="margin-left:11%;"><b>ns_ictl trace delete</b>
<i>script</i></p>

<p style="margin-left:22%;">Register <i>script</i> to be
called before an interpreter is destroyed. This is useful to
free any resources which may have been allocated for the
interpreter during the lifetime of the interpreter.</p>

<p style="margin-left:11%;"><b>ns_ictl trace allocate</b>
<i>script</i></p>

<p style="margin-left:22%;">Register <i>script</i> to be
called each time an interpreter is allocated for use by the
<b>Ns_TclAllocateInterp</b> routine. This is useful for
reinitializing resources which may be used during a single
transaction in the interpreter.</p>

<p style="margin-left:11%;"><b>ns_ictl trace deallocate</b>
<i>script</i></p>

<p style="margin-left:22%;">Register <i>script</i> to be
called each time an interpreter is returned after a
transaction with the <b>Ns_TclDeAllocateInterp</b> routine.
This is useful for garbage collection, i.e., freeing any
resources which may be used during a single transaction in
the interpreter.</p>

<p style="margin-left:11%;"><b>ns_ictl trace getconn</b>
<i>script</i></p>

<p style="margin-left:22%;">Register <i>script</i> to be
called each time an interpreter is returned and associated
with an HTTP connection with the <b>Ns_GetConnInterp</b>
routine. This could be useful to define variables relative
to the HTTP request.</p>

<p style="margin-left:11%;"><b>ns_ictl trace freeconn</b>
<i>script</i></p>

<p style="margin-left:22%;">Register <i>script</i> to be
called each time an HTTP connection is closed. This could be
used to log information about the request, e.g., timing
statistics. Note that the interpreter may still be actively
evaluating a script after the connection is closed, i.e.,
this is not equivalent to <b>ns_ictl trace deallocate</b>
for connection-related interpreters.</p>

<p style="margin-left:11%;"><b>ns_ictl update</b></p>

<p style="margin-left:22%;">This command can be used to
atomically compare the epoch of the current duplication
script with the epoch of the interpreter, evaluating the
script and updating the epoch in the interpreter if they do
not match. This command is generally registered as a
callback with <b>ns_ictl trace allocate</b> by the legacy
initialization code.</p>

<h2>INTERPRETER ALLOCATION
<a name="INTERPRETER ALLOCATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl interpreter
in AOLserver are available on demand with state specific to
a virtual server. These interpreters are also expected to be
reused for multiple transactions (e.g., HTTP connections,
scheduled procedures, socket callbacks).</p>

<p style="margin-left:11%; margin-top: 1em">To support
reuse, AOLserver provides the C-level
<b>Ns_TclAllocateInterp</b> routine to allocate an
interpreter from a per-thread cache (creating and
initializing a new interpreter if necessary) and the
<b>Ns_TclDeAllocateInterp</b> routine to return an
interpreter to the cache when no longer required. All
interpreters in the per-thread cache are destroyed when a
thread exists.</p>

<p style="margin-left:11%; margin-top: 1em">In general,
only C-level extension writers need to call the C-level
API&rsquo;s directly; the various Tcl-level interfaces in
AOLserver (e.g., <b>ADP</b> pages, <b>ns_regiseter_proc</b>,
<b>ns_schedule_proc</b>, <b>ns_thread</b>, etc.) allocate
and reuse interpreters using the C-level API&rsquo;s
automatically before invoking the cooresponding script or
ADP page.</p>

<h2>INTERPRETER TRACES
<a name="INTERPRETER TRACES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To ensure a
consistent state of interpreters when allocated and enable
cleanup and reinitialization between transactions, each
virtual server maintains a list of callbacks to be invoked
at various points in the lifetime of an interpreter. These
callbacks are generally installed when the server is
initialized at startup and then called automatically by the
<b>Ns_TclAllocateInterp</b> and
<b>Ns_TclDeAllocateInterp</b> API&rsquo;s at the appropriate
times and in consistent order. The
<b>Ns_TclRegisterTrace</b> routine can be used to register
C-level callbacks and the <b>ns_ictl trace</b> command can
be used to register Tcl script callbacks. The <b>ns_ictl
gettraces</b> command can be used to list all currently
registered callbacks, both at the Tcl script and C
level.</p>

<p style="margin-left:11%; margin-top: 1em">Callbacks
registered via the tracing facility are invoked in a
specific order depending on the type. Initialization style
callbacks including <b>create</b>, <b>allocate</b>, and
<b>getconn</b> are invoked in FIFO order, with all script
callbacks invoked after all C-level callbacks. This enables
extension writers to utilize the facilities of previously
initialized extensions. Correspondingly, cleanup style
callbacks including <b>freeconn</b>, <b>deallocate</b>, and
<b>delete</b> are invoked in LIFO order, with all scripts
callbacks invoked before C-level callbacks. This helps avoid
the possibility that a cleanup callback utilizes features of
a previously cleaned up extension.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
the <b>ns_ictl package</b> command can be used to
consistently manage the loading of a Tcl package in all
interpreters for a virtual server. This feature is mostly a
convenience routine built above the generic trace framework
with additional checks to ensure version number consistency.
Coupled with <b>ns_ictl once</b>, the <b>ns_ictl package</b>
command provides a clean framework to utilize Tcl packages
in multi-threaded AOLserver (see <b>EXAMPLES</b>).</p>

<h2>VIRTUAL SERVER TCL INITIALIZATION
<a name="VIRTUAL SERVER TCL INITIALIZATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">AOLserver also
supports a Tcl initialization framework for virtual servers
based on callbacks registered by loadable modules and the
sourcing of scripts files located in corresponding
directories. Options to <b>ns_ictl</b> to support this
framework include <i>save</i>, <i>get</i>, <i>epoch</i>, and
<i>update</i> and are used in conjunction with the generic
tracing facility by the virtual server bootstrap script
(normally <i>bin/init.tcl</i>). The <b>ns_eval</b> command
also relies on this framework to support dynamic update of
the state of interpreters.</p>

<p style="margin-left:11%; margin-top: 1em">This
initialization framework pre-dates the Tcl package
facilities and utilizes introspection of the state of a
startup interpreter at the end of initialization to
construct a single script which attempts to duplicate the
state in subsequent interpreters. Steps taken during this
initialization include: <br>
1. Load all modules in the server&rsquo;s module config
section, e.g.,</p>


<p style="margin-left:22%;"><i>ns/server/server1/modules</i>.
Modules with Tcl C-level extensions typically call the
legacy <b>Ns_TclInitInterps</b> routine or the more general
<b>Ns_TclRegisterTrace</b> routine with the
<i>NS_TCL_TRACE_CREATE</i> flag in their module init routine
to register a callback to invoke when new interpreters are
created. The callback normally creates one or more new
commands in the interpreter with <b>Tcl_CreateObjCommand</b>
but may perform any per-interpreter initialization required,
e.g., creating and saving private state with the
<b>Tcl_SetAssocData</b> facility. In addition, as modules
are loaded, the string name of the module is added to the
list of known modules.</p>

<p style="margin-left:11%;">2. After all C modules are
loaded, AOLserver creates a new Tcl</p>

<p style="margin-left:22%;">interpreter for the virtual
server, executing any trace callbacks already registered via
the loaded C modules (e.g., any <b>Ns_TclInitInterps</b>
callbacks) and then sources the virtual server bootstrap
script, normally <i>bin/init.tcl</i>. This script creates a
few utility procedures and then sources all <i>private</i>
and <i>public</i> script files in directories which
correspond to loaded modules in the order in which they were
loaded. These directories are normally relative to the
virtual server and to the AOLserver installation directory,
e.g., initialization script files for the module
<i>mymod</i> in the <i>server1</i> virtual server would be
searched for in the
<i>servers/server1/modules/tcl/mymod/</i> and
<i>modules/tcl/mymod/</i>. Any <i>init.tcl</i> file found in
each directory is sourced first with all remaining files
sourced in alphabetical order. In addition, any files in the
<i>public</i> directory with identical names to files in the
private directory are skipped as a means to enable
overloading of specific functionality on a per-server basis.
In practice, most modules only contain shared utility
procedures defined in the <i>public</i> directories and the
<i>private</i> directories are empty or non-existant. The
script files normally contain a mix of commands to evaluate
once for server configuration (e.g., a call to
<b>ns_register_proc</b> to bind a Tcl procedure to an HTTP
request URL) with <b>proc</b> and <b>namespace</b> commands
to provide additional functionality in the interpreter.</p>

<p style="margin-left:11%;">3. After all script files have
been sourced, the bootstrap script</p>

<p style="margin-left:22%;">code then uses a collection of
recursive procedures to extract the definitions of all
procedures defined in all namespaces. The definitions are
used to construct a script which attempts to duplicate the
state of the initialization interpreters. This scripts is
then saved as the per-virtual server duplication script with
the <b>ns_ictl save</b> command which also increments the
<i>epoch</i> to 1. There are limits to this approach to
determine the full state, e.g., it does not attempt to
duplicate any global variables which may have been defined
in the startup scripts. Typically, startup scripts will use
<b>nsv_set</b> or other mechanisms to store such shared
state.</p>

<p style="margin-left:11%;">4. The bootstrap code then uses
the <b>ns_ictl trace allocate</b></p>

<p style="margin-left:22%;">command to register a callback
to the <b>ns_ictl update</b> command each time an
interpreter is allocated for use. In practice, interpreters
are created with the default <i>epoch</i> of 0 and the first
call to <b>ns_ictl update</b> determines an out-of-date
condition, evaluates the duplication script, and increments
the interpreter&rsquo;s <i>epoch</i> to 1 to match the state
created by the startup interp.</p>

<p style="margin-left:11%;">5. Subsequent calls the
<b>ns_eval</b>, if any, will evaluate the</p>

<p style="margin-left:22%;">given script and then
re-generate and save the duplication script as was done at
startup, incrementing the <i>epoch</i> once again. In this
way, dynamic updates which are detected in other
interpreters on their next call to <b>ns_ictl update</b> can
be supported in a limited fashion.</p>

<p style="margin-left:11%; margin-top: 1em">In practice,
while generally successful, this duplication technique has
inhibited the clean use of proper Tcl package extensions and
encouraged the use of the <b>ns_eval</b> command which is
generally not recommended for the non-deterministic manner
in which it attempts to dynamically reconfigure a server.
Also, commands required to configure the server once (e.g.,
calls to <b>ns_register_proc</b>) are inter-mixed with
<b>proc</b> commands designed to extend functionality in all
interpreters, complicating configuration management.</p>

<p style="margin-left:11%; margin-top: 1em">As an
alternative, the example below illustrates a means to more
explicitly manage configuration through a combination of
direct calls to <b>ns_ictl trace create</b> and <b>ns_ictl
once</b>. Unfortunately, the all encompassing nature of the
legacy initialization approach makes it difficult to
incrementally move to this cleaner approach because the
duplication script construction code is unable to
distinguish between state created with the newer, cleaner
<b>ns_ictl</b> commands and state created as a side effect
of one or more script files being sourced. As such, it is
expected the legacy initialization framework will remain in
place until AOLserver 5.x when it will be removed entirely
in a non-backwards compatible move towards the cleaner
API&rsquo;s.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This example
illustrates the use of <b>ns_ictl package</b> and <b>ns_ictl
once</b> to load an AOLserver-aware Tcl package into a
virtual server. The following code could be added to the
virtual server bootstrap script, <i>bin/init.tcl</i>, to
load <i>MyPkg</i> in the virtual server:</p>

<p style="margin-left:22%; margin-top: 1em"># <br>
# Startup code in bin/init.tcl: <br>
# <br>
# Load MyPkg in all interps (including this one). <br>
# <br>
ns_ictl package require MyPkg</p>

<p style="margin-left:11%; margin-top: 1em">This call will
result in the package being loaded into the startup
interpreter in the ordinary Tcl fashion (see the
<b>package</b> man page for details). Ordinary Tcl extension
packages would need no modifications but packages which
utilize AOLserver-specific features or require garbage
collection between transactions could also use
<b>ns_ictl</b> for finer grained control. For example, the
<i>init.tcl</i> script specified by the <b>package
ifneeded</b> command in the <i>MyPkg</i> package&rsquo;s
<i>pkgIndex.tcl</i> file could contains:</p>

<p style="margin-left:22%; margin-top: 1em"># <br>
# Package code in lib/myPkg1.0/init.tcl: <br>
# <br>
#</p>

<p style="margin-left:22%; margin-top: 1em">package provide
MyPkg 1.0</p>

<p style="margin-left:22%; margin-top: 1em"># <br>
# Server init which will be executed the first time called,
<br>
# normally in the context of the startup interpreter as
above. <br>
#</p>

<p style="margin-left:22%; margin-top: 1em">ns_ictl once
MyPkg { <br>
# Register the run Tcl proc HTTP handler. <br>
ns_register_proc /mypkg mkpkg::run <br>
# Register a garbage collection callback. <br>
ns_ictl trace deallocate mypkg::cleanup <br>
}</p>

<p style="margin-left:22%; margin-top: 1em"># <br>
# Code which will be invoked to initialize the package in
<br>
# all interpreters when required. <br>
# <br>
proc mypkg::run {} { <br>
... handle /mypkg requests ... <br>
} <br>
proc mkpkg::cleanup {} { <br>
... cleanup transaction resources for mypkg, e.g., db
handles ... <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Ns_TclAllocateInterp(3),
Ns_TclDeAllocateInterp(3), Ns_GetConnInterp(3),
Ns_FreeConnInterp(3), Ns_TclInitInterps(3),
Ns_TclRegisterTrace(3), Ns_TclRegisterDeferred(3),
ns_atclose(n), ns_eval(n).</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">threads,
interpreters, traces, initialization</p>
<hr>
</body>
</html>
