<html>
<head>
<title>AOLserver</title>
</head>
<body>

<h1>Thread C Library Functions</h1>

<p>
$Header: /cvsroot/aolserver/aolserver.com/docs/devel/c/index.html,v 1.1 2002/03/07 19:15:35 kriston Exp $
<p>


<h2><a name= href=./>Ns_AbsTimedWaitForEvent</a></h2>

Wait for an event to be broadcast

<h3>Syntax</h3>

<pre>    
    int Ns_AbsTimedWaitForEvent (
    Ns_Cond* event,
    Ns_Mutex* lock,
    time_t abstime
    );
</pre>

<h3>Description</h3>

Wait for an event to be broadcast or the current time to be abstime,
whichever comes first.



<p>

<hr>

<br>



<h2><a name= href=./>Ns_AllocThreadLocalStorage</a></h2>

Initialize a local thread storage variable.

<h3>Syntax</h3>

<pre>    
    int Ns_AllocThreadLocalStorage(
    Ns_ThreadLocalStorage * tls,
    void (*destructor) (void *)
    );
</pre>

<h3>Description</h3>

Initializes a thread local storage variable and sets its destructor
   function. The tls's value is initially NULL in all existing threads
   and any new threads which are later created. If the destructor
   function pointer is non-null and the tls is non-null in a particular
   thread when it exits, the destructor will be called for that thread.

<p>

Thread local storage is often used to store data which must be shared
   between unrelated functions much like global variables are used in a
   single threaded program. Thread local storage is also often used to
   provide buffer space unique to each thread when making older code
   thread safe.

<h3>Examples</h3>

<pre>
    static Ns_ThreadLocalStorage tls;

    void
    Init(void)
    {
        /* This function is called once at startup. */
        Ns_AllocThreadLocalStorage(&tls, Ns_Free);
    }

    char *
    GetBuffer
    {
        void *ptr;

        Ns_GetThreadLocalStorage(&tls, &ptr);
        if (ptr == NULL) {
                /* Allocate a buffer for this thread. */
                ptr = Ns_Malloc(BUFFER_SIZE);
                Ns_SetThreadLocalStorage(&tls, ptr);
        }
        return (char *) ptr;
    }
</pre>


<p>

<hr>

<br>
<h2><a name= href=./>Ns_BeginDetachedThread</a></h2>

Create a detached thread

<h3>Syntax</h3>

<pre>    
    int Ns_BeginDetachedThread(
    Ns_ThreadProc *start_routine,
    void *arg
    );
</pre>

<h3>Description</h3>

Ns_BeginDetachedThread creates a thread which cleans up its data as
   soon as it ends. Note that detached threads' ids can be reused
   immediately by the system, and they cannot be waited on.

<h3>Examples</h3>

<pre>
    static void
    ThreadStart(void *arg)
    {
        int n;

        n = (int) arg;
        Ns_Log(Notice, "%d: %d", Ns_GetThreadId(), n);
    }

    /*
      * ManyThreads - Create 10 threads which all log a message.
      */
    static void
    ManyThreads(void)
    {
        int i;

        for (i = 0; i < 10; ++i) {
                Ns_BeginDetachedThread(ThreadStart, (void *) i);
        }
    }
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_BeginThread</a></h2>

Start a thread

<h3>Syntax</h3>

<pre>    
    int Ns_BeginThread(
    Ns_ThreadProc *start_routine,
    void *arg,
    Ns_Thread *thread
    );
</pre>

<h3>Description</h3>

Ns_BeginThread starts a new thread running start_routine and passwd
   arg as its context. If thread is non-null it will be filled with the
   thread's id. (see Ns_WaitForThread.)

<p>

Ns_ThreadCreate is the preferred function to start a thread.

<h3>Examples</h3>

<pre>
    static void
    ThreadStart(void *arg)
    {
        int n;

        n = (int) arg;
        Ns_Log(Notice, "%d: %d", Ns_GetThreadId(), n);
    }

    /*
      * ManyThreadWait - Create 10 threads which all log a message
      * and wait for all of them to exit.
      */
    static void
    ManyThreadWait(void)
    {
        int i;
        Ns_Thread tids[10];

        for (i = 0; i < 10; ++i) {
                Ns_BeginThread(ThreadStart, (void *) i, &tids[i]);
        }

        for (i = 0; i < 10; ++i) {
                Ns_WaitForThread(&tids[i]);
        }
    }
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_BroadcastEvent</a></h2>

Wake up events that are waiting to be triggered

<h3>Syntax</h3>

<pre>    
    int Ns_BroadcastEvent(
    Ns_Event * event
    );
</pre>

<h3>Description</h3>

Wake up all the threads waiting on the event. If no threads are
   waiting on the event, this function has no effect.

<h3>Examples</h3>

<pre>
    static Ns_Event myev;
    static Ns_Mutex mylock;

    void
    Init(void)
    {
        /* Initialize the lock and event at startup. */
        Ns_InitializeMutex(&mylock);
        Ns_InitializeEvent(&myev);
    }

    /* Lock the mutex and wait for the event. */
    void
    WaitFunc(void)
    {
        Ns_LockMutex(&mylock);
        Ns_WaitForEvent(&myev, &mylock);
    }

    /* Wake up any waiting threads. */
    void
    BroadcastFunc(void)
    {
        Ns_BroadcastEvent(&myev);
    }
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheBroadcast</a></h2>

Broadcast to condition variable

<h3>Syntax</h3>

<pre>    
    void Ns_CacheBroadcast (
    Ns_Cache* cache
    );
</pre>

<h3>Description</h3>

Broadcast to the cache's condition variable, waking all threads. Every
   cache has an associated cond for user use. Every cache has an
   associated cond for user use.


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheCreate</a></h2>

Create a new cache

<h3>Syntax</h3>

<pre>    
    Ns_Cache* Ns_CacheCreate (
    char* name,
    int keys,
    time_t timeout,
    Ns_Callback* freeProc
    );
</pre>

<h3>Description</h3>

Create a new cache with the specified name. The keys argument is the
   size of the cache key in system words. The timeout argument is the
   time for cache entries to live. The freeProc argument is the
   Ns_Callback to free cache entry data.

<p>

For a good example of how to use the Ns_Cache* functions, look at
nsd/fastpath.c.


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheCreateEntry</a></h2>

Create a cache entry

<h3>Syntax</h3>

<pre>    
    Ns_Entry* Ns_CacheCreateEntry (
    Ns_Cache* cache,
    char* key,
    int* pnew
    );
</pre>

<h3>Description</h3>

Create a new cache entry in the specified cache. This function
emulates Tcl_CreateHashEntry's interface.

<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheCreateSz</a></h2>

Create a size-based cache

<h3>Syntax</h3>

<pre>    
    Ns_Cache* Ns_CacheCreateSz (
    char* name,
    int keys,
    size_t maxsize,
    Ns_Callback* freeProc
    );
</pre>

<h3>Description</h3>

Create a new size-based cache (a cache that has a maximum size in
bytes, specified by the maxsize argument). The keys argument is
TCL_STRING_KEYS or TCL_ONE_WORD_KEYS or an integer >=2, which is the
number of machine words needed to store a cache key. The freeProc
argument is the Ns_Callback to free cache entry data.

<p>

<hr>

<br>



<h2><a name= href=./>Ns_CacheDeleteEntry</a></h2>


Delete a cache entry

<h3>Syntax</h3>

<pre>    
    void Ns_CacheDeleteEntry (
    Ns_Entry* entry
    );
</pre>

<h3>Description</h3>

Delete the specified entry from the cache table.


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheFind</a></h2>

Find a cache

<h3>Syntax</h3>

<pre>    
    Ns_Cache* Ns_CacheFind (
    char* name
    );
</pre>

<h3>Description</h3>

Find a cache by name.


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheFindEntry</a></h2>

Find a cache entry

<h3>Syntax</h3>

<pre>    
    Ns_Entry* Ns_CacheFindEntry (
    Ns_Cache* cache,
    char* key
    );
</pre>

<h3>Description</h3>

Find a cache entry.


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheFirstEntry</a></h2>

Get first cache entry

<h3>Syntax</h3>

<pre>    
    Ns_Entry* Ns_CacheFirstEntry (
    Ns_Cache* cache,
    Ns_CacheSearch* searchPtr
    );
</pre>

<h3>Description</h3>

Return a pointer to the first entry in the cache (Cache entries are
stored in no particular order.)


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheFlush</a></h2>

Flush all cache entries

<h3>Syntax</h3>

<pre>    
    void Ns_CacheFlush (
    Ns_Cache* cache
    );
</pre>

<h3>Description</h3>

Flush every entry from the specified cache.


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheFlushEntry</a></h2>

Delete a cache entry

<h3>Syntax</h3>

<pre>    
    void Ns_CacheFlushEntry (
    Ns_Entry* entry
    );
</pre>

<h3>Description</h3>

Delete an entry from the cache table after first unsetting the current
entry value (if any).


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheFree</a></h2>

Free allocated memory

<h3>Syntax</h3>

<pre>    
    void Ns_CacheFree (
    Ns_Cache* cache,
    void* memPtr
    );
</pre>

<h3>Description</h3>


Frees memory allocated with Ns_CacheMalloc.

   
<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheGetValue</a></h2>

Get value of cache entry

<h3>Syntax</h3>

<pre>    
    void* Ns_CacheGetValue (
    Ns_Entry* entry
    );
</pre>

<h3>Description</h3>

Get the value (contents) of a cache entry.


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheKey</a></h2>

Get key of cache entry

<h3>Syntax</h3>

<pre>    
    char* Ns_CacheKey (
    Ns_Entry* entry
    );
</pre>

<h3>Description</h3>

Gets the key of a cache entry.


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheLock</a></h2>

Lock a cache

<h3>Syntax</h3>

<pre>    
    void Ns_CacheLock (
    Ns_Cache* cache
    );
</pre>

<h3>Description</h3>

Lock the cache. This must be done before performing any read/write
   action on a cache.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheMalloc</a></h2>

Allocate memory

<h3>Syntax</h3>

<pre>    
    void* Ns_CacheMalloc (
    Ns_Cache* cache,
    size_t len
    );
</pre>

<h3>Description</h3>

Allocate memory from a cache-local pool.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheName</a></h2>

Get name of cache

<h3>Syntax</h3>

<pre>    
    char* Ns_CacheName (
    Ns_Entry* entry
    );
</pre>

<h3>Description</h3>

Get the name of the cache.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheNextEntry</a></h2>

Get next cache entry

<h3>Syntax</h3>

<pre>    
    Ns_Entry* Ns_CacheNextEntry (
    Ns_CacheSearch* searchPtr
    );
</pre>

<h3>Description</h3>

Get the next cache entry. When used in conjunction with
   Ns_CacheFirstEntry, you can traverse the whole cache.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheSetValue</a></h2>

Set value of cache entry

<h3>Syntax</h3>

<pre>    
    void Ns_CacheSetValue (
    Ns_Entry* entry,
    void* value
    );
</pre>

<h3>Description</h3>

Set the value of a cache entry.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheSetValueSz</a></h2>

Set value of cache entry and adjust cache size

<h3>Syntax</h3>

<pre>    
    void Ns_CacheSetValueSz (
    Ns_Entry* entry,
    void* value,
    size_t size
    );
</pre>

<h3>Description</h3>

Free the cache entry's previous contents, set it to the new contents,
   increase the size of the cache, and prune the cache until it's back
   under the maximum size.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheSignal</a></h2>

Signal cache's condition variable

<h3>Syntax</h3>

<pre>    
    void Ns_CacheSignal (
    Ns_Cache* cache
    );
</pre>

<h3>Description</h3>

Signal the cache's condition variable, waking the first waiting thread
   (if any).

<p>

Note: Consider waking all threads with Ns_CacheBroadcast, instead.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheTimedGetValue</a></h2>

Wait for cache entry to be set

<h3>Syntax</h3>

<pre>    
    void* Ns_CacheTimedGetValue (
    Ns_Cache* cache,
    char* key,
    Ns_Time* timePtr,
    int* condPtr
    );
</pre>

<h3>Description</h3>

Wait for an entry's value to be set to non-null by some other thread
   up to the given timeout or until an optional condition integer becomes
   zero. Note that the cache and key are given instead of the entry
   because you cannot rely on an entry to remain valid during the
   Ns_CondTimedWait.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheTimedWait</a></h2>

Wait for condition variable to be set

<h3>Syntax</h3>

<pre>    
    int Ns_CacheTimedWait (
    Ns_Cache* cache,
    Ns_Time* timePtr
    );
</pre>

<h3>Description</h3>

Wait for the cache's condition variable to be signaled or the given
   absolute timeout if timePtr is not NULL.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheUnlock</a></h2>

Unlock cache

<h3>Syntax</h3>

<pre>    
    void Ns_CacheUnlock (
    Ns_Cache* cache
    );
</pre>

<h3>Description</h3>

Unlock the specified cache.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheUnsetValue</a></h2>

Reset cache entry to null

<h3>Syntax</h3>

<pre>    
    void Ns_CacheUnsetValue (
    Ns_Entry* entry
    );
</pre>

<h3>Description</h3>

Reset the value of an entry to NULL, calling the free proc for any
   previous entry and updating the cache size.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CacheWait</a></h2>

Wait indefinitely for condition variable to be set

<h3>Syntax</h3>

<pre>    
    void Ns_CacheWait (
    Ns_Cache* cache
    );
</pre>

<h3>Description</h3>

Wait indefinitely for the cache's condition variable to be signaled.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_CondBroadcast</a></h2>

Wake up all threads waiting on a cond

<h3>Syntax</h3>

<pre>    
    void Ns_CondBroadcast (
    Ns_Cond*
    );
</pre>

<h3>Description</h3>

Wake up all threads that are waiting on a cond. For more informations
   on condition variables, look at the pthread_cond_wait(3P) man page.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CondDestroy</a></h2>

Free a cond's memory

<h3>Syntax</h3>

<pre>    
    void Ns_CondDestroy (
    Ns_Cond *condPtr
    );
</pre>

<h3>Description</h3>

Free a cond's memory.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CondInit</a></h2>

Initialize a cond

<h3>Syntax</h3>

<pre>    
    void Ns_CondInit (
    Ns_Cond *condPtr
    );
</pre>

<h3>Description</h3>

Initialize a cond. You don't need to call this function if it is
   initialized to 0, as is the case with static variables.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CondSignal</a></h2>

Wake up a single thread

<h3>Syntax</h3>

<pre>    
    void Ns_CondSignal (
    Ns_Cond *condPtr
    );
</pre>

<h3>Description</h3>

Wake up a single thread blocking on a cond.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CondTimedWait</a></h2>

Block on a cond

<h3>Syntax</h3>

<pre>    
    int Ns_CondTimedWait (
    Ns_Cond *condPtr ,
    Ns_Mutex *mutexPtr ,
    Ns_Time *timePtr
    );
</pre>

<h3>Description</h3>

Block on a cond until signaled or the specified time expires. The time
   is absolute. The Ns_Time value can be manipulated with Ns_GetTime,
   Ns_DiffTime, or Ns_IncrTime.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CondWait</a></h2>

Wait indefinitely on a cond

<h3>Syntax</h3>

<pre>    
    void Ns_CondWait (
    Ns_Cond *condPtr ,
    Ns_Mutex *mutexPtr
    );
</pre>

<h3>Description</h3>

Wait indefinetly on a cond.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_CsDestroy</a></h2>

Destroy a critical section object

<h3>Syntax</h3>

<pre>    
    void Ns_CsDestroy(
    Ns_Cs*
    );
</pre>

<h3>Description</h3>

Free the resources associated with the critical section.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CsEnter</a></h2>

Enter a critical section

<h3>Syntax</h3>

<pre>    
    void Ns_CsEnter(
    Ns_Cs *csPtr
    );
</pre>

<h3>Description</h3>

Enter the specified critical section. If the critical section is use
   by another thread, the current will block until it is no longer so.
   Note that critical sections are recursive and must be exited the same
   number of times as they were entered.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CsInit</a></h2>

Initialize a critical section

<h3>Syntax</h3>

<pre>    
    void Ns_CsInit(
    Ns_Cs *csPtr
    );
</pre>

<h3>Description</h3>

Initialize the specified critical section. It is recommended that you
   use a mutex instead of a critical section if possible.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CsLeave</a></h2>

Leave a critical section

<h3>Syntax</h3>

<pre>    
    void Ns_CsLeave(
    Ns_Cs *csPtr
    );
</pre>

<h3>Description</h3>

Leave the specified critical section.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_DestroyCriticalSection</a></h2>

Free a critical section's resources

<h3>Syntax</h3>

<pre>    
    int Ns_DestroyCriticalSection(
    Ns_CriticalSection * section
    );
</pre>

<h3>Description</h3>

Free the resources associated with the critical section.

<p>

Ns_CsDestroy is the preferred function for freeing a critical
   section's resources.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_DestroyEvent</a></h2>

Free an event's resources

<h3>Syntax</h3>

<pre>    
    int Ns_DestroyEvent(
    Ns_Event * event
    );
</pre>

<h3>Description</h3>

Free the resources associated with the event object.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_DestroyMutex</a></h2>

Free a mutual exclusion lock's resources

<h3>Syntax</h3>

<pre>    
    int Ns_DestroyMutex(
    Ns_Mutex * mutex
    );
</pre>

<h3>Description</h3>

Free the mutex's associated resources.

<p>

Ns_MutexDestroy is the preferred function for freeing a mutex's
   resources.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_DestroyRWLock</a></h2>

Destroy a read/write lock

<h3>Syntax</h3>

<pre>    
    int Ns_DestroyRWLock(
    Ns_RWLock *lock
    );
</pre>

<h3>Description</h3>

Ns_DestroyRWLock frees the read/write lock's associated resources.

<p>

For general information about read/write locks and an example showing
   the use of the read/write lock functions, see the Ns_InitializeRWLock
   function.

<p>

Ns_RWLockDestroy is the preferred function for destroying a read/write
   lock.

<p>

<hr>

<br>




<h2><a name= href=./>Ns_DestroySemaphore</a></h2>

Free a semaphore's resources

<h3>Syntax</h3>

<pre>    
    int Ns_DestroySemaphore(
    Ns_Semaphore * sema
    );
</pre>

<h3>Description</h3>

Free the resources associated with the semaphore.

<p>

Ns_SemaDestroy is the preferred function for freeing a semaphore's
   resources.
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_EnterCriticalSection</a></h2>

Enter a critical section

<h3>Syntax</h3>

<pre>    
    int Ns_EnterCriticalSection(
    Ns_CriticalSection * section
    );
</pre>

<h3>Description</h3>

Enter the specified critical section. If the critical section is use
   by another thread, the current will block until it is no longer so.
   Note that critical sections are recursive and must be exited the same
   number of times as they were entered.

<p>

Ns_CsEnter is the preferred function for entering a critical section.
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_ExitThread</a></h2>

Free a thread or mark as exited

<h3>Syntax</h3>

<pre>    
    void Ns_ExitThread (
    int retcode
    );
</pre>

<h3>Description</h3>

Cleanup the thread's tls and memory pool and either free the thread if
   it's detached or mark the thread as exited and allow it to be joined.

<p>

Ns_ThreadExit is the preferred function for freeing a thread.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_GetThread</a></h2>

Get the identifier for the current thread

<h3>Syntax</h3>

<pre>    
    void Ns_GetThread(
    Ns_Thread *thread
    );
</pre>

<h3>Description</h3>

Ns_GetThread fills in the unique thread identifier for the current
   thread. (see Ns_WaitForThread)
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_GetThreadId</a></h2>

Get the unique ID number for the current thread

<h3>Syntax</h3>

<pre>    
    int Ns_GetThreadId(void);
</pre>

<h3>Description</h3>

This routine tries to come up with a unique integer corresponding to
   the current thread. (This is the integer that shows up in the log
   files.) Often, this unique ID is the PID, but not always.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_GetThreadLocalStorage</a></h2>

Get the thread local storage

<h3>Syntax</h3>

<pre>    
    int Ns_GetThreadLocalStorage(
    Ns_ThreadLocalStorage * tls,
    void **p
    );
</pre>

<h3>Description</h3>

Fill *p with the value of the thread local storage. Note: If tls has
   not been set within the current the thread *p will be set to NULL.

<p>

Ns_TlsGet is the preferred function for getting thread local storage.
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_InitializeCriticalSection</a></h2>

Initialize a critical section

<h3>Syntax</h3>

<pre>    
    int Ns_InitializeCriticalSection(
    Ns_CriticalSection * section
    );
</pre>

<h3>Description</h3>

Initialize the specified critical section. It is recommended that you
   use a mutex instead of a critical section if possible.

<p>

Ns_CsInit is the preferred function for initializing a critical
   section.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InitializeEvent</a></h2>

Initialize an event object

<h3>Syntax</h3>

<pre>    
    int Ns_InitializeEvent(
    Ns_Event * event
    );
</pre>

<h3>Description</h3>

Initialize an event object.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InitializeMutex</a></h2>

Initialize a mutual exclusion lock

<h3>Syntax</h3>

<pre>    
    int Ns_InitializeMutex(
    Ns_Mutex * mutex
    );
</pre>

<h3>Description</h3>

Initialize a Mutual Exclusion lock for use.

<p>

Ns_MutexInit is the preferred function for initializing a mutex.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InitializeRWLock</a></h2>

Initialize a read/write lock

<h3>Syntax</h3>

<pre>    
    int Ns_InitializeRWLock(
    Ns_RWLock *lock
    );
</pre>

<h3>Description</h3>

Initialize a read/write lock for use. A lock ID is returned via the
   lock parameter, which can be used in the other read/write lock
   functions.

<p>

 About Read/Write Locks
Read/write locks are a serialization mechanism for using data
   structures where multiple reads can happen simultaneously, but where
   writes must happen singly. For example, suppose you have a hash table
   that is heavily used but doesn't change very often. You'd like to have
   multiple threads be able to read from the table without blocking on
   each other, but when you need to update the table, you can do so
   safely without having to worry about other threads reading incorrect
   data.

<p>

The principal feature of read/write locks is the mechanism of which
   locks have priority and which locks must wait. Any number of read
   locks can be pending. If there's a write lock active, the read lock
   acquisition blocks until the write lock is released. Also, only one
   write lock can be in effect. If there are pending read locks active,
   the write lock acquisition blocks until all of the read locks drain.
   If a subsequent read lock acquisition attempt is made while a write
   lock is waiting to acquire, the write lock has priority.

<p>

Ns_RWLockInit is the preferred function for initializing a read/write
   lock.

<h3>Examples</h3>

<pre>
    NS_RWLock lock;
    int GetData (int key)
    {
        /* acquire a read lock */
        Ns_ReadLockRWLock (&lock);
        search through the data structure looking for key's data;

        /* release our read lock */
        Ns_ReadUnlockRWLock (&lock);
        return (value);

    } /* GetData */
    int StoreData (int key, int value)
    {
       /* acquire the write lock */
       Ns_WriteLockRWLock (&lock);
       manipulate the data structure storing key's value;
       /* release the write lock */
       Ns_WriteUnlockRWLock (&lock);
       return (value);
    } /* StoreData */
    ...
    Ns_InitializeRWLock (&lock);
    ...
    (different threads using GetData and StoreData)
    ...
    Ns_DestoryRWLock (&lock);

</pre>

<p>

<hr>

<br>




<h2><a name= href=./>Ns_InitializeSemaphore</a></h2>

Initialize a semaphore

<h3>Syntax</h3>

<pre>    
    int Ns_InitializeSemaphore(
    Ns_Semaphore * sema,
    int beg_count
    );
</pre>

<h3>Description</h3>

Initialize the semaphore with a semaphore count of beg_count.

<p>

Ns_SemaInit is the preferred function for initializing a semaphore.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_LeaveCriticalSection</a></h2>

Leave a critical section

<h3>Syntax</h3>

<pre>    
    int Ns_LeaveCriticalSection(
    Ns_CriticalSection * section
    );
</pre>

<h3>Description</h3>

Leave the specified critical section.

<p>

Ns_CsLeave is the preferred function for leaving a critical section.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_LockMutex</a></h2>

Create a mutual exclusion lock

<h3>Syntax</h3>

<pre>    
    int Ns_LockMutex(
    Ns_Mutex * mutex
    );
</pre>

<h3>Description</h3>

Acquire the mutex. If the mutex is already locked then the current
   thread will block until the mutex is unlocked. Note: mutexes are not
   recursive. If the current thread tries to lock the mutex twice in a
   row, it will block or get an error depending on the platform.
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_MutexDestroy</a></h2>

Destroy a mutex object

<h3>Syntax</h3>

<pre>    
    void Ns_MutexDestroy (
    Ns_Mutex *mutexPtr
    );
</pre>

<h3>Description</h3>

Free the mutex's associated resources.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_MutexInit</a></h2>

Initialize a mutex object

<h3>Syntax</h3>

<pre>    
    void Ns_MutexInit (
    Ns_Mutex *mutexPtr
    );
</pre>

<h3>Description</h3>

Initialize a Mutual Exclusion lock for use.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_MutexLock</a></h2>

Lock a mutex object

<h3>Syntax</h3>

<pre>    
    void Ns_MutexLock (
    Ns_Mutex *mutexPtr
    );
</pre>

<h3>Description</h3>

Acquire the mutex. If the mutex is already locked then the current
   thread will block until the mutex is unlocked. Note: mutexes are not
   recursive. If the current thread tries to lock the mutex twice in a
   row, it will block or get an error depending on the platform.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_MutexUnlock</a></h2>

Unlock a mutex object

<h3>Syntax</h3>

<pre>    
    void Ns_MutexUnlock (
    Ns_Mutex *mutexPtr
    );
</pre>

<h3>Description</h3>

Unlock the mutex.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ReadLockRWLock</a></h2>

Acquire a read lock

<h3>Syntax</h3>

<pre>    
    int Ns_ReadLockRWLock(
    Ns_RWLock *lock
    );
</pre>

<h3>Description</h3>

Ns_ReadLockRWLock acquires a read lock. Any number of read locks can
   be pending. If there's a write lock active, the read lock acquisition
   blocks until the write lock is released.

<p>

For general information about read/write locks and an example showing
   the use of the read/write lock functions, see the Ns_InitializeRWLock
   function.

<p>

Ns_RWLockRdLock is the preferred function for acquiring a read lock.

<p>

<hr>

<br>




<h2><a name= href=./>Ns_ReadUnlockRWLock</a></h2>

Release a read lock

<h3>Syntax</h3>

<pre>    
    int Ns_ReadUnlockRWLock(
    Ns_RWLock *lock
    );
</pre>

<h3>Description</h3>

Ns_ReadUnlockRWLock releases a read lock.

<p>

For general information about read/write locks and an example showing
   the use of the read/write lock functions, see the Ns_InitializeRWLock
   function.

<p>

Ns_RWLockUnlock is the preferred function for releasing a lock.

<p>

<hr>

<br>




<h2><a name= href=./>Ns_ReleaseSemaphore</a></h2>

Increment the semaphore count

<h3>Syntax</h3>

<pre>    
    int Ns_ReleaseSemaphore(
    Ns_Semaphore * sema,
    int count
    );
</pre>

<h3>Description</h3>

Increment the semaphore count.

<p>

Ns_SemaPost is the preferred function for incrementing the semaphore
   count.
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_RWLockDestroy</a></h2>

Destroy a read/write lock

<h3>Syntax</h3>

<pre>    
    void Ns_RWLockDestroy (
    Ns_RWLock*
    );
</pre>

<h3>Description</h3>

Ns_RWLockDestroy frees the read/write lock's associated resources.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_RWLockInit</a></h2>

Initialize a read/write lock

<h3>Syntax</h3>

<pre>    
    void Ns_RWLockInit (
    Ns_RWLock*
    );
</pre>

<h3>Description</h3>

Initialize a read/write lock for use. A lock ID is returned via the
   lock parameter, which can be used in the other read/write lock
   functions.

<p>

 About Read/Write Locks
Read/write locks are a serialization mechanism for using data
   structures where multiple reads can happen simultaneously, but where
   writes must happen singly. For example, suppose you have a hash table
   that is heavily used but doesn't change very often. You'd like to have
   multiple threads be able to read from the table without blocking on
   each other, but when you need to update the table, you can do so
   safely without having to worry about other threads reading incorrect
   data.

<p>

The principal feature of read/write locks is the mechanism of which
   locks have priority and which locks must wait. Any number of read
   locks can be pending. If there's a write lock active, the read lock
   acquisition blocks until the write lock is released. Also, only one
   write lock can be in effect. If there are pending read locks active,
   the write lock acquisition blocks until all of the read locks drain.
   If a subsequent read lock acquisition attempt is made while a write
   lock is waiting to acquire, the write lock has priority.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_RWLockRdLock</a></h2>

Acquire a read lock

<h3>Syntax</h3>

<pre>    
    void Ns_RWLockRdLock (
    Ns_RWLock *lockPtr
    );
</pre>

<h3>Description</h3>

Ns_RWLockRdLock acquires a read lock. Any number of read locks can be
   pending. If there's a write lock active, the read lock acquisition
   blocks until the write lock is released.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_RWLockUnlock</a></h2>

Release a read/write lock

<h3>Syntax</h3>

<pre>    
    void Ns_RWLockUnlock (
    Ns_RWLock *lockPtr
    );
</pre>

<h3>Description</h3>

Ns_RWLockUnlock releases a read or write lock.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_RWLockWrLock</a></h2>

Acquire a write lock

<h3>Syntax</h3>

<pre>    
    void Ns_RWLockWrLock (
    Ns_RWLock *lockPtr
    );
</pre>

<h3>Description</h3>

Ns_RWLockWrLock acquires a write lock. Only one write lock can be in
   effect. If there are pending read locks active, the write lock
   acquisition blocks until all of the read locks drain. If a subsequent
   read lock acquisition attempt is made, the write lock has priority.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_SemaDestroy</a></h2>

Destroy a semaphore object

<h3>Syntax</h3>

<pre>    
    int Ns_SemaDestroy(
    Ns_Sema*
    );
</pre>

<h3>Description</h3>

Free the resources associated with the semaphore.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_SemaInit</a></h2>

Initialize a semaphore

<h3>Syntax</h3>

<pre>    
    int Ns_SemaInit(
    Ns_Sema* ,
    int count
    );
</pre>

<h3>Description</h3>

Initialize the semaphore with a semaphore count of count.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_SemaPost</a></h2>

Increment the semaphore count

<h3>Syntax</h3>

<pre>    
    int Ns_SemaPost(
    Ns_Sema* ,
    int count
    );
</pre>

<h3>Description</h3>

Increment the semaphore count.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_SemaWait</a></h2>

Wait for a semaphore count to be greater than zero.

<h3>Syntax</h3>

<pre>    
    int Ns_SemaWait(
    Ns_Sema*
    );
</pre>

<h3>Description</h3>

If the semaphore count is greater than zero, decrement it and
   continue. Otherwise, block until this is possible.
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_SetThreadLocalStorage</a></h2>

Set thread local storage

<h3>Syntax</h3>

<pre>    
    int Ns_SetThreadLocalStorage(
    Ns_ThreadLocalStorage * tls,
    void *p
    );
</pre>

<h3>Description</h3>

Set the thread local storage tls to the value p.

<h3>Examples</h3>

<pre>
   See the example for Ns_AllocThreadLocalStorage.

<p>

Ns_TlsSet is the preferred function for setting thread local storage.
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_ThreadCreate</a></h2>

Create new thread

<h3>Syntax</h3>

<pre>    
    void Ns_ThreadCreate (
    Ns_ThreadProc* proc,
    void* arg,
    long stackSize,
    Ns_Thread* threadPtr
    );
</pre>

<h3>Description</h3>

Create a new thread.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadExit</a></h2>

Free or exit thread

<h3>Syntax</h3>

<pre>    
    void Ns_ThreadExit (
    int exitCode
    );
</pre>

<h3>Description</h3>

Cleanup the thread's tls and memory pool and either free the thread if
   it's detached or mark the thread as exited and allow it to be joined.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadFree</a></h2>

Free thread pool memory

<h3>Syntax</h3>

<pre>    
    void Ns_ThreadFree (
    void* ptr
    );
</pre>

<h3>Description</h3>

Free previously allocated memory from the per-thread pool.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadGetName</a></h2>

Get thread name

<h3>Syntax</h3>

<pre>    
   char* Ns_ThreadGetName (void);
   </pre>

<h3>Description</h3>

Return a pointer to calling thread's string name, as set with
   Ns_ThreadSetName.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadId</a></h2>

Get thread ID

<h3>Syntax</h3>

<pre>    
   int Ns_ThreadId (void);
   </pre>

<h3>Description</h3>

Return the numeric thread id for the calling thread.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadJoin</a></h2>

Wait for thread exit

<h3>Syntax</h3>

<pre>    
    void Ns_ThreadJoin (
    Ns_Thread* threadPtr,
    int* exitCodePtr
    );
</pre>

<h3>Description</h3>

Wait for exit of a non-detached thread.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadMalloc</a></h2>

Allocate thread pool memory

<h3>Syntax</h3>

<pre>    
    void* Ns_ThreadMalloc (
    unsigned int size
    );
</pre>

<h3>Description</h3>

Allocate thread-pool memory.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadPool</a></h2>

Get thread pool memory

<h3>Syntax</h3>

<pre>    
    Ns_Pool* Ns_ThreadPool (void);
</pre>

<h3>Description</h3>

Get this thread's memory pool.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadRealloc</a></h2>

Realloc thread pool memory

<h3>Syntax</h3>

<pre>    
    void* Ns_ThreadRealloc (
    void* ptr,
    unsigned int size
    );
</pre>

<h3>Description</h3>

realloc for thread memory pools.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadSelf</a></h2>

Get handle to thread

<h3>Syntax</h3>

<pre>    
    void Ns_ThreadSelf (
    Ns_Thread* threadPtr
    );
</pre>

<h3>Description</h3>

Return opaque handle to thread's data structure.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadSetname</a></h2>

Set thread name

<h3>Syntax</h3>

<pre>    
    void Ns_ThreadSetName (
    char* name
    );
</pre>

<h3>Description</h3>

Set the name of the thread, which is used in the server.log. The name
   can be retrieved with Ns_ThreadGetName.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ThreadYield</a></h2>

Yield processor time to runnable threads

<h3>Syntax</h3>

<pre>    
    void Ns_ThreadYield(void);
</pre>

<h3>Description</h3>

Ns_ThreadYield yields its processor time to any runnable threads with
   equal or higher priority.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_TimedWaitForEvent</a></h2>

Wait for an event for a specified time

<h3>Syntax</h3>

<pre>    
    int Ns_TimedWaitForEvent(
    Ns_Event * event,
    Ns_Mutex * lock,
    int usec
    );
</pre>

<h3>Description</h3>

Same as Ns_WaitForEvent except that it has a timeout in seconds. On
   timeout, the function returns NS_TIMEOUT.

<h3>Examples</h3>

<pre>
        Ns_LockMutex(&lock);
        if (!ready) {
                result = Ns_TimedWaitForEvent(&ev, &lock, 10);
                if (result == NS_TIMEOUT) {
                        ... handle timeout ...
                } else if (result != NS_OK) {
                        ... handle error ...
                }
        }
        Ns_UnlockMutex(&lock);

   
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_TlsAlloc</a></h2>

Allocate thread local storage

<h3>Syntax</h3>

<pre>    
    void Ns_TlsAlloc (
    Ns_Tls* ,
    Ns_TlsCleanup*
    );
</pre>

<h3>Description</h3>

Allocate thread-local-storage. This is unneeded if the tls variable is
   initialized to 0 (as static data is). See pthread_setspecific(3P) for
   details on thread-local storage.

<p>

This function is a renamed version of Ns_AllocThreadLocalStorage.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_TlsGet</a></h2>

Get thread local storage

<h3>Syntax</h3>

<pre>    
    void* Ns_TlsGet (
    Ns_Tls *tlsPtr
    );
</pre>

<h3>Description</h3>

Get thread-local-storage. This function is a renamed version of
   Ns_GetThreadLocalStorage.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_TlsSet</a></h2>

Set thread local storage

<h3>Syntax</h3>

<pre>    
    void Ns_TlsSet (
    Ns_Tls *tlsPtr ,
    void *value
    );
</pre>

<h3>Description</h3>

Set thread local storage. This function is a renamed version of
   Ns_SetThreadLocalStorage.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_UnlockMutex</a></h2>

Unlock the mutual exclusion lock

<h3>Syntax</h3>

<pre>    
    int Ns_UnlockMutex(
    Ns_Mutex * mutex
    );
</pre>

<h3>Description</h3>

Unlock the mutex.

<p>

Ns_MutexLock is the preferred function for unlocking a mutex.

<h3>Examples</h3>

<pre>
   See the example for Ns_LockMutex.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_UTimedWaitForEvent</a></h2>

Wait for an event for a specified time, in microseconds

<h3>Syntax</h3>

<pre>    
    int Ns_UTimedWaitForEvent(
    Ns_Event *event,
    Ns_Mutex *lock,
    int seconds,
    int microseconds
    );
</pre>

<h3>Description</h3>

Same as Ns_WaitForEvent except that it has a timeout in microseconds.
   On timeout, the function returns NS_TIMEOUT.

<p>

On the Irix platform, the timeout granularity is still in seconds. In
   this case, if you specify a timeout of less than one second, it will
   be treated as one second.

   
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_WaitForEvent</a></h2>

Wait for an event

<h3>Syntax</h3>

<pre>    
    int Ns_WaitForEvent(
    Ns_Event * event,
    Ns_Mutex * lock
    );
</pre>

<h3>Description</h3>

Unlock the lock and wait for the event. This function blocks the
   current thread's execution until the event has been set and it can
   reacquire the lock. The mutex lock is locked before and after the
   call.

<h3>Examples</h3>

<pre>
    static int ready = 0;
    static Ns_Event ev;
    static Ns_Mutex lock;

    void
    Init(void)
    {
        Ns_InitializeMutex(&lock);
        Ns_InitializeEvent(&ev);
    }

    void
    Waiter(void)
    {
        Ns_LockMutex(&lock);
        if (!ready) {
                Ns_WaitForEvent(&ev, &lock);
        }
        Ns_UnlockMutex(&lock);
        ... resource ready ...
    }

   
</pre>


<p>

<hr>

<br>






<h2><a name= href=./>Ns_WaitForSemaphore</a></h2>

Wait for a semaphore count to be greater than zero.

<h3>Syntax</h3>

<pre>    
    int Ns_WaitForSemaphore(
    Ns_Semaphore * sema
    );
</pre>

<h3>Description</h3>

If the semaphore count is greater than zero, decrement it and
   continue. Otherwise, block until this is possible.

<p>

Ns_SemaWait is the preferred function for waiting for a semaphore.

<h3>Examples</h3>

<pre>
    static Ns_Semaphore sem;

    void

Init(void)
    {
        Ns_InitializeSemaphore(&sem, 0);
    }

    void
    Waiter(void)
    {
        Ns_WaitForSemaphore(&sem);
        ... access resource ...
    }

    void
    Releaser(void)
    {
        Ns_ReleaseSemaphore(&sem, 1);
    }

   
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_WaitForThread</a></h2>

Wait for a thread to exit

<h3>Syntax</h3>

<pre>    
    int Ns_WaitForThread(
    Ns_Thread *thread
    );
</pre>

<h3>Description</h3>

This routine blocks the current thread's execution until the specified
   thread exits.

<h3>Examples</h3>


<pre>
   See the example for Ns_BeginThread.
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_WaitThread</a></h2>

Wait for thread to exit

<h3>Syntax</h3>

<pre>    
    int Ns_WaitThread (
    Ns_Thread* thread,
    int* retcode
    );
</pre>

<h3>Description</h3>

This function blocks the current thread's execution until the
   specified thread exits.
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_WriteLockRWLock</a></h2>

Acquire a write lock

<h3>Syntax</h3>

<pre>    
    int Ns_WriteLockRWLock(
    Ns_RWLock *lock
    );
</pre>

<h3>Description</h3>

Ns_WriteLockRWLock acquires a write lock. Only one write lock can be
   in effect. If there are pending read locks active, the write lock
   acquisition blocks until all of the read locks drain. If a subsequent
   read lock acquisition attempt is made, the write lock has priority.

<p>

For general information about read/write locks and an example showing
   the use of the read/write lock functions, see the Ns_InitializeRWLock
   function.

<p>

Ns_RWLockWrLock is the preferred function for acquiring a write lock.

<p>

<hr>

<br>



<h2><a name= href=./>Ns_WriteUnlockRWLock</a></h2>

Release a write lock.

<h3>Syntax</h3>

<pre>    
    int Ns_WriteUnlockRWLock(
    Ns_RWLock *lock
    );
</pre>

<h3>Description</h3>

Ns_WriteUnlockRWLock releases a write lock.

<p>

For general information about read/write locks and an example showing
   the use of the read/write lock functions, see the Ns_InitializeRWLock
   function.

<p>

Ns_RWLockUnlock is the preferred function for releasing a lock.

<p>

<hr>

<br>




</body>
</html>
