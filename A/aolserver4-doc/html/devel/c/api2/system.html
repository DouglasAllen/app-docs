<html>
<head>
<title>AOLserver</title>
</head>
<body>

<h1>Operating System C Library Functions</h1>

<p>
$Header: /cvsroot/aolserver/aolserver.com/docs/devel/c/index.html,v 1.1 2002/03/07 19:15:35 kriston Exp $
<p>



<h2><a name= href=./>Ns_AdjTime</a></h2>


Adjust Ns_Time.

<h3>Syntax</h3>

<pre>    
    Ns_AdjTime(
    Ns_Time *timePtr
    );
</pre>

<h3>Description</h3>

Adjust an Ns_Time so that the values are in range. If usec is
negative, sec is decremented; if usec is over 1000000, sec is
incremented.

<p>

<hr>

<br>



<h2><a name= href=./>Ns_Asctime</a></h2>

Perform asctime_r

<h3>Syntax</h3>

<pre>    
    char* Ns_Asctime (
    const struct tm* tmPtr
    );
</pre>

<h3>Description</h3>

This function is a wrapper around asctime_r(3C). This converts a tm
   struture to a 26-character string. The value returned by this function
   will be changed by additional calls to it within the same thread, so
   make a copy of the value if needed.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_Calloc</a></h2>

Allocate a zero-filled block of memory

<h3>Syntax</h3>

<pre>    
    void *Ns_Calloc(
    size_t num,
    size_t size
    );
</pre>

<h3>Description</h3>

The Ns_Calloc function allocates a block of zero-filled memory large
   enough to hold the given number of elements of the given size. This
   function replaces the system calloc function.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_CheckStack</a></h2>

Check for thread stack overflow

<h3>Syntax</h3>

<pre>    
   int Ns_CheckStack (void);
   </pre>

<h3>Description</h3>

Check for possible thread stack overflow. This function returns NS_OK
   if stack appears ok, otherwise it returns NS_ERROR.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_CloseOnExec</a></h2>

Set close-on-exec flag

<h3>Syntax</h3>

<pre>    
    int Ns_CloseOnExec (
    int fd
    );
</pre>

<h3>Description</h3>

Set the close-on-exec flag on a file descriptor.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_Ctime</a></h2>

Perform ctime_r

<h3>Syntax</h3>

<pre>    
    char* Ns_Ctime (
    const time_t* clock
    );
</pre>

<h3>Description</h3>

This function is a wrapper around ctime_r(3C).
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_DiffTime</a></h2>

Get difference between two times

<h3>Syntax</h3>

<pre>    
    void Ns_DiffTime (
    Ns_Time* t1,
    Ns_Time* t2,
    Ns_Time* result
    );
</pre>

<h3>Description</h3>

Determine the difference in seconds between two Ns_Time structures.
   The result is put into result.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_DupHigh</a></h2>

Move file descriptors

<h3>Syntax</h3>

<pre>    
    Ns_DupHigh(
    int *fd
    );
</pre>

<h3>Description</h3>

Ns_DupHigh moves file descriptors above 256 on platforms where the
   file descriptor in the stdio FILE structure is an unsigned char. By
   calling Ns_DupHigh on file descriptors that you know will not be
   buffered, you can leave as many low file descriptors available for
   stdio as possible. Ns_DupHigh is not supported on platforms where this
   is not an issue.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_ExecArgblk</a></h2>

Execute file with argument string

<h3>Syntax</h3>

<pre>    
    int Ns_ExecArgblk (
    char* sExec,
    char* sDir,
    int fdIn,
    int fdOut,
    char* argBlk,
    Ns_Set* env
    );
</pre>

<h3>Description</h3>

Change current directory to sDir if it is not NULL and executes the
   file sExec. All input will come from fdIn if it's greater than 0;
   otherwise stdin will be used. All output will go to fdOut if it's
   greater than 0; otherwise stdout will be used.

<p>

The argBlk is a string of null-separated arguments, terminated with
   two nulls, like this: "foo\0bar\0\0".

<p>

The env is an Ns_Set containing environment variables to pass the
   program.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ExecArgv</a></h2>

Execute file with argument array

<h3>Syntax</h3>

<pre>    
    int Ns_ExecArgv (
    char* sExec,
    char* sDir,
    int fdIn,
    int fdOut,
    char** argv,
    Ns_Set* env
    );
</pre>

<h3>Description</h3>

Change current directory to sDir if it is not NULL and executes the
   file sExec. All input will come from fdIn if it's greater than 0;
   otherwise stdin will be used. All output will go to fdOut if it's
   greater than 0; otherwise stdout will be used.

<p>

The argv is a null-terminated array of argument strings, like this: {
   "foo", "bar", NULL }.

<p>

The env is an Ns_Set containing environment variables to pass the
   program.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ExecProc</a></h2>

Execute file with argument array

<h3>Syntax</h3>

<pre>    
    int Ns_ExecProc (
    char* sExec,
    char** argv
    );
</pre>

<h3>Description</h3>

Execute the file sExec. All input will come from stdin. All output
   will go to stdout.

<p>

The argv is a null-terminated array of argument strings, like this: {
   "foo", "bar", NULL }.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ExecProcess</a></h2>

Execute file with argument string

<h3>Syntax</h3>

<pre>    
    int Ns_ExecProcess (
    char* sExec,
    char* sDir,
    int fdIn,
    int fdOut,
    char* argBlk,
    Ns_Set* env
    );
</pre>

<h3>Description</h3>

Change current directory to sDir if it is not NULL and executes the
   file sExec. All input will come from fdIn if it's greater than 0;
   otherwise stdin will be used. All output will go to fdOut if it's
   greater than 0; otherwise stdout will be used.

<p>

The argBlk is a string of null-separated arguments, terminated with
   two nulls, like this: "foo\0bar\0\0".

<p>

The env is an Ns_Set containing environment variables to pass the
   program.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_Fatal</a></h2>

Log a fatal error and shutdown

<h3>Syntax</h3>

<pre>    
    void Ns_Fatal(
    char *fmt,
    ...
    );
</pre>

<h3>Description</h3>

This function calls Ns_Log with the Fatal severity and then shuts down
   the server.
</pre>


<p>

<hr>

<br>


<h2><a name= href=./>Ns_Fork</a></h2>

Perform a fork

<h3>Syntax</h3>

<pre>    
    int Ns_Fork (void);
</pre>

<h3>Description</h3>

Performs a fork(), or on Solaris, fork1().
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_Free</a></h2>

Free a block of allocated memory

<h3>Syntax</h3>

<pre>    
    void *Ns_Free(
    void *buf
    );
</pre>

<h3>Description</h3>

The Ns_Free function frees any memory allocated by the Ns_Malloc,
   Ns_Calloc, or Ns_Realloc functions. This function replaces the system
   free function.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_GetTime</a></h2>

Perform gettimeofday

<h3>Syntax</h3>

<pre>    
    void Ns_GetTime (
    Ns_Time*
    );
</pre>

<h3>Description</h3>

This function is a wrapper for gettimeofday(3B).
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_GetUid</a></h2>

Return UID of user

<h3>Syntax</h3>

<pre>    
    int Ns_GetUid (
    char* user
    );
</pre>

<h3>Description</h3>

Returns the Unix UID of the user running the server.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_GetUserHome</a></h2>

Get UNIX user's home directory

<h3>Syntax</h3>

<pre>    
    int Ns_GetUserHome(
    Ns_DString *pds,
    char *user
    );
</pre>

<h3>Description</h3>

The Ns_GetUserHome function returns NS_TRUE and appends the user's
   home directory to the Ns_DString passed in, or it returns NS_FALSE if
   the user doesn't exist.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_Gmtime</a></h2>

Perform gmtime

<h3>Syntax</h3>

<pre>    
    struct tm* Ns_Gmtime (
    const time_t* clock
    );
</pre>

<h3>Description</h3>

This function is a wrapper for gmtime(3C).
</pre>


<p>

<hr>

<br>


<h2><a name= href=./>Ns_HomePath</a></h2>

Construct a path name relative to the AOLserver home directory

<h3>Syntax</h3>

<pre>    
    char *Ns_HomePath(
    Ns_DString * dest,
    char *relpath
    );
</pre>

<h3>Description</h3>

The Ns_HomePath function constructs a path name by appending the given
   relative path to the AOLserver home directory. The resulting path name
   is appended to the given Ns_DString.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_HttpTime</a></h2>

Return a formatted time string

<h3>Syntax</h3>

<pre>    
    char *Ns_HttpTime(
    Ns_DString *pds
    time_t *when
    );
</pre>

<h3>Description</h3>

The Ns_HttpTime function converts given time to the appropriate format
   for an HTTP header or log file. The Ns_HttpTime function returns the
   time and date with a four digit year, e.g., "Sun, 06 Nov 1994 08:49:37
   GMT".

<p>

If when is NULL, the function returns a string containing the current
   time. The formatted time string is appended to the specified
   Ns_DString (pds).
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_IncrTime</a></h2>

Increment time by seconds and microseconds

<h3>Syntax</h3>

<pre>    
    void Ns_IncrTime (
    Ns_Time* time,
    time_t sec,
    long usec
    );
</pre>

<h3>Description</h3>

Increment time by sec.usec, where usec is microseconds.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_InetNtoa</a></h2>

Perform inet_ntoa

<h3>Syntax</h3>

<pre>    
    char* Ns_InetNtoa (
    struct in_addr addr
    );
</pre>

<h3>Description</h3>

This function wraps inet_ntoa(3N).
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoBootTime</a></h2>

Return server boot time

<h3>Syntax</h3>

<pre>    
   int Ns_InfoBootTime (void);
   </pre>

<h3>Description</h3>

Return the time (in time_t form) of the most recent server boot.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoBuildDate</a></h2>

Return AOLserver build date

<h3>Syntax</h3>

<pre>    
    char *Ns_InfoBuildDate(void);
</pre>

<h3>Description</h3>

The Ns_InfoBuildDate function returns the date and time AOLServer was
   compiled.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoConfigFile</a></h2>

Return full path name of the configuration file in use.

<h3>Syntax</h3>

<pre>    
    char *Ns_InfoConfigFile(void)
</pre>

<h3>Description</h3>

Return full path name of the configuration file in use.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoErrorLog</a></h2>

Return error log name

<h3>Syntax</h3>

<pre>    
    char* Ns_InfoErrorLog (void);
</pre>

<h3>Description</h3>

Return the name of the error log.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoHomePath</a></h2>

Return directory where the AOLserver is installed.

<h3>Syntax</h3>

<pre>    
    char *Ns_InfoHomePath(void)
</pre>

<h3>Description</h3>

Return directory where the AOLserver is installed.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoHostname</a></h2>

Return hostname of server

<h3>Syntax</h3>

<pre>    
    char* Ns_InfoHostname (void);
</pre>

<h3>Description</h3>

Return the hostname that AOLserver thinks it's running on, as
   specified in the configuration file.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoLabel</a></h2>

Return source code label for server

<h3>Syntax</h3>

<pre>    
    char *Ns_InfoLabel(void);
</pre>

<h3>Description</h3>

Returns the source code label for the server. If no label was used,
   "unlabeled" is returned. You can use these functions to provide the
   source code label when you report problems with the server.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoPid</a></h2>

Return server pid

<h3>Syntax</h3>

<pre>    
    int Ns_InfoPid (void);
</pre>

<h3>Description</h3>

Return pid of AOLserver.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoPlatform</a></h2>

Return platform

<h3>Syntax</h3>

<pre>    
    char* Ns_InfoPlatform (void);
</pre>

<h3>Description</h3>

Returns platform name, e.g. "IRIX".
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoServerName</a></h2>

Return AOLserver name string ("AOLserver").

<h3>Syntax</h3>

<pre>    
    char *Ns_InfoServerName(void)
</pre>

<h3>Description</h3>

Return AOLserver name string ("AOLserver").
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoServersStarted</a></h2>

Determine if server has started

<h3>Syntax</h3>

<pre>    
    int Ns_InfoServersStarted (void);
</pre>

<h3>Description</h3>

Return TRUE if the server has started, i.e., if initialization and
   module loading is complete.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoServerVersion</a></h2>

Return AOLserver version string.

<h3>Syntax</h3>

<pre>    
    char *Ns_InfoServerVersion(void)
</pre>

<h3>Description</h3>

Return AOLserver version string.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoShutdownPending</a></h2>

Determine if a server shutdown is pending

<h3>Syntax</h3>

<pre>    
    int Ns_InfoShutdownPending (void);
</pre>

<h3>Description</h3>

Return TRUE if there is there a shutdown pending, i.e., if an INTR
   signal has been received or if ns_shutdown has been called.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoStarted</a></h2>

Determine if server has started

<h3>Syntax</h3>

<pre>    
    int Ns_InfoStarted (void);
</pre>

<h3>Description</h3>

Return TRUE if the server has started, i.e., if initialization and
   module loading is complete.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_InfoUptime</a></h2>

Return time server has been running

<h3>Syntax</h3>

<pre>    
    int Ns_InfoUptime (void);
</pre>

<h3>Description</h3>

Return how long, in seconds, AOLserver has been running.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_LibPath</a></h2>

Construct path relative to lib

<h3>Syntax</h3>

<pre>    
    char* Ns_LibPath (Ns_DString* dest,...);
</pre>

<h3>Description</h3>

Make a path relative to $ASHOME/lib/ given the specified destination.
   For example, if AOLserver is running out of /disk2/aolserver, the
   following call would return "/disk2/aolserver/lib/foo/bar":
    Ns_LibPath("foo", "bar", NULL);

   
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_Localtime</a></h2>

Perform localtime

<h3>Syntax</h3>

<pre>    
    struct tm* Ns_Localtime (
    const time_t* clock
    );
</pre>

<h3>Description</h3>

This function wraps localtime(3C).
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_Log</a></h2>

Log formatted message

<h3>Syntax</h3>

<pre>    
    void Ns_Log(
    Ns_LogSeverity severity,
    char *fmt,
    ...
    );
</pre>

<h3>Description</h3>

The Ns_Log function writes formatted messages to the server log file.
   Allowable values for severity are:

<p>

Notice

<p>

Something interesting occurred.

<p>

Warning

<p>

Maybe something bad occurred.

<p>

Error

<p>

Something bad occurred.

<p>

Fatal

<p>

Something extremely bad occurred. The server will shut down after
   logging this message.

<p>

Bug

<p>

Something occurred that implies there is a bug in your code.

<p>

Debug

<p>

If the server is in Debug mode, the message is printed. Debug mode is
   specified in the [ns/parameters] section of the configuration file. If
   the server is not in debug mode, the message is not printed.

<h3>Examples</h3>

<pre>
    char *hServer; /* server handle */
    char *hModule; /* module handle */
    Ns_Log(Notice, "Initializing module %s on server %s",
                                        hModule, hServer);

   
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_LogRoll</a></h2>

Roll server log

<h3>Syntax</h3>

<pre>    
    int Ns_LogRoll (void);
</pre>

<h3>Description</h3>

Roll the server.log file, renaming the existing file with the date and
   starting a new log file.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_LogTime</a></h2>

Construct local date and time for log file

<h3>Syntax</h3>

<pre>    
    char *Ns_LogTime(
    char *dateTimeBuf
    );
</pre>

<h3>Description</h3>

The Ns_LogTime function constructs the local date and time for use in
   the log file. Upon completion, dateTimeBuf will contain the formatted
   string. Ns_LogTime is used by Ns_Log to create log file entries.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_MakePath</a></h2>

Construct a path name from a list of path elements

<h3>Syntax</h3>

<pre>    
    char *Ns_MakePath(
    Ns_DString * dest,
    ...
    );
</pre>

<h3>Description</h3>

The Ns_MakePath function constructs a path name by appending a list of
   path elements to the given Ns_DString. The path elements are separated
   by single slashes, and the resulting path name is appended to the
   given Ns_DString. The last argument needs to be NULL to indicate the
   end of the argument list.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_Malloc</a></h2>

Allocate a block of memory

<h3>Syntax</h3>

<pre>    
    void *Ns_Malloc(
    size_t size
    );
</pre>

<h3>Description</h3>

The Ns_Malloc function returns a block of memory of the given size.
   This function replaces the system malloc function.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_ModuleLoad</a></h2>


Load a module into AOLserver

<h3>Syntax</h3>

<pre>    
    int Ns_ModuleLoad(
    char *hServer,
    char *hModule,
    char *sModuleFile,
    char *sInitProc
    );
</pre>

<h3>Description</h3>

The Ns_ModuleLoad function loads a module into AOLserver and calls the
   initialization routine (sInitProc). If sInitProc is NULL, the
   initialization routine used defaults to Ns_ModuleInit.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ModulePath</a></h2>

Construct a path from base path

<h3>Syntax</h3>

<pre>    
    char *Ns_ModulePath(
    Ns_DString *dest,
    char *hServer,
    char *hModule,
    ...
    );
</pre>

<h3>Description</h3>

The Ns_ModulePath function constructs a path by appending the final
   variable arguments to the base path defined by a module on the
   specified server. The list of arguments must end with NULL.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_ModuleSymbol</a></h2>

Return symbol

<h3>Syntax</h3>

<pre>    
    int Ns_ModuleSymbol(
    char *sModuleFile,
    char *sSymbolName
    );
</pre>

<h3>Description</h3>

The Ns_ModuleSymbol function returns a pointer to the value of a
   symbol in a particular shared library.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_NormalizePath</a></h2>

Normalize a path name

<h3>Syntax</h3>

<pre>    
    char *Ns_NormalizePath(
    Ns_DString *dest,
    char *path
    );
</pre>

<h3>Description</h3>

This function removes any extraneous slashes from the path and
   resolves "." and ".." references. The result is appended to the given
   Ns_DString. For example
    Ns_NormalizePath(&ds,
"/dog/cat/../../rat/../../dog//mouse/..");

   appends "/dog" to the Ns_DString.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_PageRoot</a></h2>

Return path name of the AOLserver pages directory for a server.

<h3>Syntax</h3>

<pre>    
    char *Ns_PageRoot(
    char *hServer
    );
</pre>

<h3>Description</h3>

Return path name of the AOLserver pages directory for a server.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_ParseHttpTime</a></h2>

Convert Http time into time_t

<h3>Syntax</h3>

<pre>    
    time_t Ns_ParseHttpTime (
    char* str
    );
</pre>

<h3>Description</h3>

Convert a time like "Thursday, 10-Jun-93 01:29:59 GMT" or "Thu, 10 Jan
   1993 01:29:59 GMT" into time_t.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_PathIsAbsolute</a></h2>

Check for an absolute path name

<h3>Syntax</h3>

<pre>    
    int Ns_PathIsAbsolute(
    char *path
    );
</pre>

<h3>Description</h3>

This function returns 1 if the path is absolute and 0 otherwise. Under
   Unix, an absolute path starts with a `/'.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_PoolAlloc</a></h2>

Allocate memory within a pool

<h3>Syntax</h3>

<pre>    
    void* Ns_PoolAlloc (
    Ns_Pool* pool,
    unsigned int size
    );
</pre>

<h3>Description</h3>

Alloc memory within a pool. Memory pools are thread-specific memory
   that reduce the number of globally-locking malloc(3C) calls.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_PoolCreate</a></h2>

Create a new memory pool

<h3>Syntax</h3>

<pre>    
    Ns_Pool* Ns_PoolCreate (
    char* name
    );
</pre>

<h3>Description</h3>

Create a new memory pool with the specified name.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_PoolDestroy</a></h2>

Destroy a memory pool

<h3>Syntax</h3>

<pre>    
    void Ns_PoolDestroy (
    Ns_Pool* pool
    );
</pre>

<h3>Description</h3>

Destroy the specified memory pool.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_PoolDump</a></h2>

Debug a memory pool

<h3>Syntax</h3>

<pre>    
    void Ns_PoolDump (
    int fd,
    Ns_Pool* pool
    );
</pre>

<h3>Description</h3>

Write information about the pool to the open file descriptor fd.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_PoolFree</a></h2>

Free pool memory

<h3>Syntax</h3>

<pre>    
    void Ns_PoolFree (
    Ns_Pool* pool,
    void* ptr
    );
</pre>

<h3>Description</h3>

Free pool memory.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_PoolRealloc</a></h2>

Reallocate pool memory

<h3>Syntax</h3>

<pre>    
    void* Ns_PoolRealloc (
    Ns_Pool* pool,
    void* ptr,
    unsigned int size
    );
</pre>

<h3>Description</h3>

Perform realloc for pools. See the realloc(3C) man page.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_PoolTrace</a></h2>

Trace a memory pool

<h3>Syntax</h3>

<pre>    
    int Ns_PoolTrace (
    char* filename
    );
</pre>

<h3>Description</h3>

Open the specified filename to contain debugging information and begin
   debugging. Returns NS_OK or NS_ERROR
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_Readdir</a></h2>

Perform readdir

<h3>Syntax</h3>

<pre>    
    struct dirent* Ns_Readdir (
    DIR* pDir
    );
</pre>

<h3>Description</h3>

This funciton wraps readdir(3B).
</pre>


<p>

<hr>

<br>


<h2><a name= href=./>Ns_Realloc</a></h2>

Resize a previously allocated block of memory

<h3>Syntax</h3>

<pre>    
    void *Ns_Realloc(
    void *buf,
    size_t size
    );
</pre>

<h3>Description</h3>

The Ns_Realloc function reallocates a block of memory previously
   allocated with Ns_Malloc or Ns_Calloc to the given size. The block of
   memory may or may not move as a result. This function replaces the
   system realloc function.
</pre>


<p>

<hr>

<br>






<h2><a name= href=./>Ns_RollFile</a></h2>

Rename a file and increment its backup number

<h3>Syntax</h3>

<pre>    
    int Ns_RollFile(
    char *filename,
    int backupMax
    );
</pre>

<h3>Description</h3>

The Ns_RollFile function renames the specified file, incrementing its
   backup number (file extension). The backupMax argument must be between
   1 and 1000. Ns_RollFile returns a status of NS_ERROR or NS_OK.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_SetUrlToFileProc</a></h2>

Customize relative file mapping

<h3>Syntax</h3>

<pre>    
    void Ns_SetUrlToFileProc(
    char *hserver,
    Ns_UrlToFileProc *proc
    );
</pre>

<h3>Description</h3>

Ns_SetUrlToFileProc() sets the procedure pointed to by proc to be
   called by Ns_UrlToFile() to map a URL to a file pathname. The
   interface of the procedure pointed to by proc must have the same
   interface as Ns_UrlToFile().

<p>

A NULL proc argument to Ns_SetUrlToFileProc() causes Ns_UrlToFile()
   afterwards to call a default procedure.

<h3>Examples</h3>

<pre>
    int
    Ns_ModuleInit(char *hServer, char *hModule)
    {
        Ns_SetUrlToFileProc(hServer, AliasedUrlToFile);

        return NS_OK;
    }

    static int
    AliasedUrlToFile(Ns_DString *dest, char *hServer, char *relpath)
    {
        char   *pageRoot;

        /*
         * construct dest from hServer and relpath
         */

        pageRoot = Ns_PageRoot(hServer);
        Ns_MakePath(dest, pageRoot, relpath, NULL);

        return NS_OK;
    }

   See the alias C example for a more comprehensive example.

</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_SetUserAuthorizeProc</a></h2>

Set function used by Ns_AuthorizeUser

<h3>Syntax</h3>

<pre>    
    void Ns_SetUserAuthorizeProc(
    Ns_UserAuthorizeProc *procPtr
    );
</pre>

<h3>Description</h3>

Sets a procedure to handle calls to Ns_AuthorizeUser. This function
   should only be called once per execution of AOLserver. The procPtr
   should be of the form:
    typedef int (Ns_UserAuthorizeProc) (char *user, char *passwd);

   It should return NS_OK on a match or NS_ERROR if any problem is
   encountered or the password does not match.
</pre>


<p>

<hr>

<br>









<h2><a name= href=./>Ns_Sigmask</a></h2>

Perform sigprocmask

<h3>Syntax</h3>

<pre>    
    int Ns_Sigmask (
    int how,
    sigset_t* set,
    sigset_t* oset
    );
</pre>

<h3>Description</h3>

This function wraps sigprocmask(2).
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_Signal</a></h2>

Install signal handler

<h3>Syntax</h3>

<pre>    
    int Ns_Signal (
    int sig, void (*proc) (void)
    );
</pre>

<h3>Description</h3>

Install a handler for a signal. This function is essentially a wrapper
   around signal(2).
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_Sigwait</a></h2>

Perform sigwait

<h3>Syntax</h3>

<pre>    
    int Ns_Sigwait (
    sigset_t* set,
    int* sig
    );
</pre>

<h3>Description</h3>

This function wraps sigwait(3).
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_UrlIsDir</a></h2>

Check if a directory that corresponds to a URL exists

<h3>Syntax</h3>

<pre>    
    int Ns_UrlIsDir(
    char *hServer,
    char *URL
    );
</pre>

<h3>Description</h3>

The Ns_UrlIsDir function constructs a directory name by appending the
   URL to the current AOLserver pages directory for the specified server.
   It returns 1 if the directory exists.

<h3>Examples</h3>

<pre>
   See the example for Ns_UrlIsFile.
</pre>


<p>

<hr>

<br>




<h2><a name= href=./>Ns_UrlIsFile</a></h2>

Check if a file that corresponds to a URL exists

<h3>Syntax</h3>

<pre>    
    int Ns_UrlIsFile(
    char *hServer,
    char *URL
    );
</pre>

<h3>Description</h3>

The Ns_UrlIsFile function constructs a file name by appending the URL
   to the current AOLserver pages directory for the specified server. It
   returns 1 if the file exists and is a regular file.

<h3>Examples</h3>

<pre>
    /* IsFile - Simple request to determine if an URL is a file. */
    int
    IsFile(Ns_Conn *conn, void *ctx)
    {
        int isfile;
        char *server;

        server = Ns_ConnServer(conn);
        isfile = Ns_UrlIsFile(server, conn->request->url);
        if (isfile) {
                Ns_ConnReturnNotice(conn, 200, "File", NULL);
        } else {
                Ns_ConnReturnNotice(conn, 200, "Not a File", NULL);
        }
        return NS_OK;
    }

   
</pre>


<p>

<hr>

<br>





<h2><a name= href=./>Ns_UrlToFile</a></h2>

Construct the filename that corresponds to a URL

<h3>Syntax</h3>

<pre>    
    int Ns_UrlToFile(
    Ns_DString *dest,
    char *hServer,
    char *URL
    );
</pre>

<h3>Description</h3>

The Ns_UrlToFile function writes the full path name of the file
   corresponding to the given URL. The result is appended to the
   Ns_DString. The function does not check that the file exists or is
   readable by the AOLserver process. This function returns a status of
   NS_OK or NS_ERROR.

<h3>Examples</h3>

<pre>
    /* A simple page fetch request function. */
    int
    SimpleFetch(Ns_Conn *conn, void *ctx)
    {
        Ns_DString ds;
        FILE fp;
        char *server;

        Ns_DStringInit(&ds);
        server = Ns_ConnServer(conn);
        Ns_UrlToFile(&ds, server, conn->request->url);
        fp = fopen(ds.string, "r");
        Ns_ConnSendOpenFp(conn, fp, -1);
        fclose(fp);
        Ns_DStringFree(&ds);
        return NS_OK;
    }

   
</pre>


<p>

<hr>

<br>


<h2><a name= href=./>Ns_WaitForProcess</a></h2>

Wait for process to exit

<h3>Syntax</h3>

<pre>    
    int Ns_WaitForProcess (
    int iPid,
    int* pExitCode
    );
</pre>

<h3>Description</h3>

Wait for a proess to exit and write information about the process to
   the log. This function is essentially a wrapper around waitpid(2). It
   returns NS_OK if the process exited normally.
</pre>


<p>

<hr>

<br>



<h2><a name= href=./>Ns_WaitProcess</a></h2>

Wait for process to exit

<h3>Syntax</h3>

<pre>    
    int Ns_WaitProcess (
    int iPid,
    );
</pre>

<h3>Description</h3>

Wait for a proess to exit and write information about the process to
   the log. This function is essentially a wrapper around waitpid(2). It
   returns NS_OK if the process exited normally.
</pre>


<p>

<hr>

<br>


</body>
</html>
