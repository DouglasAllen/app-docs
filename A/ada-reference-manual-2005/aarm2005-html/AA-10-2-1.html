<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Elaboration Control</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Indented1 {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-10-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-11.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>10.2.1 Elaboration Control</H1>
<div class="paranum">1</div>
<div class="Normal">[<SPAN STYLE="font-size: 80%">{<I>elaboration control</I>}</SPAN> 
<A NAME="I4331"></A>This subclause defines pragmas that help control 
the elaboration order of <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN>s.] 
</div>

<H4 Class="centered">Language Design Principles</H4>
<div class="paranum">1.a</div>
<div class="Annotations">The rules governing preelaboration are designed 
to allow it to be done largely by bulk initialization of statically allocated 
storage from information in a &ldquo;load module&rdquo; created by a 
linker. Some implementations may require run-time code to be executed 
in some cases, but we consider these cases rare enough that we need not 
further complicate the rules.</div>
<div class="paranum">1.b</div>
<div class="Annotations">It is important that programs be able to declare 
data structures that are link-time initialized with <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s, 
<SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN>s, 
and concatenations thereof. It is important to be able to write link-time 
evaluated expressions involving the First, Last, and Length attributes 
of such data structures (including variables), because they might be 
initialized with positional <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s 
or <SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN>s, 
and we don't want the user to have to count the elements. There is no 
corresponding need for accessing discriminants, since they can be initialized 
with a static constant, and then the constant can be referred to elsewhere. 
It is important to allow link-time initialized data structures involving 
discriminant-dependent components. It is important to be able to write 
link-time evaluated expressions involving pointers (both access values 
and addresses) to the above-mentioned data structures.</div>
<div class="paranum">1.c</div>
<div class="Annotations">The rules also ensure that no Elaboration_Check 
need be performed for calls on library-level subprograms declared within 
a preelaborated package. This is true also of the Elaboration_Check on 
task activation for library level task types declared in a preelaborated 
package. However, it is not true of the Elaboration_Check on instantiations.</div>
<div class="paranum">1.d</div>
<div class="Annotations">A static expression should never prevent a library 
unit from being preelaborable.</div>

<H4 Class="centered">Syntax</H4>
<div class="paranum">2</div>
<div class="Indented1" style="margin-bottom: 0.4em">The form of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborate is as follows:&nbsp;</div>
<div class="paranum">3</div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4332"></A><A NAME="I4333"></A>Preelaborate[(<I>library_unit_</I><A NAME="I4334"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>)];</div>
<div class="paranum">4</div>
<div class="Indented1"><SPAN STYLE="font-size: 80%">{<I>library unit 
pragma (Preelaborate)</I> [partial]}</SPAN> <A NAME="I4335"></A><SPAN STYLE="font-size: 80%">{<I>pragma, 
library unit (Preelaborate)</I> [partial]}</SPAN> <A NAME="I4336"></A>A 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Preelaborate 
is a library unit pragma.&nbsp;</div>
<div class="paranum">4.1/2</div>
<div class="Indented1" style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
The form of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization is as follows:&nbsp;</div>
<div class="paranum">4.2/2</div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4337"></A><A NAME="I4338"></A>Preelaborable_Initialization(<A NAME="I4339"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN>); 
</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum">5</div>
<div class="Normal" style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>preelaborable 
(of an elaborable construct)</I> [distributed]}</SPAN> <A NAME="I4340"></A>An 
elaborable construct is preelaborable unless its elaboration performs 
any of the following actions:&nbsp;</div>
<div class="paranum">5.a</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>A <I>preelaborable</I> 
construct can be elaborated without using any information that is available 
only at run time. Note that we don't try to prevent exceptions in preelaborable 
constructs; if the implementation wishes to generate code to raise an 
exception, that's OK.</div>
<div class="paranum">5.b</div>
<div class="Annotations">Because there is no flow of control and there 
are no calls (other than to predefined subprograms), these run-time properties 
can actually be detected at compile time. This is necessary in order 
to require compile-time enforcement of the rules.&nbsp;</div>
<div class="paranum">6</div>
<div class="Bulleted">The execution of a <SPAN Class="swiss"><A HREF="AA-5-1.html#S0131">statement</A></SPAN> 
other than a <SPAN Class="swiss"><A HREF="AA-5-1.html#S0134">null_statement</A></SPAN>. 
</div>
<div class="paranum">6.a</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>A preelaborable construct 
can contain <SPAN Class="swiss"><A HREF="AA-5-1.html#S0135">label</A></SPAN>s 
and <SPAN Class="swiss"><A HREF="AA-5-1.html#S0134">null_statement</A></SPAN>s. 
</div>
<div class="paranum">7</div>
<div class="Bulleted">A call to a subprogram other than a static function.</div>
<div class="paranum">8</div>
<div class="Bulleted">The evaluation of a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0120">primary</A></SPAN> 
that is a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of an object, unless the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is a static expression, or statically denotes a discriminant of an enclosing 
type.&nbsp;</div>
<div class="paranum">8.a</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>One can evaluate such a 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>, but 
not as a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0120">primary</A></SPAN>. 
For example, one can evaluate an attribute of the object. One can evaluate 
an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>, 
so long as it does not denote an object, and its <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
does not disobey any of these rules. For example, Obj'Access, Obj'Unchecked_Access, 
and Obj'Address are generally legal in preelaborated library units.&nbsp;</div>
<div class="paranum">9/2</div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
The creation of an object [(including a component)] of a type that does 
not have preelaborable initialization. Similarly, the evaluation of an 
<SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0109">extension_aggregate</A></SPAN> 
with an ancestor <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
denoting a subtype of such a type.</div>
<div class="paranum">9.a</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>One can declare these kinds 
of types, but one cannot create objects of those types.</div>
<div class="paranum">9.b</div>
<div class="Annotations">It is also non-preelaborable to create an object 
if that will cause the evaluation of a default expression that will call 
a user-defined function. This follows from the rule above forbidding 
non-null statements.&nbsp;</div>
<div class="paranum">9.c/2</div>
<div class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
</div>
<div class="paranum">10/2</div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
A generic body is preelaborable only if elaboration of a corresponding 
instance body would not perform any such actions, presuming that: <SPAN STYLE="font-size: 80%">{<I>generic 
contract issue</I>}</SPAN> <A NAME="I4341"></A></div>
<div class="paranum">10.1/2</div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
the actual for each formal private type (or extension) declared within 
the formal part of the generic unit is a private type (or extension) 
that does not have preelaborable initialization;</div>
<div class="paranum">10.2/2</div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
the actual for each formal type is nonstatic;</div>
<div class="paranum">10.3/2</div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
the actual for each formal object is nonstatic; and</div>
<div class="paranum">10.4/2</div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
the actual for each formal subprogram is a user-defined subprogram.&nbsp;</div>
<div class="paranum">10.a.1/2</div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
This is an &ldquo;assume-the-worst&rdquo; rule. The elaboration of a 
generic unit doesn't perform any of the actions listed above, because 
its sole effect is to establish that the generic can from now on be instantiated. 
So the elaboration of the generic itself is not the interesting part 
when it comes to preelaboration rules. The interesting part is what happens 
when you elaborate &ldquo;any instantiation&rdquo; of the generic. For 
instance, declaring an object of a limited formal private type might 
well start tasks, call functions, and do all sorts of non-preelaborable 
things. We prevent these situations by assuming that the actual parameters 
are as badly behaved as possible.&nbsp;</div>
<div class="paranum">10.a</div>
<div class="Annotations"><B>Reason:&nbsp;</B>Without this rule about generics, 
we would have to forbid instantiations in preelaborated library units, 
which would significantly reduce their usefulness.&nbsp;</div>
<div class="paranum">11/1</div>
<div class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>preelaborated</I> [partial]}</SPAN> 
<A NAME="I4342"></A>If a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborate (or <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure &mdash; see below) applies to a library unit, then it is <I>preelaborated</I>. 
[ <SPAN STYLE="font-size: 80%">{<I>preelaborated</I> [distributed]}</SPAN> 
<A NAME="I4343"></A>If a library unit is preelaborated, then its declaration, 
if any, and body, if any, are elaborated prior to all non-preelaborated 
<SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN>s 
of the partition.] The declaration and body of a preelaborated library 
unit, and all subunits that are elaborated as part of elaborating the 
library unit, shall be preelaborable. <SPAN STYLE="font-size: 80%">{<I>generic 
contract issue</I> [partial]}</SPAN> <A NAME="I4344"></A>In addition 
to the places where Legality Rules normally apply (see <A HREF="AA-12-3.html">12.3</A>), 
this rule applies also in the private part of an instance of a generic 
unit. In addition, all compilation units of a preelaborated library unit 
shall depend semantically only on compilation units of other preelaborated 
library units.&nbsp;</div>
<div class="paranum">11.a</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>In a generic body, we assume 
the worst about formal private types and extensions.</div>
<div class="paranum">11.a.1/1</div>
<div class="Annotations">{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
Subunits of a preelaborated subprogram unit do not need to be preelaborable. 
This is needed in order to be consistent with units nested in a subprogram 
body, which do not need to be preelaborable even if the subprogram is 
preelaborated. However, such subunits cannot depend semantically on non-preelaborated 
units, which is also consistent with nested units.&nbsp;</div>
<div class="paranum">11.1/2</div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>preelaborable initialization</I>}</SPAN> 
<A NAME="I4345"></A>The following rules specify which entities have <I>preelaborable 
initialization</I>:</div>
<div class="paranum">11.2/2</div>
<div class="Bulleted">The partial view of a private type or private extension, 
a protected type without <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0200">entry_declaration</A></SPAN>s, 
a generic formal private type, or a generic formal derived type, have 
preelaborable initialization if and only if the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization has been applied to them. [A protected type 
with <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0200">entry_declaration</A></SPAN>s 
or a task type never has preelaborable initialization.]</div>
<div class="paranum">11.3/2</div>
<div class="Bulleted">A component (including a discriminant) of a record 
or protected type has preelaborable initialization if its declaration 
includes a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
whose execution does not perform any actions prohibited in preelaborable 
constructs as described above, or if its declaration does not include 
a default expression and its type has preelaborable initialization.</div>
<div class="paranum">11.4/2</div>
<div class="Bulleted">A derived type has preelaborable initialization 
if its parent type has preelaborable initialization and (in the case 
of a derived record extension) if the non-inherited components all have 
preelaborable initialization. However, a user-defined controlled type 
with an overriding Initialize procedure does not have preelaborable initialization.</div>
<div class="paranum">11.5/2</div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
A view of a type has preelaborable initialization if it is an elementary 
type, an array type whose component type has preelaborable initialization, 
a record type whose components all have preelaborable initialization, 
or an interface type.&nbsp;</div>
<div class="paranum">11.6/2</div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Preelaborable_Initialization 
specifies that a type has preelaborable initialization. This pragma shall 
appear in the visible part of a package or generic package.</div>
<div class="paranum">11.7/2</div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
If the pragma appears in the first list of <SPAN Class="swiss"><A HREF="AA-3-11.html#S0088">basic_declarative_item</A></SPAN>s 
of a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN>, 
then the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
shall denote the first subtype of a private type, private extension, 
or protected type that is not an interface type and is without <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0200">entry_declaration</A></SPAN>s, 
and the type shall be declared immediately within the same package as 
the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>. 
If the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
is applied to a private type or a private extension, the full view of 
the type shall have preelaborable initialization. If the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
is applied to a protected type, each component of the protected type 
shall have preelaborable initialization. In addition to the places where 
Legality Rules normally apply, these rules apply also in the private 
part of an instance of a generic unit.</div>
<div class="paranum">11.8/2</div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
If the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
appears in a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN>, 
then the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
shall denote a generic formal private type or a generic formal derived 
type declared in the same <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN> 
as the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>. 
In a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN> 
the corresponding actual type shall have preelaborable initialization.</div>
<div class="paranum">11.b/2</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Not only do protected types 
with <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0200">entry_declaration</A></SPAN>s 
and task types not have preelaborable initialization, but they cannot 
have pragma Preelaborable_Initialization applied to them.&nbsp;</div>

<H4 Class="centered">Implementation Advice</H4>
<div class="paranum">12</div>
<div class="Normal">In an implementation, a type declared in a preelaborated 
package should have the same representation in every elaboration of a 
given version of the package, whether the elaborations occur in distinct 
executions of the same program, or in executions of distinct programs 
or partitions that include the given version.&nbsp;</div>
<div class="paranum">12.a/2</div>
<div class="Annotations"><B>Implementation Advice:&nbsp;</B>A type declared 
in a preelaborated package should have the same representation in every 
elaboration of a given version of the package.</div>

<H4 Class="centered">Syntax</H4>
<div class="paranum">13</div>
<div class="Indented1" style="margin-bottom: 0.4em">The form of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure is as follows:&nbsp;</div>
<div class="paranum">14</div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4346"></A><A NAME="I4347"></A>Pure[(<I>library_unit_</I><A NAME="I4348"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>)];</div>
<div class="paranum">15</div>
<div class="Indented1"><SPAN STYLE="font-size: 80%">{<I>library unit 
pragma (Pure)</I> [partial]}</SPAN> <A NAME="I4349"></A><SPAN STYLE="font-size: 80%">{<I>pragma, 
library unit (Pure)</I> [partial]}</SPAN> <A NAME="I4350"></A>A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure is a library unit pragma.&nbsp;</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum">15.1/2</div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>pure</I>}</SPAN> <A NAME="I4351"></A>A 
<I>pure</I> <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
is a preelaborable <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
whose elaboration does not perform any of the following actions:</div>
<div class="paranum">15.2/2</div>
<div class="Bulleted">the elaboration of a variable declaration;</div>
<div class="paranum">15.3/2</div>
<div class="Bulleted">the evaluation of an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
of an access-to-variable type; for the purposes of this rule, the partial 
view of a type is presumed to have non-visible components whose default 
initialization evaluates such an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>;</div>
<div class="paranum">15.a/2</div>
<div class="Annotations"><B>Reason:&nbsp;</B>This rule is needed because aggregates 
can specify the default initialization of a private type or extension 
using &lt;&gt; or the ancestor subtype of an extension aggregate. The 
subtype of a component could use an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
to initialize an access discriminant. Ada 95 did not allow such private 
types to have preelaborable initialization, so they could not have occurred. 
Thus this rule is not incompatible with Ada 95.&nbsp;</div>
<div class="paranum">15.4/2</div>
<div class="Bulleted">the elaboration of the declaration of a named access-to-variable 
type unless the Storage_Size of the type has been specified by a static 
expression with value zero or is defined by the language to be zero;</div>
<div class="paranum">15.b/2</div>
<div class="Annotations"><B>Discussion:&nbsp;</B>A remote access-to-class-wide 
type (see <A HREF="AA-E-2-2.html">E.2.2</A>) has its Storage_Size defined 
to be zero.&nbsp;</div>
<div class="paranum">15.c/2</div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
We disallow most named access-to-object types because an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
has a side effect; the pool constitutes variable data. We allow access-to-subprogram 
types because they don't have <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s. 
We even allow named access-to-object types if they have an empty predefined 
pool (they can't have a user-defined pool as System.Storage_Pools is 
not pure). In this case, most attempts to use an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
are illegal, and any others (in a generic body) will raise Storage_Error. 
</div>
<div class="paranum">15.5/2</div>
<div class="Bulleted">the elaboration of the declaration of a named access-to-constant 
type for which the Storage_Size has been specified by an expression other 
than a static expression with value zero.</div>
<div class="paranum">15.d/2</div>
<div class="Annotations"><B>Discussion:&nbsp;</B>We allow access-to-constant 
types so long as there is no user-specified non-zero Storage_Size; if 
there were a user-specified non-zero Storage_Size restricting the size 
of the storage pool, allocators would be problematic since the package 
is supposedly &lsquo;stateless&rsquo;, and the allocated size count for 
the storage pool would represent state.&nbsp;</div>
<div class="paranum">15.6/2</div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
The Storage_Size for an anonymous access-to-variable type declared at 
library level in a library unit that is declared pure is defined to be 
zero.</div>
<div class="paranum">15.e/2</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This makes <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s 
illegal for such types (see <A HREF="AA-4-8.html">4.8</A>), making a 
storage pool unnecessary for these types. A storage pool would represent 
state.</div>
<div class="paranum">15.f/2</div>
<div class="Annotations">Note that access discriminants and access parameters 
are never library-level, even when they are declared in a type or subprogram 
declared at library-level. That's because they have their own special 
accessibility rules (see <A HREF="AA-3-10-2.html">3.10.2</A>).&nbsp;</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum">16/2</div>
<div class="Normal">&nbsp;<SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
</div>
<div class="paranum">17/2</div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>declared pure</I>}</SPAN> <A NAME="I4352"></A>A 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Pure 
is used to declare that a library unit is pure. If a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure applies to a library unit, then its compilation units shall be pure, 
and they shall depend semantically only on compilation units of other 
library units that are declared pure. Furthermore, the full view of any 
partial view declared in the visible part of the library unit that has 
any available stream attributes shall support external streaming (see 
<A HREF="AA-13-13-2.html">13.13.2</A>).&nbsp;</div>
<div class="paranum">17.a</div>
<div class="Annotations"><B>To be honest:&nbsp;</B>A <I>declared-pure</I> 
library unit is one to which a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure applies. Its declaration and body are also said to be declared pure. 
</div>
<div class="paranum">17.b</div>
<div class="Annotations"><B>Discussion:&nbsp;</B>A declared-pure package is 
useful for defining types to be shared between partitions with no common 
address space.&nbsp;</div>
<div class="paranum">17.c</div>
<div class="Annotations"><B>Reason:&nbsp;</B>Note that generic packages are 
not mentioned in the list of things that can contain variable declarations. 
Note that the Ada 95 rules for deferred constants make them allowable 
in library units that are declared pure; that isn't true of Ada 83's 
deferred constants.&nbsp;</div>
<div class="paranum">17.d/2</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
Anonymous access types are allowed.&nbsp;</div>
<div class="paranum">17.e/2</div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
Ada 95 didn't allow any access types as these (including access-to-subprogram 
types) cause trouble for <A HREF="AA-E.html">Annex E</A>, &ldquo;<A HREF="AA-E.html">Distributed 
Systems</A>&rdquo;, because such types  allow access values in a shared 
passive partition to designate objects in an active partition, thus allowing 
inter-address space references. We decided to disallow such uses in the 
relatively rare cases where they cause problems, rather than making life 
harder for the majority of users. Types declared in a pure package can 
be used in remote operations only if they are externally streamable. 
That simply means that there is a means to transport values of the type; 
that's automatically true for nonlimited types that don't have an access 
part. The only tricky part about this is to avoid privacy leakage; that 
was handled by ensuring that any private types (and private extensions) 
declared in a pure package that have available stream attributes (which 
include all nonlimited types by definition) have to be externally streamable. 
</div>

<H4 Class="centered">Implementation Permissions</H4>
<div class="paranum">18/2</div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
If a library unit is declared pure, then the implementation is permitted 
to omit a call on a library-level subprogram of the library unit if the 
results are not needed after the call. In addition, the implementation 
may omit a call on such a subprogram and simply reuse the results produced 
by an earlier call on the same subprogram, provided that none of the 
parameters nor any object accessible via access values from the parameters 
are of a limited type, and the addresses and values of all by-reference 
actual parameters, the values of all by-copy-in actual parameters, and 
the values of all objects accessible via access values from the parameters, 
are the same as they were at the earlier call. [This permission applies 
even if the subprogram produces other side effects when called.]&nbsp;</div>
<div class="paranum">18.a/2</div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
A declared-pure <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
has no variable state. Hence, a call on one of its (nonnested) subprograms 
cannot normally have side effects. The only possible side effects from 
such a call would be through machine code insertions, imported subprograms,unchecked 
conversion to an access type declared within the subprogram, and similar 
features. The compiler may omit a call to such a subprogram even if such 
side effects exist, so the writer of such a subprogram has to keep this 
in mind.&nbsp;</div>

<H4 Class="centered">Syntax</H4>
<div class="paranum">19</div>
<div class="Indented1" style="margin-bottom: 0.4em">The form of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate, Elaborate_All, or Elaborate_Body is as follows:&nbsp;</div>
<div class="paranum">20</div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4353"></A><A NAME="I4354"></A>Elaborate(<I>library_unit_</I><A NAME="I4355"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>{, 
<I>library_unit_</I><A NAME="I4356"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>});</div>
<div class="paranum">21</div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4357"></A><A NAME="I4358"></A>Elaborate_All(<I>library_unit_</I><A NAME="I4359"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>{, 
<I>library_unit_</I><A NAME="I4360"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>});</div>
<div class="paranum">22</div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4361"></A><A NAME="I4362"></A>Elaborate_Body[(<I>library_unit_</I><A NAME="I4363"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>)];</div>
<div class="paranum">23</div>
<div class="Indented1">A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All is only allowed within a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN>. 
</div>
<div class="paranum">23.a</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>&ldquo;Within a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN>&rdquo; 
allows it to be the last item in the <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN>. 
It can't be first, because the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
has to denote something mentioned earlier.&nbsp;</div>
<div class="paranum">24</div>
<div class="Indented1"><SPAN STYLE="font-size: 80%">{<I>library unit 
pragma (Elaborate_Body)</I> [partial]}</SPAN> <A NAME="I4364"></A><SPAN STYLE="font-size: 80%">{<I>pragma, 
library unit (Elaborate_Body)</I> [partial]}</SPAN> <A NAME="I4365"></A>A 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_Body 
is a library unit pragma.&nbsp;</div>
<div class="paranum">24.a</div>
<div class="Annotations"><B>Discussion:&nbsp;</B>Hence, a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All is not elaborated, not that it makes any practical 
difference.</div>
<div class="paranum">24.b</div>
<div class="Annotations">Note that a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All is neither a program unit pragma, nor a library 
unit pragma.</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum">25</div>
<div class="Normal"><SPAN STYLE="font-size: 80%">{<I>requires a completion 
(declaration to which a pragma Elaborate_Body applies)</I> [partial]}</SPAN> 
<A NAME="I4366"></A>If a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate_Body applies to a declaration, then the declaration requires 
a completion [(a body)].</div>
<div class="paranum">25.1/2</div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-50217.TXT">AI95-00217-06</A></I>} 
The <I>library_unit_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All shall denote a nonlimited view of a library 
unit.&nbsp;</div>
<div class="paranum">25.a/2</div>
<div class="Annotations"><B>Reason:&nbsp;</B>These <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
are intended to prevent elaboration check failures. But a limited view 
does not make anything visible that has an elaboration check, so the 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s cannot 
do anything useful. Moreover, the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
would probably reintroduce the circularity that the <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0238">limited_with_clause</A></SPAN> 
was intended to break. So we make such uses illegal.&nbsp;</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum">26</div>
<div class="Normal">[A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate specifies that the body of the named library unit is elaborated 
before the current <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN>. 
A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_All 
specifies that each <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
that is needed by the named library unit declaration is elaborated before 
the current <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN>. 
A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_Body 
specifies that the body of the library unit is elaborated immediately 
after its declaration.]&nbsp;</div>
<div class="paranum">26.a</div>
<div class="Annotations"><B>Proof:&nbsp;</B>The official statement of the 
semantics of these <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
is given in <A HREF="AA-10-2.html">10.2</A>.&nbsp;</div>
<div class="paranum">26.b</div>
<div class="Annotations"><B>Implementation Note:&nbsp;</B>The presence of 
a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_Body 
simplifies the removal of unnecessary Elaboration_Checks. For a subprogram 
declared immediately within a library unit to which a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate_Body applies, the only calls that can fail the Elaboration_Check 
are those that occur in the library unit itself, between the declaration 
and body of the called subprogram; if there are no such calls (which 
can easily be detected at compile time if there are no <SPAN Class="swiss">stub</SPAN>s), 
then no Elaboration_Checks are needed for that subprogram. The same is 
true for Elaboration_Checks on task activations and instantiations, and 
for library subprograms and generic units.&nbsp;</div>
<div class="paranum">26.c</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>The fact that the unit 
of elaboration is the <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
means that if a <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN> 
is not a completion, it is impossible for any <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
to be elaborated between the declaration and the body of such a subprogram. 
Therefore, it is impossible for a call to such a subprogram to fail its 
Elaboration_Check.&nbsp;</div>
<div class="paranum">26.d</div>
<div class="Annotations"><B>Discussion:&nbsp;</B>The visibility rules imply 
that each <I>library_unit_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All has to denote a library unit mentioned by 
a previous <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">with_clause</A></SPAN> 
of the same <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN>. 
</div>
<div class="NotesHeader">NOTES</div>
<div class="paranum">27</div>
<div class="Notes">12&nbsp;&nbsp;A preelaborated library unit is allowed 
to have non-preelaborable children.&nbsp;</div>
<div class="paranum">27.a/1</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
But generally not non-preelaborated subunits. (Non-preelaborated subunits 
of subprograms are allowed as discussed above.)&nbsp;</div>
<div class="paranum">28</div>
<div class="Notes">13&nbsp;&nbsp;A library unit that is declared pure 
is allowed to have impure children.&nbsp;</div>
<div class="paranum">28.a/1</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
But generally not impure subunits. (Impure subunits of subprograms are 
allowed as discussed above.)&nbsp;</div>
<div class="paranum">28.b</div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Pragma Elaborate is mainly 
for closely related library units, such as when two package bodies 'with' 
each other's declarations. In such cases, Elaborate_All sometimes won't 
work.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 83</H4>
<div class="paranum">28.c</div>
<div class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I4367"></A>The 
concepts of preelaborability and purity are new to Ada 95. The Elaborate_All, 
Elaborate_Body, Preelaborate, and Pure <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
are new to Ada 95.</div>
<div class="paranum">28.d</div>
<div class="Annotations">Pragmas Elaborate are allowed to be mixed in 
with the other things in the <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN> 
&mdash; in Ada 83, they were required to appear last.&nbsp;</div>

<H4 Class="centered">Incompatibilities With Ada 95</H4>
<div class="paranum">28.e/2</div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
{<I>incompatibilities with Ada 95</I>} <A NAME="I4368"></A>The requirement 
that a partial view with available stream attributes be externally streamable 
can cause an incompatibility in rare cases. If there is a limited tagged 
type declared in a pure package with available attributes, and that type 
is used to declare a private extension in another pure package, and the 
full type for the private extension has a component of an explicitly 
limited record type, a protected type, or a type with access discriminants, 
then the stream attributes will have to be user-specified in the visible 
part of the package. That is not a requirement for Ada 95, but this combination 
seems very unlikely in pure packages. Note that this cannot be an incompatibility 
for a nonlimited type, as all of the types that are allowed in Ada 95 
that would require explicitly defined stream attributes are limited (and 
thus cannot be used as components in a nonlimited type).</div>
<div class="paranum">28.f/2</div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
<B>Amendment Correction:</B> Added wording to cover missing cases for 
preelaborated generic units. This is incompatible as a preelaborated 
unit could have used a formal object to initialize a library-level object; 
that isn't allowed in Ada 2005. But such a unit wouldn't really be preelaborable, 
and Ada 95 compilers can reject such units (as this is a Binding Interpretation), 
so such units should be very rare.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 95</H4>
<div class="paranum">28.g/2</div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
{<I>extensions to Ada 95</I>} <A NAME="I4369"></A><B>Amendment Correction:</B> 
The concept of preelaborable initialization and <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization are new. These allow more types of objects 
to be created in preelaborable units, and fix holes in the old rules.</div>
<div class="paranum">28.h/2</div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
Access-to-subprogram types and access-to-object types with a Storage_Size 
of 0 are allowed in pure units. The permission to omit calls was adjusted 
accordingly (which also fixes a hole in Ada 95, as access parameters 
are allowed, and changes in the values accessed by them must be taken 
into account).&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<div class="paranum">28.i/2</div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
<B>Corrigendum:</B> The wording was changed so that subunits of a preelaborated 
subprogram are also preelaborated.</div>
<div class="paranum">28.j/2</div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-50217.TXT">AI95-00217-06</A></I>} 
Disallowed pragma Elaborate and Elaborate_All for packages that are mentioned 
in a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0238">limited_with_clause</A></SPAN>. 
</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-10-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-11.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
