

                                   Annex C
                                 (normative)

                             Systems Programming


1   The Systems Programming Annex specifies additional capabilities provided
for low-level programming. These capabilities are also required in many
real-time, embedded, distributed, and information systems.


C.1 Access to Machine Operations


1   This clause specifies rules regarding access to machine instructions from
within an Ada program.


                         Implementation Requirements

2   The implementation shall support machine code insertions (see 13.8) or
intrinsic subprograms (see 6.3.1) (or both). Implementation-defined attributes
shall be provided to allow the use of Ada entities as operands.


                            Implementation Advice

3   The machine code or intrinsics support should allow access to all
operations normally available to assembly language programmers for the target
environment, including privileged instructions, if any.

4   The interfacing pragmas (see Annex B) should support interface to
assembler; the default assembler should be associated with the convention
identifier Assembler.

5   If an entity is exported to assembly language, then the implementation
should allocate it at an addressable location, and should ensure that it is
retained by the linking process, even if not otherwise referenced from the Ada
code. The implementation should assume that any call to a machine code or
assembler subprogram is allowed to read or update every object that is
specified as exported.


                         Documentation Requirements

6   The implementation shall document the overhead associated with calling
machine-code or intrinsic subprograms, as compared to a fully-inlined call,
and to a regular out-of-line call.

7   The implementation shall document the types of the package
System.Machine_Code usable for machine code insertions, and the attributes to
be used in machine code insertions for references to Ada entities.

8   The implementation shall document the subprogram calling conventions
associated with the convention identifiers available for use with the
interfacing pragmas (Ada and Assembler, at a minimum), including register
saving, exception propagation, parameter passing, and function value
returning.

9   For exported and imported subprograms, the implementation shall document
the mapping between the Link_Name string, if specified, or the Ada designator,
if not, and the external link name used for such a subprogram.


                            Implementation Advice

10  The implementation should ensure that little or no overhead is associated
with calling intrinsic and machine-code subprograms.

11  It is recommended that intrinsic subprograms be provided for convenient
access to any machine operations that provide special capabilities or
efficiency and that are not otherwise available through the language
constructs. Examples of such instructions include:

12    * Atomic read-modify-write operations - e.g., test and set, compare and
        swap, decrement and test, enqueue/dequeue.

13    * Standard numeric functions - e.g., sin, log.

14    * String manipulation operations - e.g., translate and test.

15    * Vector operations - e.g., compare vector against thresholds.

16    * Direct operations on I/O ports.


C.2 Required Representation Support


1/2 This clause specifies minimal requirements on the support for
representation items and related features.


                         Implementation Requirements

2   The implementation shall support at least the functionality defined by the
recommended levels of support in Section 13.


C.3 Interrupt Support


1   This clause specifies the language-defined model for hardware interrupts
in addition to mechanisms for handling interrupts.


                              Dynamic Semantics

2   An interrupt represents a class of events that are detected by the
hardware or the system software. Interrupts are said to occur. An occurrence
of an interrupt is separable into generation and delivery. Generation of an
interrupt is the event in the underlying hardware or system that makes the
interrupt available to the program. Delivery is the action that invokes part
of the program as response to the interrupt occurrence. Between generation and
delivery, the interrupt occurrence (or interrupt) is pending. Some or all
interrupts may be blocked. When an interrupt is blocked, all occurrences of
that interrupt are prevented from being delivered. Certain interrupts are
reserved. The set of reserved interrupts is implementation defined. A reserved
interrupt is either an interrupt for which user-defined handlers are not
supported, or one which already has an attached handler by some other
implementation-defined means. Program units can be connected to non-reserved
interrupts. While connected, the program unit is said to be attached to that
interrupt. The execution of that program unit, the interrupt handler, is
invoked upon delivery of the interrupt occurrence.

3   While a handler is attached to an interrupt, it is called once for each
delivered occurrence of that interrupt. While the handler executes, the
corresponding interrupt is blocked.

4   While an interrupt is blocked, all occurrences of that interrupt are
prevented from being delivered. Whether such occurrences remain pending or are
lost is implementation defined.

5   Each interrupt has a default treatment which determines the system's
response to an occurrence of that interrupt when no user-defined handler is
attached. The set of possible default treatments is implementation defined, as
is the method (if one exists) for configuring the default treatments for
interrupts.

6   An interrupt is delivered to the handler (or default treatment) that is in
effect for that interrupt at the time of delivery.

7   An exception propagated from a handler that is invoked by an interrupt has
no effect.

8   If the Ceiling_Locking policy (see D.3) is in effect, the interrupt
handler executes with the active priority that is the ceiling priority of the
corresponding protected object.


                         Implementation Requirements

9   The implementation shall provide a mechanism to determine the minimum
stack space that is needed for each interrupt handler and to reserve that
space for the execution of the handler. This space should accommodate nested
invocations of the handler where the system permits this.

10  If the hardware or the underlying system holds pending interrupt
occurrences, the implementation shall provide for later delivery of these
occurrences to the program.

11  If the Ceiling_Locking policy is not in effect, the implementation shall
provide means for the application to specify whether interrupts are to be
blocked during protected actions.


                         Documentation Requirements

12  The implementation shall document the following items:

13  1.  For each interrupt, which interrupts are blocked from delivery when a
        handler attached to that interrupt executes (either as a result of an
        interrupt delivery or of an ordinary call on a procedure of the
        corresponding protected object).

14  2.  Any interrupts that cannot be blocked, and the effect of attaching
        handlers to such interrupts, if this is permitted.

15  3.  Which run-time stack an interrupt handler uses when it executes as a
        result of an interrupt delivery; if this is configurable, what is the
        mechanism to do so; how to specify how much space to reserve on that
        stack.

16  4.  Any implementation- or hardware-specific activity that happens before
        a user-defined interrupt handler gets control (e.g., reading device
        registers, acknowledging devices).

17  5.  Any timing or other limitations imposed on the execution of interrupt
        handlers.

18  6.  The state (blocked/unblocked) of the non-reserved interrupts when the
        program starts; if some interrupts are unblocked, what is the
        mechanism a program can use to protect itself before it can attach the
        corresponding handlers.

19  7.  Whether the interrupted task is allowed to resume execution before the
        interrupt handler returns.

20  8.  The treatment of interrupt occurrences that are generated while the
        interrupt is blocked; i.e., whether one or more occurrences are held
        for later delivery, or all are lost.

21  9.  Whether predefined or implementation-defined exceptions are raised as
        a result of the occurrence of any interrupt, and the mapping between
        the machine interrupts (or traps) and the predefined exceptions.

22  10. On a multi-processor, the rules governing the delivery of an interrupt
        to a particular processor.


                         Implementation Permissions

23/2 If the underlying system or hardware does not allow interrupts to be
blocked, then no blocking is required as part of the execution of subprograms
of a protected object for which one of its subprograms is an interrupt handler.

24  In a multi-processor with more than one interrupt subsystem, it is
implementation defined whether (and how) interrupt sources from separate
subsystems share the same Interrupt_ID type (see C.3.2). In particular, the
meaning of a blocked or pending interrupt may then be applicable to one
processor only.

25  Implementations are allowed to impose timing or other limitations on the
execution of interrupt handlers.

26/2 Other forms of handlers are allowed to be supported, in which case the
rules of this clause should be adhered to.

27  The active priority of the execution of an interrupt handler is allowed to
vary from one occurrence of the same interrupt to another.


                            Implementation Advice

28/2 If the Ceiling_Locking policy is not in effect, the implementation should
provide means for the application to specify which interrupts are to be
blocked during protected actions, if the underlying system allows for
finer-grained control of interrupt blocking.

        NOTES

29      1  The default treatment for an interrupt can be to keep the interrupt
        pending or to deliver it to an implementation-defined handler.
        Examples of actions that an implementation-defined handler is allowed
        to perform include aborting the partition, ignoring (i.e., discarding
        occurrences of) the interrupt, or queuing one or more occurrences of
        the interrupt for possible later delivery when a user-defined handler
        is attached to that interrupt.

30      2  It is a bounded error to call Task_Identification.Current_Task (see
        C.7.1) from an interrupt handler.

31      3  The rule that an exception propagated from an interrupt handler has
        no effect is modeled after the rule about exceptions propagated out of
        task bodies.


C.3.1 Protected Procedure Handlers



                                   Syntax

1       The form of a pragma Interrupt_Handler is as follows:

2         pragma Interrupt_Handler(handler_name);

3       The form of a pragma Attach_Handler is as follows:

4         pragma Attach_Handler(handler_name, expression);


                            Name Resolution Rules

5   For the Interrupt_Handler and Attach_Handler pragmas, the handler_name
shall resolve to denote a protected procedure with a parameterless profile.

6   For the Attach_Handler pragma, the expected type for the expression is
Interrupts.Interrupt_ID (see C.3.2).


                               Legality Rules

7/2 The Attach_Handler pragma is only allowed immediately within the
protected_definition where the corresponding subprogram is declared. The
corresponding protected_type_declaration or single_protected_declaration shall
be a library-level declaration.

8/2 The Interrupt_Handler pragma is only allowed immediately within the
protected_definition where the corresponding subprogram is declared. The cor-
responding protected_type_declaration or single_protected_declaration shall be
a library-level declaration.


                              Dynamic Semantics

9   If the pragma Interrupt_Handler appears in a protected_definition, then
the corresponding procedure can be attached dynamically, as a handler, to
interrupts (see C.3.2). Such procedures are allowed to be attached to multiple
interrupts.

10  The expression in the Attach_Handler pragma as evaluated at object
creation time specifies an interrupt. As part of the initialization of that
object, if the Attach_Handler pragma is specified, the handler procedure is
attached to the specified interrupt. A check is made that the corresponding
interrupt is not reserved. Program_Error is raised if the check fails, and the
existing treatment for the interrupt is not affected.

11/2 If the Ceiling_Locking policy (see D.3) is in effect, then upon the
initialization of a protected object for which either an Attach_Handler or
Interrupt_Handler pragma applies to one of its procedures, a check is made
that the ceiling priority defined in the protected_definition is in the range
of System.Interrupt_Priority. If the check fails, Program_Error is raised.

12/1 When a protected object is finalized, for any of its procedures that are
attached to interrupts, the handler is detached. If the handler was attached
by a procedure in the Interrupts package or if no user handler was previously
attached to the interrupt, the default treatment is restored. If an Attach_-
Handler pragma was used and the most recently attached handler for the same
interrupt is the same as the one that was attached at the time the protected
object was initialized, the previous handler is restored.

13  When a handler is attached to an interrupt, the interrupt is blocked
(subject to the Implementation Permission in C.3) during the execution of
every protected action on the protected object containing the handler.


                             Erroneous Execution

14  If the Ceiling_Locking policy (see D.3) is in effect and an interrupt is
delivered to a handler, and the interrupt hardware priority is higher than the
ceiling priority of the corresponding protected object, the execution of the
program is erroneous.

14.1/1 If the handlers for a given interrupt attached via pragma
Attach_Handler are not attached and detached in a stack-like (LIFO) order,
program execution is erroneous. In particular, when a protected object is
finalized, the execution is erroneous if any of the procedures of the
protected object are attached to interrupts via pragma Attach_Handler and the
most recently attached handler for the same interrupt is not the same as the
one that was attached at the time the protected object was initialized.


                                   Metrics

15  The following metric shall be documented by the implementation:

16/2   * The worst-case overhead for an interrupt handler that is a
        parameterless protected procedure, in clock cycles. This is the
        execution time not directly attributable to the handler procedure or
        the interrupted execution. It is estimated as C - (A+B), where A is
        how long it takes to complete a given sequence of instructions without
        any interrupt, B is how long it takes to complete a normal call to a
        given protected procedure, and C is how long it takes to complete the
        same sequence of instructions when it is interrupted by one execution
        of the same procedure called via an interrupt.


                         Implementation Permissions

17  When the pragmas Attach_Handler or Interrupt_Handler apply to a protected
procedure, the implementation is allowed to impose implementation-defined
restrictions on the corresponding protected_type_declaration and protected_-
body.

18  An implementation may use a different mechanism for invoking a protected
procedure in response to a hardware interrupt than is used for a call to that
protected procedure from a task.

19  Notwithstanding what this subclause says elsewhere, the Attach_Handler and
Interrupt_Handler pragmas are allowed to be used for other, implementation
defined, forms of interrupt handlers.


                            Implementation Advice

20  Whenever possible, the implementation should allow interrupt handlers to
be called directly by the hardware.

21  Whenever practical, the implementation should detect violations of any
implementation-defined restrictions before run time.

        NOTES

22      4  The Attach_Handler pragma can provide static attachment of handlers
        to interrupts if the implementation supports preelaboration of
        protected objects. (See C.4.)

23/2    5  A protected object that has a (protected) procedure attached to an
        interrupt should have a ceiling priority at least as high as the
        highest processor priority at which that interrupt will ever be
        delivered.

24      6  Protected procedures can also be attached dynamically to interrupts
        via operations declared in the predefined package Interrupts.

25      7  An example of a possible implementation-defined restriction is
        disallowing the use of the standard storage pools within the body of a
        protected procedure that is an interrupt handler.


C.3.2 The Package Interrupts



                              Static Semantics

1   The following language-defined packages exist:

2       with System;
        package Ada.Interrupts is
           type Interrupt_ID is implementation-defined;
           type Parameterless_Handler is
              access protected procedure;

3/1     This paragraph was deleted.

4          function Is_Reserved (Interrupt : Interrupt_ID)
              return Boolean;

5          function Is_Attached (Interrupt : Interrupt_ID)
              return Boolean;

6          function Current_Handler (Interrupt : Interrupt_ID)
              return Parameterless_Handler;

7          procedure Attach_Handler
              (New_Handler : in Parameterless_Handler;
               Interrupt   : in Interrupt_ID);

8          procedure Exchange_Handler
              (Old_Handler : out Parameterless_Handler;
               New_Handler : in Parameterless_Handler;
               Interrupt   : in Interrupt_ID);

9          procedure Detach_Handler
              (Interrupt : in Interrupt_ID);

10         function Reference(Interrupt : Interrupt_ID)
              return System.Address;

11      private
           ... -- not specified by the language
        end Ada.Interrupts;

12      package Ada.Interrupts.Names is
           implementation-defined : constant Interrupt_ID :=
             implementation-defined;
              . . .
           implementation-defined : constant Interrupt_ID :=
             implementation-defined;
        end Ada.Interrupts.Names;


                              Dynamic Semantics

13  The Interrupt_ID type is an implementation-defined discrete type used to
identify interrupts.

14  The Is_Reserved function returns True if and only if the specified
interrupt is reserved.

15  The Is_Attached function returns True if and only if a user-specified
interrupt handler is attached to the interrupt.

16/1 The Current_Handler function returns a value that represents the attached
handler of the interrupt. If no user-defined handler is attached to the
interrupt, Current_Handler returns null.

17  The Attach_Handler procedure attaches the specified handler to the
interrupt, overriding any existing treatment (including a user handler) in
effect for that interrupt. If New_Handler is null, the default treatment is
restored. If New_Handler designates a protected procedure to which the pragma
Interrupt_Handler does not apply, Program_Error is raised. In this case, the
operation does not modify the existing interrupt treatment.

18/1 The Exchange_Handler procedure operates in the same manner as
Attach_Handler with the addition that the value returned in Old_Handler
designates the previous treatment for the specified interrupt. If the previous
treatment is not a user-defined handler, null is returned.

19  The Detach_Handler procedure restores the default treatment for the
specified interrupt.

20  For all operations defined in this package that take a parameter of type
Interrupt_ID, with the exception of Is_Reserved and Reference, a check is made
that the specified interrupt is not reserved. Program_Error is raised if this
check fails.

21  If, by using the Attach_Handler, Detach_Handler, or Exchange_Handler
procedures, an attempt is made to detach a handler that was attached
statically (using the pragma Attach_Handler), the handler is not detached and
Program_Error is raised.

22/2 The Reference function returns a value of type System.Address that can be
used to attach a task entry via an address clause (see J.7.1) to the interrupt
specified by Interrupt. This function raises Program_Error if attaching task
entries to interrupts (or to this particular interrupt) is not supported.


                         Implementation Requirements

23  At no time during attachment or exchange of handlers shall the current
handler of the corresponding interrupt be undefined.


                         Documentation Requirements

24/2 If the Ceiling_Locking policy (see D.3) is in effect, the implementation
shall document the default ceiling priority assigned to a protected object
that contains either the Attach_Handler or Interrupt_Handler pragmas, but not
the Interrupt_Priority pragma. This default need not be the same for all
interrupts.


                            Implementation Advice

25  If implementation-defined forms of interrupt handler procedures are
supported, such as protected procedures with parameters, then for each such
form of a handler, a type analogous to Parameterless_Handler should be
specified in a child package of Interrupts, with the same operations as in the
predefined package Interrupts.

        NOTES

26      8  The package Interrupts.Names contains implementation-defined names
        (and constant values) for the interrupts that are supported by the
        implementation.


                                  Examples

27  Example of interrupt handlers:

28      Device_Priority : constant
          array (1..5) of System.Interrupt_Priority := ( ... );
        protected type Device_Interface
          (Int_ID : Ada.Interrupts.Interrupt_ID) is
          procedure Handler;
          pragma Attach_Handler(Handler, Int_ID);
          ...
          pragma Interrupt_Priority(Device_Priority(Int_ID));
        end Device_Interface;
          ...
        Device_1_Driver : Device_Interface(1);
          ...
        Device_5_Driver : Device_Interface(5);
          ...


C.4 Preelaboration Requirements


1   This clause specifies additional implementation and documentation
requirements for the Preelaborate pragma (see 10.2.1).


                         Implementation Requirements

2   The implementation shall not incur any run-time overhead for the
elaboration checks of subprograms and protected_bodies declared in
preelaborated library units.

3   The implementation shall not execute any memory write operations after
load time for the elaboration of constant objects declared immediately within
the declarative region of a preelaborated library package, so long as the
subtype and initial expression (or default initial expressions if initialized
by default) of the object_declaration satisfy the following restrictions. The
meaning of load time is implementation defined.

4     * Any subtype_mark denotes a statically constrained subtype, with
        statically constrained subcomponents, if any;

4.1/2   * no subtype_mark denotes a controlled type, a private type, a private
        extension, a generic formal private type, a generic formal derived
        type, or a descendant of such a type;

5     * any constraint is a static constraint;

6     * any allocator is for an access-to-constant type;

7     * any uses of predefined operators appear only within static expressions;

8     * any primaries that are names, other than attribute_references for the
        Access or Address attributes, appear only within static expressions;

9     * any name that is not part of a static expression is an expanded name
        or direct_name that statically denotes some entity;

10    * any discrete_choice of an array_aggregate is static;

11    * no language-defined check associated with the elaboration of the
        object_declaration can fail.


                         Documentation Requirements

12  The implementation shall document any circumstances under which the
elaboration of a preelaborated package causes code to be executed at run time.

13  The implementation shall document whether the method used for
initialization of preelaborated variables allows a partition to be restarted
without reloading.


                            Implementation Advice

14  It is recommended that preelaborated packages be implemented in such a way
that there should be little or no code executed at run time for the
elaboration of entities not already covered by the
Implementation Requirements.


C.5 Pragma Discard_Names


1   A pragma Discard_Names may be used to request a reduction in storage used
for the names of certain entities.


                                   Syntax

2       The form of a pragma Discard_Names is as follows:

3         pragma Discard_Names[([On => ] local_name)];

4       A pragma Discard_Names is allowed only immediately within a
        declarative_part, immediately within a package_specification, or as a
        configuration pragma.


                               Legality Rules

5   The local_name (if present) shall denote a non-derived enumeration first
subtype, a tagged first subtype, or an exception. The pragma applies to the
type or exception. Without a local_name, the pragma applies to all such
entities declared after the pragma, within the same declarative region.
Alternatively, the pragma can be used as a configuration pragma. If the pragma
applies to a type, then it applies also to all descendants of the type.


                              Static Semantics

6   If a local_name is given, then a pragma Discard_Names is a representation
pragma.

7/2 If the pragma applies to an enumeration type, then the semantics of the
Wide_Wide_Image and Wide_Wide_Value attributes are implementation defined for
that type; the semantics of Image, Wide_Image, Value, and Wide_Value are still
defined in terms of Wide_Wide_Image and Wide_Wide_Value. In addition, the
semantics of Text_IO.Enumeration_IO are implementation defined. If the pragma
applies to a tagged type, then the semantics of the Tags.Wide_Wide_Expanded_-
Name function are implementation defined for that type; the semantics of Tags.-
Expanded_Name and Tags.Wide_Expanded_Name are still defined in terms of Tags.-
Wide_Wide_Expanded_Name. If the pragma applies to an exception, then the
semantics of the Exceptions.Wide_Wide_Exception_Name function are
implementation defined for that exception; the semantics of Exceptions.-
Exception_Name and Exceptions.Wide_Exception_Name are still defined in terms
of Exceptions.Wide_Wide_Exception_Name.


                            Implementation Advice

8   If the pragma applies to an entity, then the implementation should reduce
the amount of storage used for storing names associated with that entity.


C.6 Shared Variable Control


1   This clause specifies representation pragmas that control the use of
shared variables.


                                   Syntax

2       The form for pragmas Atomic, Volatile, Atomic_Components, and
        Volatile_Components is as follows:

3         pragma Atomic(local_name);

4         pragma Volatile(local_name);

5         pragma Atomic_Components(array_local_name);

6         pragma Volatile_Components(array_local_name);

7/2 An atomic type is one to which a pragma Atomic applies. An atomic object
(including a component) is one to which a pragma Atomic applies, or a
component of an array to which a pragma Atomic_Components applies, or any
object of an atomic type, other than objects obtained by evaluating a slice.

8   A volatile type is one to which a pragma Volatile applies. A volatile
object (including a component) is one to which a pragma Volatile applies, or a
component of an array to which a pragma Volatile_Components applies, or any
object of a volatile type. In addition, every atomic type or object is also
defined to be volatile. Finally, if an object is volatile, then so are all of
its subcomponents (the same does not apply to atomic).


                            Name Resolution Rules

9   The local_name in an Atomic or Volatile pragma shall resolve to denote
either an object_declaration, a non-inherited component_declaration, or a
full_type_declaration. The array_local_name in an Atomic_Components or
Volatile_Components pragma shall resolve to denote the declaration of an array
type or an array object of an anonymous type.


                               Legality Rules

10  It is illegal to apply either an Atomic or Atomic_Components pragma to an
object or type if the implementation cannot support the indivisible reads and
updates required by the pragma (see below).

11  It is illegal to specify the Size attribute of an atomic object, the
Component_Size attribute for an array type with atomic components, or the
layout attributes of an atomic component, in a way that prevents the
implementation from performing the required indivisible reads and updates.

12  If an atomic object is passed as a parameter, then the type of the formal
parameter shall either be atomic or allow pass by copy (that is, not be a
nonatomic by-reference type). If an atomic object is used as an actual for a
generic formal object of mode in out, then the type of the generic formal
object shall be atomic. If the prefix of an attribute_reference for an Access
attribute denotes an atomic object (including a component), then the
designated type of the resulting access type shall be atomic. If an atomic
type is used as an actual for a generic formal derived type, then the ancestor
of the formal type shall be atomic or allow pass by copy. Corresponding rules
apply to volatile objects and types.

13  If a pragma Volatile, Volatile_Components, Atomic, or Atomic_Components
applies to a stand-alone constant object, then a pragma Import shall also
apply to it.


                              Static Semantics

14  These pragmas are representation pragmas (see 13.1).


                              Dynamic Semantics

15  For an atomic object (including an atomic component) all reads and updates
of the object as a whole are indivisible.

16  For a volatile object all reads and updates of the object as a whole are
performed directly to memory.

17  Two actions are sequential (see 9.10) if each is the read or update of the
same atomic object.

18  If a type is atomic or volatile and it is not a by-copy type, then the
type is defined to be a by-reference type. If any subcomponent of a type is
atomic or volatile, then the type is defined to be a by-reference type.

19  If an actual parameter is atomic or volatile, and the corresponding formal
parameter is not, then the parameter is passed by copy.


                         Implementation Requirements

20  The external effect of a program (see 1.1.3) is defined to include each
read and update of a volatile or atomic object. The implementation shall not
generate any memory reads or updates of atomic or volatile objects other than
those specified by the program.

21  If a pragma Pack applies to a type any of whose subcomponents are atomic,
the implementation shall not pack the atomic subcomponents more tightly than
that for which it can support indivisible reads and updates.


                            Implementation Advice

22/2 A load or store of a volatile object whose size is a multiple of
System.Storage_Unit and whose alignment is nonzero, should be implemented by
accessing exactly the bits of the object and no others.

23/2 A load or store of an atomic object should, where possible, be
implemented by a single load or store instruction.

        NOTES

24      9  An imported volatile or atomic constant behaves as a constant (i.e.
        read-only) with respect to other parts of the Ada program, but can
        still be modified by an "external source."


C.7 Task Information


1/2 This clause describes operations and attributes that can be used to obtain
the identity of a task. In addition, a package that associates user-defined
information with a task is defined. Finally, a package that associates
termination procedures with a task or set of tasks is defined.


C.7.1 The Package Task_Identification



                              Static Semantics

1   The following language-defined library package exists:

2/2     package Ada.Task_Identification is
           pragma Preelaborate(Task_Identification);
           type Task_Id is private;
           pragma Preelaborable_Initialization (Task_Id);
           Null_Task_Id : constant Task_Id;
           function  "=" (Left, Right : Task_Id) return Boolean;

3/1        function  Image        (T : Task_Id) return String;
           function  Current_Task return Task_Id;
           procedure Abort_Task   (T : in Task_Id);

4          function  Is_Terminated(T : Task_Id) return Boolean;
           function  Is_Callable  (T : Task_Id) return Boolean;
        private
           ... -- not specified by the language
        end Ada.Task_Identification;


                              Dynamic Semantics

5   A value of the type Task_Id identifies an existent task. The constant
Null_Task_Id does not identify any task. Each object of the type Task_Id is
default initialized to the value of Null_Task_Id.

6   The function "=" returns True if and only if Left and Right identify the
same task or both have the value Null_Task_Id.

7   The function Image returns an implementation-defined string that
identifies T. If T equals Null_Task_Id, Image returns an empty string.

8   The function Current_Task returns a value that identifies the calling task.

9   The effect of Abort_Task is the same as the abort_statement for the task
identified by T. In addition, if T identifies the environment task, the entire
partition is aborted, See E.1.

10  The functions Is_Terminated and Is_Callable return the value of the
corresponding attribute of the task identified by T.

11  For a prefix T that is of a task type (after any implicit dereference),
the following attribute is defined:

12  T'Identity  Yields a value of the type Task_Id that identifies the task
                denoted by T.

13  For a prefix E that denotes an entry_declaration, the following attribute
is defined:

14  E'Caller    Yields a value of the type Task_Id that identifies the task
                whose call is now being serviced. Use of this attribute is
                allowed only inside an entry_body or accept_statement
                corresponding to the entry_declaration denoted by E.

15  Program_Error is raised if a value of Null_Task_Id is passed as a
parameter to Abort_Task, Is_Terminated, and Is_Callable.

16  Abort_Task is a potentially blocking operation (see 9.5.1).


                          Bounded (Run-Time) Errors

17/2 It is a bounded error to call the Current_Task function from an entry
body, interrupt handler, or finalization of a task attribute. Program_Error is
raised, or an implementation-defined value of the type Task_Id is returned.


                             Erroneous Execution

18  If a value of Task_Id is passed as a parameter to any of the operations
declared in this package (or any language-defined child of this package), and
the corresponding task object no longer exists, the execution of the program
is erroneous.


                         Documentation Requirements

19  The implementation shall document the effect of calling Current_Task from
an entry body or interrupt handler.

        NOTES

20      10  This package is intended for use in writing user-defined task
        scheduling packages and constructing server tasks. Current_Task can be
        used in conjunction with other operations requiring a task as an
        argument such as Set_Priority (see D.5).

21      11  The function Current_Task and the attribute Caller can return a
        Task_Id value that identifies the environment task.


C.7.2 The Package Task_Attributes



                              Static Semantics

1   The following language-defined generic library package exists:

2       with Ada.Task_Identification; use Ada.Task_Identification;
        generic
           type Attribute is private;
           Initial_Value : in Attribute;
        package Ada.Task_Attributes is

3          type Attribute_Handle is access all Attribute;

4          function Value(T : Task_Id := Current_Task)
             return Attribute;

5          function Reference(T : Task_Id := Current_Task)
             return Attribute_Handle;

6          procedure Set_Value(Val : in Attribute;
                               T : in Task_Id := Current_Task);
           procedure Reinitialize(T : in Task_Id := Current_Task);

7       end Ada.Task_Attributes;


                              Dynamic Semantics

8   When an instance of Task_Attributes is elaborated in a given active
partition, an object of the actual type corresponding to the formal type
Attribute is implicitly created for each task (of that partition) that exists
and is not yet terminated. This object acts as a user-defined attribute of the
task. A task created previously in the partition and not yet terminated has
this attribute from that point on. Each task subsequently created in the
partition will have this attribute when created. In all these cases, the
initial value of the given attribute is Initial_Value.

9   The Value operation returns the value of the corresponding attribute of T.

10  The Reference operation returns an access value that designates the
corresponding attribute of T.

11  The Set_Value operation performs any finalization on the old value of the
attribute of T and assigns Val to that attribute (see 5.2 and 7.6).

12  The effect of the Reinitialize operation is the same as Set_Value where
the Val parameter is replaced with Initial_Value.

13  For all the operations declared in this package, Tasking_Error is raised
if the task identified by T is terminated. Program_Error is raised if the
value of T is Null_Task_Id.

13.1/2 After a task has terminated, all of its attributes are finalized,
unless they have been finalized earlier. When the master of an instantiation
of Ada.Task_Attributes is finalized, the corresponding attribute of each task
is finalized, unless it has been finalized earlier.


                          Bounded (Run-Time) Errors

13.2/1 If the package Ada.Task_Attributes is instantiated with a controlled
type and the controlled type has user-defined Adjust or Finalize operations
that in turn access task attributes by any of the above operations, then a
call of Set_Value of the instantiated package constitutes a bounded error. The
call may perform as expected or may result in forever blocking the calling
task and subsequently some or all tasks of the partition.


                             Erroneous Execution

14  It is erroneous to dereference the access value returned by a given call
on Reference after a subsequent call on Reinitialize for the same task
attribute, or after the associated task terminates.

15  If a value of Task_Id is passed as a parameter to any of the operations
declared in this package and the corresponding task object no longer exists,
the execution of the program is erroneous.

15.1/2 An access to a task attribute via a value of type Attribute_Handle is
erroneous if executed concurrently with another such access or a call of any
of the operations declared in package Task_Attributes. An access to a task
attribute is erroneous if executed concurrently with or after the finalization
of the task attribute.


                         Implementation Requirements

16/1 For a given attribute of a given task, the implementation shall perform
the operations declared in this package atomically with respect to any of
these operations of the same attribute of the same task. The granularity of
any locking mechanism necessary to achieve such atomicity is implementation
defined.

17/2 After task attributes are finalized, the implementation shall reclaim any
storage associated with the attributes.


                         Documentation Requirements

18  The implementation shall document the limit on the number of attributes
per task, if any, and the limit on the total storage for attribute values per
task, if such a limit exists.

19  In addition, if these limits can be configured, the implementation shall
document how to configure them.


                                   Metrics

20/2 The implementation shall document the following metrics: A task calling
the following subprograms shall execute at a sufficiently high priority as to
not be preempted during the measurement period. This period shall start just
before issuing the call and end just after the call completes. If the
attributes of task T are accessed by the measurement tests, no other task
shall access attributes of that task during the measurement period. For all
measurements described here, the Attribute type shall be a scalar type whose
size is equal to the size of the predefined type Integer. For each
measurement, two cases shall be documented: one where the accessed attributes
are of the calling task (that is, the default value for the T parameter is
used), and the other, where T identifies another, non-terminated, task.

21  The following calls (to subprograms in the Task_Attributes package) shall
be measured:

22    * a call to Value, where the return value is Initial_Value;

23    * a call to Value, where the return value is not equal to Initial_Value;

24    * a call to Reference, where the return value designates a value equal
        to Initial_Value;

25    * a call to Reference, where the return value designates a value not
        equal to Initial_Value;

26/2   * a call to Set_Value where the Val parameter is not equal to
        Initial_Value and the old attribute value is equal to Initial_Value;

27    * a call to Set_Value where the Val parameter is not equal to
        Initial_Value and the old attribute value is not equal to
        Initial_Value.


                         Implementation Permissions

28  An implementation need not actually create the object corresponding to a
task attribute until its value is set to something other than that of
Initial_Value, or until Reference is called for the task attribute. Similarly,
when the value of the attribute is to be reinitialized to that of
Initial_Value, the object may instead be finalized and its storage reclaimed,
to be recreated when needed later. While the object does not exist, the
function Value may simply return Initial_Value, rather than implicitly
creating the object.

29  An implementation is allowed to place restrictions on the maximum number
of attributes a task may have, the maximum size of each attribute, and the
total storage size allocated for all the attributes of a task.


                            Implementation Advice

30/2 Some implementations are targeted to domains in which memory use at run
time must be completely deterministic. For such implementations, it is
recommended that the storage for task attributes will be pre-allocated
statically and not from the heap. This can be accomplished by either placing
restrictions on the number and the size of the attributes of a task, or by
using the pre-allocated storage for the first N attribute objects, and the
heap for the others. In the latter case, N should be documented.

30.1/2 Finalization of task attributes and reclamation of associated storage
should be performed as soon as possible after task termination.

        NOTES

31      12  An attribute always exists (after instantiation), and has the
        initial value. It need not occupy memory until the first operation
        that potentially changes the attribute value. The same holds true
        after Reinitialize.

32      13  The result of the Reference function should be used with care; it
        is always safe to use that result in the task body whose attribute is
        being accessed. However, when the result is being used by another
        task, the programmer must make sure that the task whose attribute is
        being accessed is not yet terminated. Failing to do so could make the
        program execution erroneous.

33/2    This paragraph was deleted.


C.7.3 The Package Task_Termination



                              Static Semantics

1/2 The following language-defined library package exists:

2/2     with Ada.Task_Identification;
        with Ada.Exceptions;
        package Ada.Task_Termination is
           pragma Preelaborate(Task_Termination);

3/2        type Cause_Of_Termination
         is (Normal, Abnormal, Unhandled_Exception);

4/2        type Termination_Handler is access protected procedure
             (Cause : in Cause_Of_Termination;
              T     : in Ada.Task_Identification.Task_Id;
              X     : in Ada.Exceptions.Exception_Occurrence);

5/2        procedure Set_Dependents_Fallback_Handler
             (Handler: in Termination_Handler);
           function Current_Task_Fallback_Handler return Termination_Handler;

6/2        procedure Set_Specific_Handler
             (T       : in Ada.Task_Identification.Task_Id;
              Handler : in Termination_Handler);
           function Specific_Handler (T : Ada.Task_Identification.Task_Id)
              return Termination_Handler;

7/2     end Ada.Task_Termination;


                              Dynamic Semantics

8/2 The type Termination_Handler identifies a protected procedure to be
executed by the implementation when a task terminates. Such a protected
procedure is called a handler. In all cases T identifies the task that is
terminating. If the task terminates due to completing the last statement of
its body, or as a result of waiting on a terminate alternative, then Cause is
set to Normal and X is set to Null_Occurrence. If the task terminates because
it is being aborted, then Cause is set to Abnormal and X is set to
Null_Occurrence. If the task terminates because of an exception raised by the
execution of its task_body, then Cause is set to Unhandled_Exception and X is
set to the associated exception occurrence.

9/2 Each task has two termination handlers, a fall-back handler and a specific
handler. The specific handler applies only to the task itself, while the
fall-back handler applies only to the dependent tasks of the task. A handler
is said to be set if it is associated with a non-null value of type
Termination_Handler, and cleared otherwise. When a task is created, its
specific handler and fall-back handler are cleared.

10/2 The procedure Set_Dependents_Fallback_Handler changes the fall-back
handler for the calling task; if Handler is null, that fall-back handler is
cleared, otherwise it is set to be Handler.all. If a fall-back handler had
previously been set it is replaced.

11/2 The function Current_Task_Fallback_Handler returns the fall-back handler
that is currently set for the calling task, if one is set; otherwise it
returns null.

12/2 The procedure Set_Specific_Handler changes the specific handler for the
task identified by T; if Handler is null, that specific handler is cleared,
otherwise it is set to be Handler.all. If a specific handler had previously
been set it is replaced.

13/2 The function Specific_Handler returns the specific handler that is
currently set for the task identified by T, if one is set; otherwise it
returns null.

14/2 As part of the finalization of a task_body, after performing the actions
specified in 7.6 for finalization of a master, the specific handler for the
task, if one is set, is executed. If the specific handler is cleared, a search
for a fall-back handler proceeds by recursively following the master
relationship for the task. If a task is found whose fall-back handler is set,
that handler is executed; otherwise, no handler is executed.

15/2 For Set_Specific_Handler or Specific_Handler, Tasking_Error is raised if
the task identified by T has already terminated. Program_Error is raised if
the value of T is Ada.Task_Identification.Null_Task_Id.

16/2 An exception propagated from a handler that is invoked as part of the
termination of a task has no effect.


                             Erroneous Execution

17/2 For a call of Set_Specific_Handler or Specific_Handler, if the task
identified by T no longer exists, the execution of the program is erroneous.

