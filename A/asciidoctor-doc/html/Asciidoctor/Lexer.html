<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=US-ASCII" http-equiv="Content-Type" />

  <title>Class: Asciidoctor::Lexer</title>

  <link rel="stylesheet" href="../rdoc.css" type="text/css" media="screen" />

  <script src="../js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/darkfish.js" type="text/javascript" charset="utf-8"></script>

</head>
<body id="top" class="class">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="../lib/asciidoctor/lexer_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/asciidoctor/lexer.rb">lib/asciidoctor/lexer.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link">Object</p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-build_block">::build_block</a></li>
          
          <li><a href="#method-c-catalog_callouts">::catalog_callouts</a></li>
          
          <li><a href="#method-c-catalog_inline_anchors">::catalog_inline_anchors</a></li>
          
          <li><a href="#method-c-grab_lines_for_list_item">::grab_lines_for_list_item</a></li>
          
          <li><a href="#method-c-initialize_section">::initialize_section</a></li>
          
          <li><a href="#method-c-is_delimited_block-3F">::is_delimited_block?</a></li>
          
          <li><a href="#method-c-is_next_line_document_title-3F">::is_next_line_document_title?</a></li>
          
          <li><a href="#method-c-is_next_line_section-3F">::is_next_line_section?</a></li>
          
          <li><a href="#method-c-is_section_title-3F">::is_section_title?</a></li>
          
          <li><a href="#method-c-is_sibling_list_item-3F">::is_sibling_list_item?</a></li>
          
          <li><a href="#method-c-is_single_line_section_title-3F">::is_single_line_section_title?</a></li>
          
          <li><a href="#method-c-is_two_line_section_title-3F">::is_two_line_section_title?</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-next_block">::next_block</a></li>
          
          <li><a href="#method-c-next_labeled_list">::next_labeled_list</a></li>
          
          <li><a href="#method-c-next_list_item">::next_list_item</a></li>
          
          <li><a href="#method-c-next_outline_list">::next_outline_list</a></li>
          
          <li><a href="#method-c-next_section">::next_section</a></li>
          
          <li><a href="#method-c-next_table">::next_table</a></li>
          
          <li><a href="#method-c-parse">::parse</a></li>
          
          <li><a href="#method-c-parse_block_metadata_line">::parse_block_metadata_line</a></li>
          
          <li><a href="#method-c-parse_block_metadata_lines">::parse_block_metadata_lines</a></li>
          
          <li><a href="#method-c-parse_cell_spec">::parse_cell_spec</a></li>
          
          <li><a href="#method-c-parse_col_specs">::parse_col_specs</a></li>
          
          <li><a href="#method-c-parse_document_header">::parse_document_header</a></li>
          
          <li><a href="#method-c-parse_header_metadata">::parse_header_metadata</a></li>
          
          <li><a href="#method-c-parse_section_title">::parse_section_title</a></li>
          
          <li><a href="#method-c-parse_style_attribute">::parse_style_attribute</a></li>
          
          <li><a href="#method-c-process_attribute_entries">::process_attribute_entries</a></li>
          
          <li><a href="#method-c-process_attribute_entry">::process_attribute_entry</a></li>
          
          <li><a href="#method-c-process_authors">::process_authors</a></li>
          
          <li><a href="#method-c-reset_block_indent-21">::reset_block_indent!</a></li>
          
          <li><a href="#method-c-resolve_list_marker">::resolve_list_marker</a></li>
          
          <li><a href="#method-c-resolve_ordered_list_marker">::resolve_ordered_list_marker</a></li>
          
          <li><a href="#method-c-roman_numeral_to_int">::roman_numeral_to_int</a></li>
          
          <li><a href="#method-c-sanitize_attribute_name">::sanitize_attribute_name</a></li>
          
          <li><a href="#method-c-section_level">::section_level</a></li>
          
          <li><a href="#method-c-single_line_section_level">::single_line_section_level</a></li>
          
          <li><a href="#method-c-store_attribute">::store_attribute</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="../images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="../Asciidoctor.html">Asciidoctor</a></li>
        
          <li><a href="../Asciidoctor/AbstractBlock.html">Asciidoctor::AbstractBlock</a></li>
        
          <li><a href="../Asciidoctor/AbstractNode.html">Asciidoctor::AbstractNode</a></li>
        
          <li><a href="../Asciidoctor/AttributeList.html">Asciidoctor::AttributeList</a></li>
        
          <li><a href="../Asciidoctor/BaseTemplate.html">Asciidoctor::BaseTemplate</a></li>
        
          <li><a href="../Asciidoctor/Block.html">Asciidoctor::Block</a></li>
        
          <li><a href="../Asciidoctor/Callouts.html">Asciidoctor::Callouts</a></li>
        
          <li><a href="../Asciidoctor/Cli.html">Asciidoctor::Cli</a></li>
        
          <li><a href="../Asciidoctor/Cli/Invoker.html">Asciidoctor::Cli::Invoker</a></li>
        
          <li><a href="../Asciidoctor/Cli/Options.html">Asciidoctor::Cli::Options</a></li>
        
          <li><a href="../Asciidoctor/Debug.html">Asciidoctor::Debug</a></li>
        
          <li><a href="../Asciidoctor/DocBook45.html">Asciidoctor::DocBook45</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockAdmonitionTemplate.html">Asciidoctor::DocBook45::BlockAdmonitionTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockAudioTemplate.html">Asciidoctor::DocBook45::BlockAudioTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockColistTemplate.html">Asciidoctor::DocBook45::BlockColistTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockDlistTemplate.html">Asciidoctor::DocBook45::BlockDlistTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockExampleTemplate.html">Asciidoctor::DocBook45::BlockExampleTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockFloatingTitleTemplate.html">Asciidoctor::DocBook45::BlockFloatingTitleTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockImageTemplate.html">Asciidoctor::DocBook45::BlockImageTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockListingTemplate.html">Asciidoctor::DocBook45::BlockListingTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockLiteralTemplate.html">Asciidoctor::DocBook45::BlockLiteralTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockOlistTemplate.html">Asciidoctor::DocBook45::BlockOlistTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockOpenTemplate.html">Asciidoctor::DocBook45::BlockOpenTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockPageBreakTemplate.html">Asciidoctor::DocBook45::BlockPageBreakTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockParagraphTemplate.html">Asciidoctor::DocBook45::BlockParagraphTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockPassTemplate.html">Asciidoctor::DocBook45::BlockPassTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockPreambleTemplate.html">Asciidoctor::DocBook45::BlockPreambleTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockQuoteTemplate.html">Asciidoctor::DocBook45::BlockQuoteTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockRulerTemplate.html">Asciidoctor::DocBook45::BlockRulerTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockSidebarTemplate.html">Asciidoctor::DocBook45::BlockSidebarTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockTableTemplate.html">Asciidoctor::DocBook45::BlockTableTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockTocTemplate.html">Asciidoctor::DocBook45::BlockTocTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockUlistTemplate.html">Asciidoctor::DocBook45::BlockUlistTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockVerseTemplate.html">Asciidoctor::DocBook45::BlockVerseTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/BlockVideoTemplate.html">Asciidoctor::DocBook45::BlockVideoTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/DocumentTemplate.html">Asciidoctor::DocBook45::DocumentTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/EmbeddedTemplate.html">Asciidoctor::DocBook45::EmbeddedTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/InlineAnchorTemplate.html">Asciidoctor::DocBook45::InlineAnchorTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/InlineBreakTemplate.html">Asciidoctor::DocBook45::InlineBreakTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/InlineButtonTemplate.html">Asciidoctor::DocBook45::InlineButtonTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/InlineCalloutTemplate.html">Asciidoctor::DocBook45::InlineCalloutTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/InlineFootnoteTemplate.html">Asciidoctor::DocBook45::InlineFootnoteTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/InlineImageTemplate.html">Asciidoctor::DocBook45::InlineImageTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/InlineIndextermTemplate.html">Asciidoctor::DocBook45::InlineIndextermTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/InlineKbdTemplate.html">Asciidoctor::DocBook45::InlineKbdTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/InlineMenuTemplate.html">Asciidoctor::DocBook45::InlineMenuTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/InlineQuotedTemplate.html">Asciidoctor::DocBook45::InlineQuotedTemplate</a></li>
        
          <li><a href="../Asciidoctor/DocBook45/SectionTemplate.html">Asciidoctor::DocBook45::SectionTemplate</a></li>
        
          <li><a href="../Asciidoctor/Document.html">Asciidoctor::Document</a></li>
        
          <li><a href="../Asciidoctor/EmptyTemplate.html">Asciidoctor::EmptyTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5.html">Asciidoctor::HTML5</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockAdmonitionTemplate.html">Asciidoctor::HTML5::BlockAdmonitionTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockAudioTemplate.html">Asciidoctor::HTML5::BlockAudioTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockColistTemplate.html">Asciidoctor::HTML5::BlockColistTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockDlistTemplate.html">Asciidoctor::HTML5::BlockDlistTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockExampleTemplate.html">Asciidoctor::HTML5::BlockExampleTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockFloatingTitleTemplate.html">Asciidoctor::HTML5::BlockFloatingTitleTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockImageTemplate.html">Asciidoctor::HTML5::BlockImageTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockListingTemplate.html">Asciidoctor::HTML5::BlockListingTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockLiteralTemplate.html">Asciidoctor::HTML5::BlockLiteralTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockOlistTemplate.html">Asciidoctor::HTML5::BlockOlistTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockOpenTemplate.html">Asciidoctor::HTML5::BlockOpenTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockPageBreakTemplate.html">Asciidoctor::HTML5::BlockPageBreakTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockParagraphTemplate.html">Asciidoctor::HTML5::BlockParagraphTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockPassTemplate.html">Asciidoctor::HTML5::BlockPassTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockPreambleTemplate.html">Asciidoctor::HTML5::BlockPreambleTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockQuoteTemplate.html">Asciidoctor::HTML5::BlockQuoteTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockRulerTemplate.html">Asciidoctor::HTML5::BlockRulerTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockSidebarTemplate.html">Asciidoctor::HTML5::BlockSidebarTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockTableTemplate.html">Asciidoctor::HTML5::BlockTableTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockTocTemplate.html">Asciidoctor::HTML5::BlockTocTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockUlistTemplate.html">Asciidoctor::HTML5::BlockUlistTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockVerseTemplate.html">Asciidoctor::HTML5::BlockVerseTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/BlockVideoTemplate.html">Asciidoctor::HTML5::BlockVideoTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/DocumentTemplate.html">Asciidoctor::HTML5::DocumentTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/EmbeddedTemplate.html">Asciidoctor::HTML5::EmbeddedTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/InlineAnchorTemplate.html">Asciidoctor::HTML5::InlineAnchorTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/InlineBreakTemplate.html">Asciidoctor::HTML5::InlineBreakTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/InlineButtonTemplate.html">Asciidoctor::HTML5::InlineButtonTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/InlineCalloutTemplate.html">Asciidoctor::HTML5::InlineCalloutTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/InlineFootnoteTemplate.html">Asciidoctor::HTML5::InlineFootnoteTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/InlineImageTemplate.html">Asciidoctor::HTML5::InlineImageTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/InlineIndextermTemplate.html">Asciidoctor::HTML5::InlineIndextermTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/InlineKbdTemplate.html">Asciidoctor::HTML5::InlineKbdTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/InlineMenuTemplate.html">Asciidoctor::HTML5::InlineMenuTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/InlineQuotedTemplate.html">Asciidoctor::HTML5::InlineQuotedTemplate</a></li>
        
          <li><a href="../Asciidoctor/HTML5/SectionTemplate.html">Asciidoctor::HTML5::SectionTemplate</a></li>
        
          <li><a href="../Asciidoctor/Helpers.html">Asciidoctor::Helpers</a></li>
        
          <li><a href="../Asciidoctor/Inline.html">Asciidoctor::Inline</a></li>
        
          <li><a href="../Asciidoctor/Lexer.html">Asciidoctor::Lexer</a></li>
        
          <li><a href="../Asciidoctor/ListItem.html">Asciidoctor::ListItem</a></li>
        
          <li><a href="../Asciidoctor/PathResolver.html">Asciidoctor::PathResolver</a></li>
        
          <li><a href="../Asciidoctor/Reader.html">Asciidoctor::Reader</a></li>
        
          <li><a href="../Asciidoctor/Renderer.html">Asciidoctor::Renderer</a></li>
        
          <li><a href="../Asciidoctor/SafeMode.html">Asciidoctor::SafeMode</a></li>
        
          <li><a href="../Asciidoctor/Section.html">Asciidoctor::Section</a></li>
        
          <li><a href="../Asciidoctor/Substituters.html">Asciidoctor::Substituters</a></li>
        
          <li><a href="../Asciidoctor/Table.html">Asciidoctor::Table</a></li>
        
          <li><a href="../Asciidoctor/Table/Cell.html">Asciidoctor::Table::Cell</a></li>
        
          <li><a href="../Asciidoctor/Table/Column.html">Asciidoctor::Table::Column</a></li>
        
          <li><a href="../Asciidoctor/Table/ParserContext.html">Asciidoctor::Table::ParserContext</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">Asciidoctor::Lexer</h1>

    <div id="description" class="description">
      
<p>Public: Methods to parse lines of AsciiDoc into an object hierarchy
representing the structure of the document. All methods are class methods
and should be invoked from the <a href="Lexer.html">Lexer</a> class. The
main entry point is <a
href="Lexer.html#method-c-next_block">::next_block</a>. No <a
href="Lexer.html">Lexer</a> instances shall be discovered running around.
(Any attempt to instantiate a <a href="Lexer.html">Lexer</a> will be
futile).</p>

<p>The object hierarchy created by the <a href="Lexer.html">Lexer</a> consists
of zero or more <a href="Section.html">Section</a> and <a
href="Block.html">Block</a> objects. <a href="Section.html">Section</a>
objects may be nested and a <a href="Section.html">Section</a> object
contains zero or more <a href="Block.html">Block</a> objects. <a
href="Block.html">Block</a> objects may be nested, but may only contain
other <a href="Block.html">Block</a> objects. <a
href="Block.html">Block</a> objects which represent lists may contain zero
or more <a href="ListItem.html">ListItem</a> objects.</p>

<p>Examples</p>

<pre># Create a Reader for the AsciiDoc lines and retrieve the next block from it.
# Lexer::next_block requires a parent, so we begin by instantiating an empty Document.

doc = Document.new
reader = Reader.new lines
block = Lexer.next_block(reader, doc)
block.class
# =&gt; Asciidoctor::Block</pre>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="BlockMatchData">BlockMatchData</a></dt>
          
          <dd class="description"></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="build_block-method" class="method-detail ">
          <a name="method-c-build_block"></a>

          
          <div class="method-heading">
            <span class="method-name">build_block</span><span
              class="method-args">(block_context, content_type, terminator, parent, reader, attributes, options = {})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>whether a block supports complex content should be a config setting if
terminator is false, that means the all the lines in the reader should be
parsed NOTE could invoke filter in here, before and after parsing</p>
            

            
            <div class="method-source-code" id="build_block-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 769</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-identifier">content_type</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">terminator</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">content_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:verbatim</span>
      <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(
          <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
          <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
          <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
          <span class="ruby-value">:skip_line_comments</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
        <span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:block_terminates_paragraph</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">line</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>]))
      }
      <span class="ruby-comment"># QUESTION check for empty buffer?</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">content_type</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:complex</span>
    <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>, <span class="ruby-value">:chomp_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">terminator</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">buffer</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">block_reader</span> = <span class="ruby-identifier">reader</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">buffer</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">block_reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">content_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:verbatim</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'indent'</span>)
    <span class="ruby-identifier">reset_block_indent!</span> <span class="ruby-identifier">buffer</span>, <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'indent'</span>].<span class="ruby-identifier">to_i</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">block_context</span>, <span class="ruby-identifier">buffer</span>)
  <span class="ruby-comment"># should supports_caption be necessary?</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:supports_caption</span>, <span class="ruby-keyword">false</span>)
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'title'</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'title'</span>)
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">assign_caption</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'caption'</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-comment"># we can look for blocks until there are no more lines (and not worry</span>
    <span class="ruby-comment"># about sections) since the reader is confined within the boundaries of a</span>
    <span class="ruby-comment"># delimited block</span>
    <span class="ruby-keyword">while</span> <span class="ruby-identifier">block_reader</span>.<span class="ruby-identifier">has_more_lines?</span>
      <span class="ruby-identifier">parsed_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">block_reader</span>, <span class="ruby-identifier">block</span>)
      <span class="ruby-identifier">block</span>.<span class="ruby-identifier">blocks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">parsed_block</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">parsed_block</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- build_block-source -->
            
          </div>

          

          
        </div><!-- build_block-method -->

      
        <div id="catalog_callouts-method" class="method-detail ">
          <a name="method-c-catalog_callouts"></a>

          
          <div class="method-heading">
            <span class="method-name">catalog_callouts</span><span
              class="method-args">(text, document)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Catalog any callouts found in the text, but don't process them</p>

<p>text     - The String of text in which to look for callouts document - The
current document on which the callouts are stored</p>

<p>Returns nothing</p>
            

            
            <div class="method-source-code" id="catalog_callouts-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 882</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">catalog_callouts</span>(<span class="ruby-identifier">text</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-identifier">text</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:callout_scan</span>]) {
    <span class="ruby-comment"># alias match for Ruby 1.8.7 compat</span>
    <span class="ruby-identifier">m</span> = <span class="ruby-identifier">$~</span>
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">start_with?</span> <span class="ruby-string">'\'</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">callouts</span>.<span class="ruby-identifier">register</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>])
  }
<span class="ruby-keyword">end</span></pre>
            </div><!-- catalog_callouts-source -->
            
          </div>

          

          
        </div><!-- catalog_callouts-method -->

      
        <div id="catalog_inline_anchors-method" class="method-detail ">
          <a name="method-c-catalog_inline_anchors"></a>

          
          <div class="method-heading">
            <span class="method-name">catalog_inline_anchors</span><span
              class="method-args">(text, document)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Catalog any inline anchors found in the text, but don't process
them</p>

<p>text     - The String text in which to look for inline anchors document -
The current document on which the references are stored</p>

<p>Returns nothing</p>
            

            
            <div class="method-source-code" id="catalog_inline_anchors-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 897</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">catalog_inline_anchors</span>(<span class="ruby-identifier">text</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-identifier">text</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:anchor_macro</span>]) {
    <span class="ruby-comment"># alias match for Ruby 1.8.7 compat</span>
    <span class="ruby-identifier">m</span> = <span class="ruby-identifier">$~</span>
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">start_with?</span> <span class="ruby-string">'\'</span>
    <span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">','</span>)
    <span class="ruby-identifier">id</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:dbl_quoted</span>], <span class="ruby-string">'\2'</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reftext</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">reftext</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:m_dbl_quoted</span>], <span class="ruby-string">'\2'</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span>])
  }
  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- catalog_inline_anchors-source -->
            
          </div>

          

          
        </div><!-- catalog_inline_anchors-method -->

      
        <div id="grab_lines_for_list_item-method" class="method-detail ">
          <a name="method-c-grab_lines_for_list_item"></a>

          
          <div class="method-heading">
            <span class="method-name">grab_lines_for_list_item</span><span
              class="method-args">(reader, list_type, sibling_trait = nil, has_text = true)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Collect the lines belonging to the current list item, navigating
through all the rules that determine what comprises a list item.</p>

<p>Grab lines until a sibling list item is found, or the block is broken by a
terminator (such as a line comment). Definition lists are more greedy if
they don't have optional inline item text...they want that text</p>

<p>reader          - The <a href="Reader.html">Reader</a> from which to
retrieve the lines. list_type       - The Symbol context of the list
(:ulist, :olist, :colist or :dlist) sibling_trait   - A Regexp that matches
a sibling of this list item or String list marker</p>

<pre>of the items in this list (default: nil)</pre>

<p>has_text        - Whether the list item has text defined inline (always
true except for labeled lists)</p>

<p>Returns an Array of lines belonging to the current list item.</p>
            

            
            <div class="method-source-code" id="grab_lines_for_list_item-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1028</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">grab_lines_for_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">buffer</span> = []

  <span class="ruby-comment"># three states for continuation: :inactive, :active &amp; :frozen</span>
  <span class="ruby-comment"># :frozen signifies we've detected sequential continuation lines &amp;</span>
  <span class="ruby-comment"># continuation is not permitted until reset </span>
  <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>

  <span class="ruby-comment"># if we are within a nested list, we don't throw away the list</span>
  <span class="ruby-comment"># continuation marks because they will be processed when grabbing</span>
  <span class="ruby-comment"># the lines for those nested lists</span>
  <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-comment"># a detached continuation is a list continuation that follows a blank line</span>
  <span class="ruby-comment"># it gets associated with the outermost block</span>
  <span class="ruby-identifier">detached_continuation</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
    <span class="ruby-identifier">this_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>

    <span class="ruby-comment"># if we've arrived at a sibling item in this list, we've captured</span>
    <span class="ruby-comment"># the complete list item and can begin processing it</span>
    <span class="ruby-comment"># the remainder of the method determines whether we've reached</span>
    <span class="ruby-comment"># the termination of the list</span>
    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)

    <span class="ruby-identifier">prev_line</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">prev_line</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">==</span> <span class="ruby-value">:inactive</span>
        <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:active</span>
        <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>
        <span class="ruby-identifier">buffer</span>[<span class="ruby-value">-1</span>] = <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">within_nested_list</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># dealing with adjacent list continuations (which is really a syntax error)</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:frozen</span>
          <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:frozen</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">this_line</span> = <span class="ruby-keyword">nil</span>
        <span class="ruby-keyword">next</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># a delimited block immediately breaks the list unless preceded</span>
    <span class="ruby-comment"># by a list continuation (they are harsh like that ;0)</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-keyword">true</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">==</span> <span class="ruby-value">:active</span>
        <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-comment"># grab all the lines in the block, leaving the delimiters in place</span>
        <span class="ruby-comment"># we're being more strict here about the terminator, but I think that's a good thing</span>
        <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">match</span>.<span class="ruby-identifier">terminator</span>, <span class="ruby-value">:grab_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
        <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-comment"># technically attr_line only breaks if ensuing line is not a list item</span>
    <span class="ruby-comment"># which really means attr_line only breaks if it's acting as a block delimiter</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:active</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>])
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">==</span> <span class="ruby-value">:active</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-comment"># literal paragraphs have special considerations (and this is one of </span>
        <span class="ruby-comment"># two entry points into one)</span>
        <span class="ruby-comment"># if we don't process it as a whole, then a line in it that looks like a</span>
        <span class="ruby-comment"># list item will throw off the exit from it</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:lit_par</span>])
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(
              <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
            <span class="ruby-comment"># we may be in an indented list disguised as a literal paragraph</span>
            <span class="ruby-comment"># so we need to make sure we don't slurp up a legitimate sibling</span>
            <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
          }
          <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>
        <span class="ruby-comment"># let block metadata play out until we find the block</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:blk_title</span>]) <span class="ruby-operator">||</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>]) <span class="ruby-operator">||</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_entry</span>])
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> = (<span class="ruby-identifier">within_nested_list</span> <span class="ruby-operator">?</span> [<span class="ruby-value">:dlist</span>] <span class="ruby-operator">:</span> <span class="ruby-constant">NESTABLE_LIST_CONTEXTS</span>).<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ctx</span><span class="ruby-operator">|</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">ctx</span>]) }
            <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">true</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">$~</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
              <span class="ruby-comment"># get greedy again</span>
              <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">prev_line</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prev_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-comment"># advance to the next line of content</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
          <span class="ruby-identifier">this_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span> 
          <span class="ruby-comment"># if we hit eof or a sibling, stop reading</span>
          <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
        <span class="ruby-keyword">end</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
          <span class="ruby-identifier">detached_continuation</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">size</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-comment"># has_text is only relevant for dlist, which is more greedy until it has text for an item</span>
          <span class="ruby-comment"># for all other lists, has_text is always true</span>
          <span class="ruby-comment"># in this block, we have to see whether we stay in the list</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">has_text</span>
            <span class="ruby-comment"># slurp up any literal paragraph offset by blank lines</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:lit_par</span>])
              <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
              <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(
                  <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
                  <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
                  <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
                <span class="ruby-comment"># we may be in an indented list disguised as a literal paragraph</span>
                <span class="ruby-comment"># so we need to make sure we don't slurp up a legitimate sibling</span>
                <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
              }
            <span class="ruby-comment"># TODO any way to combine this with the check after skipping blank lines?</span>
            <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
              <span class="ruby-keyword">break</span>
            <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">nested_list_type</span> = <span class="ruby-constant">NESTABLE_LIST_CONTEXTS</span>.<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ctx</span><span class="ruby-operator">|</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">ctx</span>]) }
              <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
              <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">true</span>
              <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">$~</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
                <span class="ruby-comment"># get greedy again</span>
                <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
              <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">else</span>
              <span class="ruby-keyword">break</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">else</span> <span class="ruby-comment"># only dlist in need of item text, so slurp it up!</span>
            <span class="ruby-comment"># pop the blank line so it's not interpretted as a list continuation</span>
            <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">within_nested_list</span>
            <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
            <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> = (<span class="ruby-identifier">within_nested_list</span> <span class="ruby-operator">?</span> [<span class="ruby-value">:dlist</span>] <span class="ruby-operator">:</span> <span class="ruby-constant">NESTABLE_LIST_CONTEXTS</span>).<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ctx</span><span class="ruby-operator">|</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">ctx</span>]) }
          <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">true</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">$~</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
            <span class="ruby-comment"># get greedy again</span>
            <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">this_line</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">nil?</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">detached_continuation</span>
    <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">delete_at</span> <span class="ruby-identifier">detached_continuation</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># strip trailing blank lines to prevent empty blocks</span>
  <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">while</span> <span class="ruby-operator">!</span><span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>

  <span class="ruby-comment"># We do need to replace the optional trailing continuation</span>
  <span class="ruby-comment"># a blank line would have served the same purpose in the document</span>
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
    <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment">#puts &quot;BUFFER[#{list_type},#{sibling_trait}]&gt;#{buffer.join}&lt;BUFFER&quot;</span>
  <span class="ruby-comment">#puts &quot;BUFFER[#{list_type},#{sibling_trait}]&gt;#{buffer.inspect}&lt;BUFFER&quot;</span>

  <span class="ruby-identifier">buffer</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- grab_lines_for_list_item-source -->
            
          </div>

          

          
        </div><!-- grab_lines_for_list_item-method -->

      
        <div id="initialize_section-method" class="method-detail ">
          <a name="method-c-initialize_section"></a>

          
          <div class="method-heading">
            <span class="method-name">initialize_section</span><span
              class="method-args">(reader, parent, attributes = {})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Initialize a new <a href="Section.html">Section</a> object and
assign any attributes provided</p>

<p>The information for this section is retrieved by parsing the lines at the
current position of the reader.</p>

<p>reader     - the source reader parent     - the parent <a
href="Section.html">Section</a> or <a href="Document.html">Document</a> of
this <a href="Section.html">Section</a> attributes - a Hash of attributes
to assign to this section (default: {})</p>
            

            
            <div class="method-source-code" id="initialize_section-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1213</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">initialize_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {})
  <span class="ruby-identifier">section</span> = <span class="ruby-constant">Section</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">parent</span>
  <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">section</span>.<span class="ruby-identifier">title</span>, <span class="ruby-identifier">section</span>.<span class="ruby-identifier">level</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">section</span>.<span class="ruby-identifier">document</span>)
  <span class="ruby-comment"># parse style, id and role from first positional attribute</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>]
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_style_attribute</span>(<span class="ruby-identifier">attributes</span>)
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">special</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-identifier">document</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>
    <span class="ruby-comment"># HACK needs to be refactored so it's driven by config</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span> <span class="ruby-operator">==</span> <span class="ruby-string">'abstract'</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">doctype</span> <span class="ruby-operator">==</span> <span class="ruby-string">'book'</span>
      <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span> = <span class="ruby-string">&quot;sect1&quot;</span>
      <span class="ruby-identifier">section</span>.<span class="ruby-identifier">special</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-identifier">section</span>.<span class="ruby-identifier">level</span> = <span class="ruby-value">1</span>
    <span class="ruby-comment"># FIXME refactor to use assign_caption (also check requirements)</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span> <span class="ruby-operator">==</span> <span class="ruby-string">'appendix'</span> <span class="ruby-operator">&amp;&amp;</span>
        <span class="ruby-operator">!</span><span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'caption'</span>) <span class="ruby-operator">&amp;&amp;</span>
        <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'caption'</span>)
      <span class="ruby-identifier">number</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">counter</span>(<span class="ruby-string">'appendix-number'</span>, <span class="ruby-string">'A'</span>)
      <span class="ruby-identifier">section</span>.<span class="ruby-identifier">caption</span> = <span class="ruby-node">&quot;#{document.attributes['appendix-caption']} #{number}: &quot;</span>
      <span class="ruby-constant">Document</span><span class="ruby-operator">::</span><span class="ruby-constant">AttributeEntry</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'appendix-number'</span>, <span class="ruby-identifier">number</span>).<span class="ruby-identifier">save_to</span>(<span class="ruby-identifier">attributes</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span> = <span class="ruby-node">&quot;sect#{section.level}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">id</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>])
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">id</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># generate an id if one was not *embedded* in the heading line</span>
    <span class="ruby-comment"># or as an anchor above the section</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">generate_id</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">section</span>.<span class="ruby-identifier">title</span>])
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">section</span>.<span class="ruby-identifier">update_attributes</span>(<span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-identifier">section</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- initialize_section-source -->
            
          </div>

          

          
        </div><!-- initialize_section-method -->

      
        <div id="is_delimited_block-3F-method" class="method-detail ">
          <a name="method-c-is_delimited_block-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_delimited_block?</span><span
              class="method-args">(line, return_match_data = false)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Determines whether this line is the start of any of the delimited
blocks</p>

<p>returns the match data if this line is the first line of a delimited block
or nil if not</p>
            

            
            <div class="method-source-code" id="is_delimited_block-3F-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 716</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">return_match_data</span> = <span class="ruby-keyword">false</span>)
  <span class="ruby-identifier">line_len</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">length</span>
  <span class="ruby-comment"># optimized for best performance</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">line_len</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">line_len</span> <span class="ruby-operator">==</span> <span class="ruby-value">3</span>
      <span class="ruby-identifier">tip</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">chop</span>
      <span class="ruby-identifier">tl</span> = <span class="ruby-value">2</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">tip</span> = <span class="ruby-identifier">line</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>]
      <span class="ruby-identifier">tl</span> = <span class="ruby-value">4</span>

      <span class="ruby-keyword">if</span> <span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:markdown_syntax</span>]
        <span class="ruby-comment"># special case for fenced code blocks</span>
        <span class="ruby-identifier">tip_alt</span> = <span class="ruby-identifier">tip</span>.<span class="ruby-identifier">chop</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">tip_alt</span> <span class="ruby-operator">==</span> <span class="ruby-string">'```'</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">tip_alt</span> <span class="ruby-operator">==</span> <span class="ruby-string">'~~~'</span>
          <span class="ruby-identifier">tip</span> = <span class="ruby-identifier">tip_alt</span>
          <span class="ruby-identifier">tl</span> = <span class="ruby-value">3</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-constant">DELIMITED_BLOCKS</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-identifier">tip</span>
      <span class="ruby-comment"># if tip is the full line</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">tl</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">line_len</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
        <span class="ruby-comment">#return_match_data ? BlockMatchData.new(DELIMITED_BLOCKS[tip], tip, tip) : true</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">return_match_data</span>
          <span class="ruby-identifier">context</span>, <span class="ruby-identifier">masq</span> = *<span class="ruby-constant">DELIMITED_BLOCKS</span>[<span class="ruby-identifier">tip</span>]
          <span class="ruby-constant">BlockMatchData</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">context</span>, <span class="ruby-identifier">masq</span>, <span class="ruby-identifier">tip</span>, <span class="ruby-identifier">tip</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:any_blk</span>])
        <span class="ruby-comment">#return_match_data ? BlockMatchData.new(DELIMITED_BLOCKS[tip], tip, match[0]) : true</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">return_match_data</span>
          <span class="ruby-identifier">context</span>, <span class="ruby-identifier">masq</span> = *<span class="ruby-constant">DELIMITED_BLOCKS</span>[<span class="ruby-identifier">tip</span>]
          <span class="ruby-constant">BlockMatchData</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">context</span>, <span class="ruby-identifier">masq</span>, <span class="ruby-identifier">tip</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>])
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">nil</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- is_delimited_block-3F-source -->
            
          </div>

          

          
        </div><!-- is_delimited_block-3F-method -->

      
        <div id="is_next_line_document_title-3F-method" class="method-detail ">
          <a name="method-c-is_next_line_document_title-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_next_line_document_title?</span><span
              class="method-args">(reader, attributes)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Convenience API for checking if the next line on the <a
href="Reader.html">Reader</a> is the document title</p>

<p>reader     - the source <a href="Reader.html">Reader</a> attributes - a
Hash of attributes collected above the current line</p>

<p>returns true if the <a href="Reader.html">Reader</a> is positioned at the
document title, false otherwise</p>
            

            
            <div class="method-source-code" id="is_next_line_document_title-3F-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1288</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_next_line_document_title?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">is_next_line_section?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- is_next_line_document_title-3F-source -->
            
          </div>

          

          
        </div><!-- is_next_line_document_title-3F-method -->

      
        <div id="is_next_line_section-3F-method" class="method-detail ">
          <a name="method-c-is_next_line_section-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_next_line_section?</span><span
              class="method-args">(reader, attributes)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Checks if the next line on the <a href="Reader.html">Reader</a>
is a section title</p>

<p>reader     - the source <a href="Reader.html">Reader</a> attributes - a
Hash of attributes collected above the current line</p>

<p>returns the section level if the <a href="Reader.html">Reader</a> is
positioned at a section title, false otherwise</p>
            

            
            <div class="method-source-code" id="is_next_line_section-3F-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1276</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_next_line_section?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">val</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>]).<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> [<span class="ruby-string">'float'</span>, <span class="ruby-string">'discrete'</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">val</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
  <span class="ruby-identifier">is_section_title?</span>(*<span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_lines</span>(<span class="ruby-value">2</span>))
<span class="ruby-keyword">end</span></pre>
            </div><!-- is_next_line_section-3F-source -->
            
          </div>

          

          
        </div><!-- is_next_line_section-3F-method -->

      
        <div id="is_section_title-3F-method" class="method-detail ">
          <a name="method-c-is_section_title-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_section_title?</span><span
              class="method-args">(line1, line2 = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Checks if these lines are a section title</p>

<p>line1 - the first line as a String line2 - the second line as a String
(default: nil)</p>

<p>returns the section level if these lines are a section title, false
otherwise</p>
            

            
            <div class="method-source-code" id="is_section_title-3F-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1299</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_section_title?</span>(<span class="ruby-identifier">line1</span>, <span class="ruby-identifier">line2</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">level</span> = <span class="ruby-identifier">is_single_line_section_title?</span>(<span class="ruby-identifier">line1</span>))
    <span class="ruby-identifier">level</span>
  <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">level</span> = <span class="ruby-identifier">is_two_line_section_title?</span>(<span class="ruby-identifier">line1</span>, <span class="ruby-identifier">line2</span>))
    <span class="ruby-identifier">level</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- is_section_title-3F-source -->
            
          </div>

          

          
        </div><!-- is_section_title-3F-method -->

      
        <div id="is_sibling_list_item-3F-method" class="method-detail ">
          <a name="method-c-is_sibling_list_item-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_sibling_list_item?</span><span
              class="method-args">(line, list_type, sibling_trait)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Determine whether the this line is a sibling list item according
to the list type and trait (marker) provided.</p>

<p>line          - The String line to check list_type     - The context of the
list (:olist, :ulist, :colist, :dlist) sibling_trait - The String marker
for the list or the Regexp to match a sibling</p>

<p>Returns a Boolean indicating whether this line is a sibling list item given
the criteria provided</p>
            

            
            <div class="method-source-code" id="is_sibling_list_item-3F-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1836</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">sibling_trait</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Regexp</span>)
    <span class="ruby-identifier">matcher</span> = <span class="ruby-identifier">sibling_trait</span>
    <span class="ruby-identifier">expected_marker</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">matcher</span> = <span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">list_type</span>]
    <span class="ruby-identifier">expected_marker</span> = <span class="ruby-identifier">sibling_trait</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">matcher</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">expected_marker</span>
      <span class="ruby-identifier">expected_marker</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>])
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- is_sibling_list_item-3F-source -->
            
          </div>

          

          
        </div><!-- is_sibling_list_item-3F-method -->

      
        <div id="is_single_line_section_title-3F-method" class="method-detail ">
          <a name="method-c-is_single_line_section_title-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_single_line_section_title?</span><span
              class="method-args">(line1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="is_single_line_section_title-3F-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1309</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_single_line_section_title?</span>(<span class="ruby-identifier">line1</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line1</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">line1</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'='</span>) <span class="ruby-operator">||</span> (<span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:markdown_syntax</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'#'</span>))) <span class="ruby-operator">&amp;&amp;</span>
      (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_title</span>]))
    <span class="ruby-identifier">single_line_section_level</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- is_single_line_section_title-3F-source -->
            
          </div>

          

          
        </div><!-- is_single_line_section_title-3F-method -->

      
        <div id="is_two_line_section_title-3F-method" class="method-detail ">
          <a name="method-c-is_two_line_section_title-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_two_line_section_title?</span><span
              class="method-args">(line1, line2)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="is_two_line_section_title-3F-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1318</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_two_line_section_title?</span>(<span class="ruby-identifier">line1</span>, <span class="ruby-identifier">line2</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line1</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line2</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">SECTION_LEVELS</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">line2</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">line2</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_underline</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_name</span>]) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-comment"># chomp so that a (non-visible) endline does not impact calculation</span>
      (<span class="ruby-identifier">line1</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">line2</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">size</span>).<span class="ruby-identifier">abs</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">section_level</span> <span class="ruby-identifier">line2</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- is_two_line_section_title-3F-source -->
            
          </div>

          

          
        </div><!-- is_two_line_section_title-3F-method -->

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          <div class="method-heading">
            <span class="method-name">new</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Make sure the <a href="Lexer.html">Lexer</a> object doesn't get
initialized.</p>

<p>Raises RuntimeError if this constructor is invoked.</p>
            

            
            <div class="method-source-code" id="new-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-string">'Au contraire, mon frere. No lexer instances will be running around.'</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
        <div id="next_block-method" class="method-detail ">
          <a name="method-c-next_block"></a>

          
          <div class="method-heading">
            <span class="method-name">next_block</span><span
              class="method-args">(reader, parent, attributes = {}, options = {})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Return the next <a href="Section.html">Section</a> or <a
href="Block.html">Block</a> object from the <a
href="Reader.html">Reader</a>.</p>

<p>Begins by skipping over blank lines to find the start of the next <a
href="Section.html">Section</a> or <a href="Block.html">Block</a>.
Processes each line of the reader in sequence until a <a
href="Section.html">Section</a> or <a href="Block.html">Block</a> is found
or the reader has no more lines.</p>

<p>Uses regular expressions from the <a
href="../Asciidoctor.html">Asciidoctor</a> module to match <a
href="Section.html">Section</a> and <a href="Block.html">Block</a>
delimiters. The ensuing lines are then processed according to the type of
content.</p>

<p>reader - The <a href="Reader.html">Reader</a> from which to retrieve the
next block parent - The <a href="Document.html">Document</a>, <a
href="Section.html">Section</a> or <a href="Block.html">Block</a> to which
the next block belongs</p>

<p>Returns a <a href="Section.html">Section</a> or <a
href="Block.html">Block</a> object holding the parsed content of the
processed lines</p>
            

            
            <div class="method-source-code" id="next_block-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 288</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {}, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-comment"># Skip ahead to the block content</span>
  <span class="ruby-identifier">skipped</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-comment"># bail if we've reached the end of the parent block or document</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>

  <span class="ruby-identifier">text_only</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>]
  <span class="ruby-comment"># check for option to find list item text only</span>
  <span class="ruby-comment"># if skipped a line, assume a list continuation was</span>
  <span class="ruby-comment"># used and block content is acceptable</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">text_only</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">skipped</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:text</span>)
    <span class="ruby-identifier">text_only</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
  
  <span class="ruby-identifier">parse_metadata</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:parse_metadata</span>, <span class="ruby-keyword">true</span>)
  <span class="ruby-comment">#parse_sections = options.fetch(:parse_sections, false)</span>

  <span class="ruby-identifier">document</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>
  <span class="ruby-identifier">parent_context</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Block</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">block</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">style</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">explicit_style</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-comment"># if parsing metadata, read until there is no more to read</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parse_metadata</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">parse_block_metadata_line</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span>)
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-comment">#elsif parse_sections &amp;&amp; parent_context.nil? &amp;&amp; is_next_line_section?(reader, attributes)</span>
    <span class="ruby-comment">#  block, attributes = next_section(reader, parent, attributes)</span>
    <span class="ruby-comment">#  break</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># QUESTION introduce parsing context object?</span>
    <span class="ruby-identifier">this_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
    <span class="ruby-identifier">delimited_block</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">block_context</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">terminator</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-comment"># QUESTION put this inside call to rekey attributes?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>]
      <span class="ruby-identifier">style</span>, <span class="ruby-identifier">explicit_style</span> = <span class="ruby-identifier">parse_style_attribute</span>(<span class="ruby-identifier">attributes</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">delimited_blk_match</span> = <span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-keyword">true</span>)
      <span class="ruby-identifier">delimited_block</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-identifier">block_context</span> = <span class="ruby-identifier">delimited_blk_match</span>.<span class="ruby-identifier">context</span>
      <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">delimited_blk_match</span>.<span class="ruby-identifier">terminator</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">style</span>
        <span class="ruby-identifier">style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">block_context</span>.<span class="ruby-identifier">to_s</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">style</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">block_context</span>.<span class="ruby-identifier">to_s</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">delimited_blk_match</span>.<span class="ruby-identifier">masq</span>.<span class="ruby-identifier">include?</span> <span class="ruby-identifier">style</span>
          <span class="ruby-identifier">block_context</span> = <span class="ruby-identifier">style</span>.<span class="ruby-identifier">to_sym</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">delimited_blk_match</span>.<span class="ruby-identifier">masq</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">'admonition'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">ADMONITION_STYLES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">style</span>)
          <span class="ruby-identifier">block_context</span> = <span class="ruby-value">:admonition</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;asciidoctor: WARNING: line #{reader.lineno}: invalid style for #{block_context} block: #{style}&quot;</span>
          <span class="ruby-identifier">style</span> = <span class="ruby-identifier">block_context</span>.<span class="ruby-identifier">to_s</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">delimited_block</span>

      <span class="ruby-comment"># this loop only executes once; used for flow control</span>
      <span class="ruby-comment"># break once a block is found or at end of loop</span>
      <span class="ruby-comment"># returns nil if the line must be dropped</span>
      <span class="ruby-comment"># Implementation note - while(true) is twice as fast as loop</span>
      <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>

        <span class="ruby-comment"># process lines verbatim</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">style</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:strict_verbatim_paragraphs</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">VERBATIM_STYLES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">style</span>)
          <span class="ruby-identifier">block_context</span> = <span class="ruby-identifier">style</span>.<span class="ruby-identifier">to_sym</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-comment"># advance to block parsing =&gt;</span>
          <span class="ruby-keyword">break</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># process lines normally</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">text_only</span>
          <span class="ruby-comment"># NOTE we're letting break lines (ruler, page_break, etc) have attributes</span>
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:break_line</span>]))
            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-constant">BREAK_LINES</span>[<span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>][<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>]])
            <span class="ruby-keyword">break</span>

          <span class="ruby-comment"># TODO make this a media_blk and handle image, video &amp; audio</span>
          <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:media_blk_macro</span>]))
            <span class="ruby-identifier">blk_ctx</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_sym</span>
            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">blk_ctx</span>)
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">blk_ctx</span> <span class="ruby-operator">==</span> <span class="ruby-value">:image</span>
              <span class="ruby-identifier">posattrs</span> = [<span class="ruby-string">'alt'</span>, <span class="ruby-string">'width'</span>, <span class="ruby-string">'height'</span>]
            <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">blk_ctx</span> <span class="ruby-operator">==</span> <span class="ruby-value">:video</span>
              <span class="ruby-identifier">posattrs</span> = [<span class="ruby-string">'poster'</span>, <span class="ruby-string">'width'</span>, <span class="ruby-string">'height'</span>]
            <span class="ruby-keyword">else</span>
              <span class="ruby-identifier">posattrs</span> = []
            <span class="ruby-keyword">end</span>

            <span class="ruby-keyword">unless</span> <span class="ruby-identifier">style</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">explicit_style</span>
              <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'alt'</span>] = <span class="ruby-identifier">style</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">blk_ctx</span> <span class="ruby-operator">==</span> <span class="ruby-value">:image</span>
              <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'style'</span>)
              <span class="ruby-identifier">style</span> = <span class="ruby-keyword">nil</span>
            <span class="ruby-keyword">end</span>

            <span class="ruby-identifier">block</span>.<span class="ruby-identifier">parse_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>], <span class="ruby-identifier">posattrs</span>,
                <span class="ruby-value">:unescape_input</span> =<span class="ruby-operator">&gt;</span> (<span class="ruby-identifier">blk_ctx</span> <span class="ruby-operator">==</span> <span class="ruby-value">:image</span>),
                <span class="ruby-value">:sub_input</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
                <span class="ruby-value">:sub_result</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>,
                <span class="ruby-value">:into</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
            <span class="ruby-identifier">target</span> = <span class="ruby-identifier">block</span>.<span class="ruby-identifier">sub_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>])
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">target</span>.<span class="ruby-identifier">empty?</span>
              <span class="ruby-comment"># drop the line if target resolves to nothing</span>
              <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
            <span class="ruby-keyword">end</span>

            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'target'</span>] = <span class="ruby-identifier">target</span>
            <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'title'</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'title'</span>)
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">blk_ctx</span> <span class="ruby-operator">==</span> <span class="ruby-value">:image</span>
              <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:images</span>, <span class="ruby-identifier">target</span>)
              <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'alt'</span>] <span class="ruby-operator">||=</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">basename</span>(<span class="ruby-identifier">target</span>, <span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-identifier">target</span>))
              <span class="ruby-comment"># QUESTION should video or audio have an auto-numbered caption?</span>
              <span class="ruby-identifier">block</span>.<span class="ruby-identifier">assign_caption</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'caption'</span>), <span class="ruby-string">'figure'</span>
            <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">break</span>

          <span class="ruby-comment"># NOTE we're letting the toc macro have attributes</span>
          <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:toc</span>]))
            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:toc</span>)
            <span class="ruby-identifier">block</span>.<span class="ruby-identifier">parse_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>], [], <span class="ruby-value">:sub_result</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>, <span class="ruby-value">:into</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
            <span class="ruby-keyword">break</span>

          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># haven't found anything yet, continue</span>
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:colist</span>]))
          <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:colist</span>)
          <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-string">'arabic'</span>
          <span class="ruby-identifier">items</span> = []
          <span class="ruby-identifier">block</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">items</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">expected_index</span> = <span class="ruby-value">1</span>
          <span class="ruby-keyword">begin</span>
            <span class="ruby-comment"># might want to move this check to a validate method</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_i</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">expected_index</span>
              <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;asciidoctor: WARNING: line #{reader.lineno + 1}: callout list item index: expected #{expected_index} got #{match[1]}&quot;</span>
            <span class="ruby-keyword">end</span>
            <span class="ruby-identifier">list_item</span> = <span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">block</span>, <span class="ruby-identifier">match</span>)
            <span class="ruby-identifier">expected_index</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
            <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">nil?</span>
              <span class="ruby-identifier">items</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">list_item</span>
              <span class="ruby-identifier">coids</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">callouts</span>.<span class="ruby-identifier">callout_ids</span>(<span class="ruby-identifier">items</span>.<span class="ruby-identifier">size</span>)
              <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">coids</span>.<span class="ruby-identifier">empty?</span>
                <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'coids'</span>] = <span class="ruby-identifier">coids</span>
              <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;asciidoctor: WARNING: line #{reader.lineno}: no callouts refer to list item #{items.size}&quot;</span>
              <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:colist</span>])

          <span class="ruby-identifier">document</span>.<span class="ruby-identifier">callouts</span>.<span class="ruby-identifier">next_list</span>
          <span class="ruby-keyword">break</span>

        <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:ulist</span>]))
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_outline_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-value">:ulist</span>, <span class="ruby-identifier">parent</span>)
          <span class="ruby-keyword">break</span>

        <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:olist</span>]))
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_outline_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-value">:olist</span>, <span class="ruby-identifier">parent</span>)
          <span class="ruby-comment"># QUESTION move this logic to next_outline_list?</span>
          <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-string">'style'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">block</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-string">'style'</span>)
            <span class="ruby-identifier">marker</span> = <span class="ruby-identifier">block</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">marker</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">start_with?</span> <span class="ruby-string">'.'</span>
              <span class="ruby-comment"># first one makes more sense, but second on is AsciiDoc-compliant</span>
              <span class="ruby-comment">#attributes['style'] = (ORDERED_LIST_STYLES[block.level - 1] || ORDERED_LIST_STYLES.first).to_s</span>
              <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = (<span class="ruby-constant">ORDERED_LIST_STYLES</span>[<span class="ruby-identifier">marker</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">first</span>).<span class="ruby-identifier">to_s</span>
            <span class="ruby-keyword">else</span>
              <span class="ruby-identifier">style</span> = <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">detect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">ORDERED_LIST_MARKER_PATTERNS</span>[<span class="ruby-identifier">s</span>]) }
              <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = (<span class="ruby-identifier">style</span> <span class="ruby-operator">||</span> <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">first</span>).<span class="ruby-identifier">to_s</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">break</span>

        <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:dlist</span>]))
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_labeled_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">parent</span>)
          <span class="ruby-keyword">break</span>

        <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">style</span> <span class="ruby-operator">==</span> <span class="ruby-string">'float'</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">style</span> <span class="ruby-operator">==</span> <span class="ruby-string">'discrete'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">is_section_title?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>)
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">float_id</span>, <span class="ruby-identifier">float_title</span>, <span class="ruby-identifier">float_level</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
          <span class="ruby-identifier">float_id</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'id'</span>)
          <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:floating_title</span>)
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">float_id</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">float_id</span>.<span class="ruby-identifier">empty?</span>
            <span class="ruby-comment"># FIXME remove hack of creating throwaway Section to get at the generate_id method</span>
            <span class="ruby-identifier">tmp_sect</span> = <span class="ruby-constant">Section</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>)
            <span class="ruby-identifier">tmp_sect</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">float_title</span>
            <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">tmp_sect</span>.<span class="ruby-identifier">generate_id</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">float_id</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">float_title</span>]) <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span>
          <span class="ruby-identifier">block</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">float_level</span>
          <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">float_title</span>
          <span class="ruby-keyword">break</span>

        <span class="ruby-comment"># FIXME create another set for &quot;passthrough&quot; styles</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">style</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">style</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'normal'</span>
          <span class="ruby-keyword">if</span> <span class="ruby-constant">PARAGRAPH_STYLES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">style</span>)
            <span class="ruby-identifier">block_context</span> = <span class="ruby-identifier">style</span>.<span class="ruby-identifier">to_sym</span>
            <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
            <span class="ruby-comment"># advance to block parsing =&gt;</span>
            <span class="ruby-keyword">break</span>
          <span class="ruby-keyword">elsif</span> <span class="ruby-constant">ADMONITION_STYLES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">style</span>)
            <span class="ruby-identifier">block_context</span> = <span class="ruby-value">:admonition</span>
            <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
            <span class="ruby-comment"># advance to block parsing =&gt;</span>
            <span class="ruby-keyword">break</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;asciidoctor: WARNING: line #{reader.lineno}: invalid style for paragraph: #{style}&quot;</span>
            <span class="ruby-identifier">style</span> = <span class="ruby-keyword">nil</span>
            <span class="ruby-comment"># continue to process paragraph</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">break_at_list</span> = (<span class="ruby-identifier">skipped</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">parent_context</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">'list'</span>))

        <span class="ruby-comment"># a literal paragraph is contiguous lines starting at least one space</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">style</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'normal'</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:lit_par</span>])
          <span class="ruby-comment"># So we need to actually include this one in the grab_lines group</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(
              <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
            <span class="ruby-comment"># a preceding blank line (skipped &gt; 0) indicates we are in a list continuation</span>
            <span class="ruby-comment"># and therefore we should not break at a list item</span>
            <span class="ruby-comment"># (this won't stop breaking on item of same level since we've already parsed them out)</span>
            <span class="ruby-comment"># QUESTION can we turn this block into a lambda or function call?</span>
            (<span class="ruby-identifier">break_at_list</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:any_list</span>])) <span class="ruby-operator">||</span>
            (<span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:block_terminates_paragraph</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">line</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>])))
          }

          <span class="ruby-identifier">reset_block_indent!</span> <span class="ruby-identifier">buffer</span>

          <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:literal</span>, <span class="ruby-identifier">buffer</span>)
          <span class="ruby-comment"># a literal gets special meaning inside of a definition list</span>
          <span class="ruby-keyword">if</span> <span class="ruby-constant">LIST_CONTEXTS</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">parent_context</span>)
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'options'</span>] <span class="ruby-operator">||=</span> []
            <span class="ruby-comment"># TODO this feels hacky, better way to distinguish from explicit literal block?</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'options'</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">'listparagraph'</span>
          <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># a paragraph is contiguous nonblank/noncontinuation lines</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(
              <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:skip_line_comments</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
            <span class="ruby-comment"># a preceding blank line (skipped &gt; 0) indicates we are in a list continuation</span>
            <span class="ruby-comment"># and therefore we should not break at a list item</span>
            <span class="ruby-comment"># (this won't stop breaking on item of same level since we've already parsed them out)</span>
            <span class="ruby-comment"># QUESTION can we turn this block into a lambda or function call?</span>
            (<span class="ruby-identifier">break_at_list</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:any_list</span>])) <span class="ruby-operator">||</span>
            (<span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:block_terminates_paragraph</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">line</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>])))
          }

          <span class="ruby-comment"># NOTE we need this logic because we've asked the reader to skip</span>
          <span class="ruby-comment"># line comments, which may leave us w/ an empty buffer if those</span>
          <span class="ruby-comment"># were the only lines found</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span>
            <span class="ruby-comment"># call get_line since the reader preserved the last line</span>
            <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
            <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
          <span class="ruby-keyword">end</span>

          <span class="ruby-identifier">catalog_inline_anchors</span>(<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">join</span>, <span class="ruby-identifier">document</span>)

          <span class="ruby-identifier">first_line</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">first</span>
          <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">text_only</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">admonition_match</span> = <span class="ruby-identifier">first_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:admonition_inline</span>]))
            <span class="ruby-identifier">buffer</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">admonition_match</span>.<span class="ruby-identifier">post_match</span>.<span class="ruby-identifier">lstrip</span>
            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:admonition</span>, <span class="ruby-identifier">buffer</span>)
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">admonition_match</span>[<span class="ruby-value">1</span>]
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'name'</span>] = <span class="ruby-identifier">admonition_name</span> = <span class="ruby-identifier">admonition_match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">downcase</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-node">&quot;#{admonition_name}-caption&quot;</span>]
          <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">text_only</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:markdown_syntax</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">first_line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'&gt; '</span>)
            <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
              <span class="ruby-keyword">if</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'&gt; '</span>)
                <span class="ruby-identifier">line</span>[<span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
              <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-string">'&gt;'</span>
                <span class="ruby-identifier">line</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
              <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">line</span>
              <span class="ruby-keyword">end</span>
            }

            <span class="ruby-keyword">if</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'-- '</span>)
              <span class="ruby-identifier">attribution</span>, <span class="ruby-identifier">citetitle</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span>[<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">', '</span>)
              <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
              <span class="ruby-identifier">buffer</span>[<span class="ruby-value">-1</span>] = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>
            <span class="ruby-keyword">else</span>
              <span class="ruby-identifier">attribution</span>, <span class="ruby-identifier">citetitle</span> = <span class="ruby-keyword">nil</span>
            <span class="ruby-keyword">end</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-string">'quote'</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'attribution'</span>] = <span class="ruby-identifier">attribution</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">attribution</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'citetitle'</span>] = <span class="ruby-identifier">citetitle</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">citetitle</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-comment"># NOTE will only detect headings that are floating titles (not section titles)</span>
            <span class="ruby-comment"># TODO could assume a floating title when inside a block context</span>
            <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-value">:quote</span>, <span class="ruby-value">:complex</span>, <span class="ruby-keyword">false</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">buffer</span>), <span class="ruby-identifier">attributes</span>)
          <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">text_only</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">first_line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'&quot;'</span>) <span class="ruby-operator">&amp;&amp;</span>
              <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'-- '</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">buffer</span>[<span class="ruby-value">-2</span>].<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">'&quot;'</span>)
            <span class="ruby-identifier">buffer</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">first_line</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
            <span class="ruby-identifier">attribution</span>, <span class="ruby-identifier">citetitle</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span>[<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">', '</span>)
            <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
            <span class="ruby-identifier">buffer</span>[<span class="ruby-value">-1</span>] = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">chop</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-string">'quote'</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'attribution'</span>] = <span class="ruby-identifier">attribution</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">attribution</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'citetitle'</span>] = <span class="ruby-identifier">citetitle</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">citetitle</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:quote</span>, <span class="ruby-identifier">buffer</span>)
            <span class="ruby-comment">#block = Block.new(parent, :quote)</span>
            <span class="ruby-comment">#block &lt;&lt; Block.new(block, :paragraph, buffer)</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-comment"># QUESTION is this necessary?</span>
            <span class="ruby-comment">#if style == 'normal' &amp;&amp; [' ', &quot;\t&quot;].include?(buffer.first[0..0])</span>
            <span class="ruby-comment">#  # QUESTION should we only trim leading blanks?</span>
            <span class="ruby-comment">#  buffer.map! &amp;:lstrip</span>
            <span class="ruby-comment">#end</span>

            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:paragraph</span>, <span class="ruby-identifier">buffer</span>)
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># forbid loop from executing more than once</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># either delimited block or styled paragraph</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block_context</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-comment"># abstract and partintro should be handled by open block</span>
      <span class="ruby-comment"># FIXME kind of hackish...need to sort out how to generalize this</span>
      <span class="ruby-identifier">block_context</span> = <span class="ruby-value">:open</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:abstract</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">block_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:partintro</span>

      <span class="ruby-keyword">case</span> <span class="ruby-identifier">block_context</span>
      <span class="ruby-keyword">when</span> <span class="ruby-value">:admonition</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'name'</span>] = <span class="ruby-identifier">admonition_name</span> = <span class="ruby-identifier">style</span>.<span class="ruby-identifier">downcase</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-node">&quot;#{admonition_name}-caption&quot;</span>]
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:complex</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)

      <span class="ruby-keyword">when</span> <span class="ruby-value">:comment</span>
        <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:chomp_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>

      <span class="ruby-keyword">when</span> <span class="ruby-value">:example</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:complex</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>, {<span class="ruby-value">:supports_caption</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>})

      <span class="ruby-keyword">when</span> <span class="ruby-value">:listing</span>, <span class="ruby-value">:fenced_code</span>, <span class="ruby-value">:source</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:fenced_code</span>
          <span class="ruby-identifier">style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-string">'source'</span>
          <span class="ruby-identifier">lang</span> = <span class="ruby-identifier">this_line</span>[<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">strip</span>
          <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'language'</span>] = <span class="ruby-identifier">lang</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">lang</span>.<span class="ruby-identifier">empty?</span>
          <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">terminator</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">terminator</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">block_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:source</span>
          <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-keyword">nil</span>, <span class="ruby-string">'language'</span>, <span class="ruby-string">'linenums'</span>])
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-value">:listing</span>, <span class="ruby-value">:verbatim</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>, {<span class="ruby-value">:supports_caption</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>})

      <span class="ruby-keyword">when</span> <span class="ruby-value">:literal</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:verbatim</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)
      
      <span class="ruby-keyword">when</span> <span class="ruby-value">:pass</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:simple</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)

      <span class="ruby-keyword">when</span> <span class="ruby-value">:open</span>, <span class="ruby-value">:sidebar</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:complex</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)

      <span class="ruby-keyword">when</span> <span class="ruby-value">:table</span>
        <span class="ruby-identifier">block_reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>, <span class="ruby-value">:skip_line_comments</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
        <span class="ruby-keyword">case</span> <span class="ruby-identifier">terminator</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]
          <span class="ruby-keyword">when</span> <span class="ruby-string">','</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'format'</span>] = <span class="ruby-string">'csv'</span>
          <span class="ruby-keyword">when</span> <span class="ruby-string">':'</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'format'</span>] = <span class="ruby-string">'dsv'</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_table</span>(<span class="ruby-identifier">block_reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)

      <span class="ruby-keyword">when</span> <span class="ruby-value">:quote</span>, <span class="ruby-value">:verse</span>
        <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-keyword">nil</span>, <span class="ruby-string">'attribution'</span>, <span class="ruby-string">'citetitle'</span>])
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, (<span class="ruby-identifier">block_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:verse</span> <span class="ruby-operator">?</span> <span class="ruby-value">:verbatim</span> <span class="ruby-operator">:</span> <span class="ruby-value">:complex</span>), <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)

      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># this should only happen if there is a misconfiguration</span>
        <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Unsupported block type #{block_context} at line #{reader.lineno}&quot;</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># when looking for nested content, one or more line comments, comment</span>
  <span class="ruby-comment"># blocks or trailing attribute lists could leave us without a block,</span>
  <span class="ruby-comment"># so handle accordingly</span>
  <span class="ruby-comment"># REVIEW we may no longer need this check</span>
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-comment"># REVIEW seems like there is a better way to organize this wrap-up</span>
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span>      <span class="ruby-operator">||=</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'id'</span>)
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span>     = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'title'</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title?</span>
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">caption</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'caption'</span>)
    <span class="ruby-comment"># AsciiDoc always use [id] as the reftext in HTML output,</span>
    <span class="ruby-comment"># but I'd like to do better in Asciidoctor</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'reftext'</span>)
      <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span>])
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">update_attributes</span>(<span class="ruby-identifier">attributes</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:listing</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:literal</span>
      <span class="ruby-identifier">catalog_callouts</span>(<span class="ruby-identifier">block</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">join</span>, <span class="ruby-identifier">document</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- next_block-source -->
            
          </div>

          

          
        </div><!-- next_block-method -->

      
        <div id="next_labeled_list-method" class="method-detail ">
          <a name="method-c-next_labeled_list"></a>

          
          <div class="method-heading">
            <span class="method-name">next_labeled_list</span><span
              class="method-args">(reader, match, parent)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Parse and construct a labeled (e.g., definition) list <a
href="Block.html">Block</a> from the current position of the <a
href="Reader.html">Reader</a></p>

<p>reader    - The <a href="Reader.html">Reader</a> from which to retrieve the
labeled list match     - The Regexp match for the head of the list parent  
- The parent <a href="Block.html">Block</a> to which this labeled list
belongs</p>

<p>Returns the <a href="Block.html">Block</a> encapsulating the parsed labeled
list</p>
            

            
            <div class="method-source-code" id="next_labeled_list-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 919</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_labeled_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">parent</span>)
  <span class="ruby-identifier">pairs</span> = []
  <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:dlist</span>)
  <span class="ruby-identifier">block</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">pairs</span>
  <span class="ruby-comment"># allows us to capture until we find a labeled item</span>
  <span class="ruby-comment"># that uses the same delimiter (::, :::, :::: or ;;)</span>
  <span class="ruby-identifier">sibling_pattern</span> = <span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:dlist_siblings</span>][<span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]]

  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">pairs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">block</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">sibling_pattern</span>)
  <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">sibling_pattern</span>)

  <span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- next_labeled_list-source -->
            
          </div>

          

          
        </div><!-- next_labeled_list-method -->

      
        <div id="next_list_item-method" class="method-detail ">
          <a name="method-c-next_list_item"></a>

          
          <div class="method-heading">
            <span class="method-name">next_list_item</span><span
              class="method-args">(reader, list_block, match, sibling_trait = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Parse and construct the next <a href="ListItem.html">ListItem</a>
for the current bulleted (unordered or ordered) list <a
href="Block.html">Block</a>, callout lists included, or the next term <a
href="ListItem.html">ListItem</a> and definition <a
href="ListItem.html">ListItem</a> pair for the labeled list <a
href="Block.html">Block</a>.</p>

<p>First collect and process all the lines that constitute the next list item
for the parent list (according to its type). Next, parse those lines into
blocks and associate them with the <a href="ListItem.html">ListItem</a> (in
the case of a labeled list, the definition <a
href="ListItem.html">ListItem</a>). Finally, fold the first block into the
item's text attribute according to rules described in <a
href="ListItem.html">ListItem</a>.</p>

<p>reader        - The <a href="Reader.html">Reader</a> from which to retrieve
the next list item list_block    - The parent list <a
href="Block.html">Block</a> of this <a href="ListItem.html">ListItem</a>.
Also provides access to the list type. match         - The match Array
which contains the marker and text (first-line) of the <a
href="ListItem.html">ListItem</a> sibling_trait - The list marker or the
Regexp to match a sibling item</p>

<p>Returns the next <a href="ListItem.html">ListItem</a> or <a
href="ListItem.html">ListItem</a> pair (depending on the list type) for the
parent list <a href="Block.html">Block</a>.</p>
            

            
            <div class="method-source-code" id="next_list_item-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 951</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">sibling_trait</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">list_type</span> = <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">context</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span>
    <span class="ruby-identifier">list_term</span> = <span class="ruby-constant">ListItem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>])
    <span class="ruby-identifier">list_item</span> = <span class="ruby-constant">ListItem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>])
    <span class="ruby-identifier">has_text</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># Create list item using first line as the text of the list item</span>
    <span class="ruby-identifier">list_item</span> = <span class="ruby-constant">ListItem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>])

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">sibling_trait</span>
      <span class="ruby-identifier">sibling_trait</span> = <span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">size</span>, <span class="ruby-keyword">true</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">marker</span> = <span class="ruby-identifier">sibling_trait</span>
    <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># first skip the line with the marker / term</span>
  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
  <span class="ruby-identifier">list_item_reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">grab_lines_for_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>, <span class="ruby-identifier">has_text</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">has_more_lines?</span>
    <span class="ruby-identifier">comment_lines</span> = <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">consume_line_comments</span>
    <span class="ruby-identifier">subsequent_line</span> = <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">peek_line</span>
    <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">unshift</span>(*<span class="ruby-identifier">comment_lines</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">comment_lines</span>.<span class="ruby-identifier">empty?</span> 

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">subsequent_line</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">continuation_connects_first_block</span> = (<span class="ruby-identifier">subsequent_line</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\n&quot;</span>)
      <span class="ruby-comment"># if there's no continuation connecting the first block, then</span>
      <span class="ruby-comment"># treat the lines as paragraph text (activated when has_text = false)</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">continuation_connects_first_block</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:dlist</span>
        <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">content_adjacent</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">subsequent_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">continuation_connects_first_block</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-identifier">content_adjacent</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># only relevant for :dlist</span>
    <span class="ruby-identifier">options</span> = {<span class="ruby-value">:text</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">has_text</span>}

    <span class="ruby-comment"># we can look for blocks until there are no more lines (and not worry</span>
    <span class="ruby-comment"># about sections) since the reader is confined within the boundaries of a</span>
    <span class="ruby-comment"># list</span>
    <span class="ruby-keyword">while</span> <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">has_more_lines?</span>
      <span class="ruby-identifier">new_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">list_item_reader</span>, <span class="ruby-identifier">list_block</span>, {}, <span class="ruby-identifier">options</span>)
      <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">blocks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_block</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">new_block</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">fold_first</span>(<span class="ruby-identifier">continuation_connects_first_block</span>, <span class="ruby-identifier">content_adjacent</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">text?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">blocks?</span>
      <span class="ruby-identifier">list_item</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
    [<span class="ruby-identifier">list_term</span>, <span class="ruby-identifier">list_item</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">list_item</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- next_list_item-source -->
            
          </div>

          

          
        </div><!-- next_list_item-method -->

      
        <div id="next_outline_list-method" class="method-detail ">
          <a name="method-c-next_outline_list"></a>

          
          <div class="method-heading">
            <span class="method-name">next_outline_list</span><span
              class="method-args">(reader, list_type, parent)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Parse and construct an outline list <a
href="Block.html">Block</a> from the current position of the <a
href="Reader.html">Reader</a></p>

<p>reader    - The <a href="Reader.html">Reader</a> from which to retrieve the
outline list list_type - A Symbol representing the list type (:olist for
ordered, :ulist for unordered) parent    - The parent <a
href="Block.html">Block</a> to which this outline list belongs</p>

<p>Returns the <a href="Block.html">Block</a> encapsulating the parsed outline
(unordered or ordered) list</p>
            

            
            <div class="method-source-code" id="next_outline_list-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 823</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_outline_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">parent</span>)
  <span class="ruby-identifier">list_block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">list_type</span>)
  <span class="ruby-identifier">items</span> = []
  <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">items</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">list_type</span>
    <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span> = <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-constant">Debug</span>.<span class="ruby-identifier">debug</span> { <span class="ruby-node">&quot;Created #{list_type} block: #{list_block}&quot;</span> }

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">list_type</span>]))

    <span class="ruby-identifier">marker</span> = <span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>])

    <span class="ruby-comment"># if we are moving to the next item, and the marker is different</span>
    <span class="ruby-comment"># determine if we are moving up or down in nesting</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">marker</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">marker</span>
      <span class="ruby-comment"># assume list is nested by default, but then check to see if we are</span>
      <span class="ruby-comment"># popping out of a nested list by matching an ancestor's list marker</span>
      <span class="ruby-identifier">this_item_level</span> = <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">p</span> = <span class="ruby-identifier">parent</span>
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">list_type</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">marker</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">marker</span>
          <span class="ruby-identifier">this_item_level</span> = <span class="ruby-identifier">p</span>.<span class="ruby-identifier">level</span>
          <span class="ruby-keyword">break</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">p</span> = <span class="ruby-identifier">p</span>.<span class="ruby-identifier">parent</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">this_item_level</span> = <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this_item_level</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
      <span class="ruby-identifier">list_item</span> = <span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>)
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">this_item_level</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
      <span class="ruby-comment"># leave this block</span>
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">this_item_level</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
      <span class="ruby-comment"># If this next list level is down one from the</span>
      <span class="ruby-comment"># current Block's, append it to content of the current list item</span>
      <span class="ruby-identifier">items</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">blocks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_block</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">items</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">list_item</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">list_item</span> = <span class="ruby-keyword">nil</span>

    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">list_block</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- next_outline_list-source -->
            
          </div>

          

          
        </div><!-- next_outline_list-method -->

      
        <div id="next_section-method" class="method-detail ">
          <a name="method-c-next_section"></a>

          
          <div class="method-heading">
            <span class="method-name">next_section</span><span
              class="method-args">(reader, parent, attributes = {})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Return the next section from the <a href="Reader.html">Reader</a>.</p>

<p>This method process block metadata, content and subsections for this
section and returns the <a href="Section.html">Section</a> object and any
orphaned attributes.</p>

<p>If the parent is a <a href="Document.html">Document</a> and has a header
(document title), then this method will put any non-section blocks at the
start of document into a preamble <a href="Block.html">Block</a>. If there
are no such blocks, the preamble is dropped.</p>

<p>Since we are reading line-by-line, there's a chance that metadata that
should be associated with the following block gets consumed. To deal with
this case, the method returns a running Hash of "orphaned" attributes that
get passed to the next <a href="Section.html">Section</a> or <a
href="Block.html">Block</a>.</p>

<p>reader     - the source <a href="Reader.html">Reader</a> parent     - the
parent <a href="Section.html">Section</a> or <a
href="Document.html">Document</a> of this new section attributes - a Hash
of metadata that was left orphaned from the</p>

<pre>previous Section.</pre>

<p>Examples</p>

<pre>source
# =&gt; &quot;Greetings\n---------\nThis is my doc.\n\nSalutations\n-----------\nIt is awesome.&quot;

reader = Reader.new source.lines.entries
# create empty document to parent the section
# and hold attributes extracted from header
doc = Document.new

Lexer.next_section(reader, doc).first.title
# =&gt; &quot;Greetings&quot;

Lexer.next_section(reader, doc).first.title
# =&gt; &quot;Salutations&quot;</pre>

<p>returns a two-element Array containing the <a
href="Section.html">Section</a> and Hash of orphaned attributes</p>
            

            
            <div class="method-source-code" id="next_section-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 167</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {})
  <span class="ruby-identifier">preamble</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-comment"># FIXME if attributes[1] is a verbatim style, then don't check for section</span>

  <span class="ruby-comment"># check if we are at the start of processing the document</span>
  <span class="ruby-comment"># NOTE we could drop a hint in the attributes to indicate</span>
  <span class="ruby-comment"># that we are at a section title (so we don't have to check)</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Document</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">blocks</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span>
      (<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">has_header?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'invalid-header'</span>) <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">is_next_line_section?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>))

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">has_header?</span>
      <span class="ruby-identifier">preamble</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:preamble</span>)
      <span class="ruby-identifier">parent</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">preamble</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">section</span> = <span class="ruby-identifier">parent</span>

    <span class="ruby-identifier">current_level</span> = <span class="ruby-value">0</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-string">'fragment'</span>
      <span class="ruby-identifier">expected_next_levels</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-comment"># small tweak to allow subsequent level-0 sections for book doctype</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">doctype</span> <span class="ruby-operator">==</span> <span class="ruby-string">'book'</span>
      <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-value">1</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">section</span> = <span class="ruby-identifier">initialize_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
    <span class="ruby-comment"># clear attributes, except for title which carries over</span>
    <span class="ruby-comment"># section title to next block of content</span>
    <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'title'</span>}
    <span class="ruby-identifier">current_level</span> = <span class="ruby-identifier">section</span>.<span class="ruby-identifier">level</span>
    <span class="ruby-comment"># subsections in preface &amp; appendix in multipart books start at level 2</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">current_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">special</span> <span class="ruby-operator">&amp;&amp;</span>
        <span class="ruby-identifier">section</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">doctype</span> <span class="ruby-operator">==</span> <span class="ruby-string">'book'</span> <span class="ruby-operator">&amp;&amp;</span> [<span class="ruby-string">'preface'</span>, <span class="ruby-string">'appendix'</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span>)
      <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-identifier">current_level</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-identifier">current_level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-comment"># Parse lines belonging to this section and its subsections until we</span>
  <span class="ruby-comment"># reach the end of this section level</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># 1. first look for metadata thingies (anchor, attribute list, block title line, etc)</span>
  <span class="ruby-comment"># 2. then look for a section, recurse if found</span>
  <span class="ruby-comment"># 3. then process blocks</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># We have to parse all the metadata lines before continuing with the loop,</span>
  <span class="ruby-comment"># otherwise subsequent metadata lines get interpreted as block content</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
    <span class="ruby-identifier">parse_block_metadata_lines</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">section</span>, <span class="ruby-identifier">attributes</span>)

    <span class="ruby-identifier">next_level</span> = <span class="ruby-identifier">is_next_line_section?</span> <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span>
      <span class="ruby-identifier">next_level</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">attr</span>(<span class="ruby-string">'leveloffset'</span>, <span class="ruby-value">0</span>).<span class="ruby-identifier">to_i</span>
      <span class="ruby-identifier">doctype</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">doctype</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">current_level</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">section</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Document</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>)
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">doctype</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'book'</span>
          <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;asciidoctor: ERROR: line #{reader.lineno + 1}: only book doctypes can contain level 0 sections&quot;</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">expected_next_levels</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">expected_next_levels</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">next_level</span>)
          <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;asciidoctor: WARNING: line #{reader.lineno + 1}: section title out of sequence: &quot;</span> <span class="ruby-operator">+</span>
              <span class="ruby-node">&quot;expected #{expected_next_levels.size &gt; 1 ? 'levels' : 'level'} #{expected_next_levels * ' or '}, &quot;</span> <span class="ruby-operator">+</span>
              <span class="ruby-node">&quot;got level #{next_level}&quot;</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-comment"># the attributes returned are those that are orphaned</span>
        <span class="ruby-identifier">new_section</span>, <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">section</span>, <span class="ruby-identifier">attributes</span>)
        <span class="ruby-identifier">section</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_section</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">doctype</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'book'</span>
          <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;asciidoctor: ERROR: line #{reader.lineno + 1}: only book doctypes can contain level 0 sections&quot;</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-comment"># close this section (and break out of the nesting) to begin a new one</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-comment"># just take one block or else we run the risk of overrunning section boundaries</span>
      <span class="ruby-identifier">new_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, (<span class="ruby-identifier">preamble</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">section</span>), <span class="ruby-identifier">attributes</span>, <span class="ruby-value">:parse_metadata</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">new_block</span>.<span class="ruby-identifier">nil?</span>
        (<span class="ruby-identifier">preamble</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">section</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_block</span>
        <span class="ruby-identifier">attributes</span> = {}
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># don't clear attributes if we don't find a block because they may</span>
        <span class="ruby-comment"># be trailing attributes that didn't get associated with a block</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">preamble</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">preamble</span>.<span class="ruby-identifier">blocks?</span>
    <span class="ruby-comment"># drop the preamble if it has no content</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">0</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># The attributes returned here are orphaned attributes that fall at the end</span>
  <span class="ruby-comment"># of a section that need to get transfered to the next section</span>
  <span class="ruby-comment"># see &quot;trailing block attributes transfer to the following section&quot; in</span>
  <span class="ruby-comment"># test/attributes_test.rb for an example</span>
  [<span class="ruby-identifier">section</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">parent</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">section</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">dup</span>]
<span class="ruby-keyword">end</span></pre>
            </div><!-- next_section-source -->
            
          </div>

          

          
        </div><!-- next_section-method -->

      
        <div id="next_table-method" class="method-detail ">
          <a name="method-c-next_table"></a>

          
          <div class="method-heading">
            <span class="method-name">next_table</span><span
              class="method-args">(table_reader, parent, attributes)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Parse the table contained in the provided <a
href="Reader.html">Reader</a></p>

<p>table_reader - a <a href="Reader.html">Reader</a> containing the source
lines of an AsciiDoc table parent       - the parent <a
href="Block.html">Block</a> of this <a
href="Table.html">Asciidoctor::Table</a> attributes   - attributes captured
from above this <a href="Block.html">Block</a></p>

<p>returns an instance of <a href="Table.html">Asciidoctor::Table</a> parsed
from the provided reader</p>
            

            
            <div class="method-source-code" id="next_table-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1863</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_table</span>(<span class="ruby-identifier">table_reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">table</span> = <span class="ruby-constant">Table</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">table</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'title'</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'title'</span>)
  <span class="ruby-identifier">table</span>.<span class="ruby-identifier">assign_caption</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'caption'</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-string">'cols'</span>
    <span class="ruby-identifier">table</span>.<span class="ruby-identifier">create_columns</span>(<span class="ruby-identifier">parse_col_specs</span>(<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'cols'</span>]))
    <span class="ruby-identifier">explicit_col_specs</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">explicit_col_specs</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-identifier">parser_ctx</span> = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ParserContext</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">has_more_lines?</span>
    <span class="ruby-identifier">line</span> = <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">get_line</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'psv'</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">starts_with_delimiter?</span> <span class="ruby-identifier">line</span>
        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">line</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
        <span class="ruby-comment"># push an empty cell spec if boundary at start of line</span>
        <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_open_cell</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">next_cell_spec</span>, <span class="ruby-identifier">line</span> = <span class="ruby-identifier">parse_cell_spec</span>(<span class="ruby-identifier">line</span>, <span class="ruby-value">:start</span>)
        <span class="ruby-comment"># if the cell spec is not null, then we're at a cell boundary</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">next_cell_spec</span>.<span class="ruby-identifier">nil?</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_open_cell</span> <span class="ruby-identifier">next_cell_spec</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-comment"># QUESTION do we not advance to next line? if so, when</span>
          <span class="ruby-comment"># will we if we came into this block?</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">while</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">match_delimiter</span>(<span class="ruby-identifier">line</span>)
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'csv'</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer_has_unclosed_quotes?</span>(<span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>)
            <span class="ruby-comment"># throw it back, it's too small</span>
            <span class="ruby-identifier">line</span> = <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">skip_matched_delimiter</span>(<span class="ruby-identifier">m</span>)
            <span class="ruby-keyword">next</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>.<span class="ruby-identifier">end_with?</span> <span class="ruby-string">'\'</span>
            <span class="ruby-identifier">line</span> = <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">skip_matched_delimiter</span>(<span class="ruby-identifier">m</span>, <span class="ruby-keyword">true</span>)
            <span class="ruby-keyword">next</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'psv'</span>
          <span class="ruby-identifier">next_cell_spec</span>, <span class="ruby-identifier">cell_text</span> = <span class="ruby-identifier">parse_cell_spec</span>(<span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>, <span class="ruby-value">:end</span>)
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">push_cell_spec</span> <span class="ruby-identifier">next_cell_spec</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-node">%(#{parser_ctx.buffer}#{cell_text})</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-node">%(#{parser_ctx.buffer}#{m.pre_match})</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">m</span>.<span class="ruby-identifier">post_match</span>
        <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_cell</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># no other delimiters to see here</span>
        <span class="ruby-comment"># suck up this line into the buffer and move on</span>
        <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-node">%(#{parser_ctx.buffer}#{line})</span>
        <span class="ruby-comment"># QUESTION make this an option? (unwrap-option?)</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'csv'</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-node">%(#{parser_ctx.buffer.rstrip} )</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">line</span> = <span class="ruby-string">''</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'psv'</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'csv'</span> <span class="ruby-operator">&amp;&amp;</span>
            <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer_has_unclosed_quotes?</span>)
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">keep_cell_open</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_cell</span> <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">skip_blank_lines</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">cell_open?</span>

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">has_more_lines?</span>
      <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_cell</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">table</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'colcount'</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">col_count</span>

  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">explicit_col_specs</span>
    <span class="ruby-comment"># TODO further encapsulate this logic (into table perhaps?)</span>
    <span class="ruby-identifier">even_width</span> = (<span class="ruby-value">100.0</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">col_count</span>).<span class="ruby-identifier">floor</span>
    <span class="ruby-identifier">table</span>.<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">assign_width</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">even_width</span>) }
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">table</span>.<span class="ruby-identifier">partition_header_footer</span> <span class="ruby-identifier">attributes</span>

  <span class="ruby-identifier">table</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- next_table-source -->
            
          </div>

          

          
        </div><!-- next_table-method -->

      
        <div id="parse-method" class="method-detail ">
          <a name="method-c-parse"></a>

          
          <div class="method-heading">
            <span class="method-name">parse</span><span
              class="method-args">(reader, document, options = {})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Parses AsciiDoc source read from the <a
href="Reader.html">Reader</a> into the <a href="Document.html">Document</a></p>

<p>This method is the main entry-point into the <a href="Lexer.html">Lexer</a>
when parsing a full document. It first looks for and, if found, processes
the document title. It then proceeds to iterate through the lines in the <a
href="Reader.html">Reader</a>, parsing the document into nested Sections
and Blocks.</p>

<p>reader   - the <a href="Reader.html">Reader</a> holding the source lines of
the document document - the empty <a href="Document.html">Document</a> into
which the lines will be parsed options  - a Hash of options to control
processing</p>

<p>returns the <a href="Document.html">Document</a> object</p>
            

            
            <div class="method-source-code" id="parse-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 47</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-identifier">block_attributes</span> = <span class="ruby-identifier">parse_document_header</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:header_only</span>]
    <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
      <span class="ruby-identifier">new_section</span>, <span class="ruby-identifier">block_attributes</span> = <span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>, <span class="ruby-identifier">block_attributes</span>)
      <span class="ruby-identifier">document</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_section</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">new_section</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">document</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- parse-source -->
            
          </div>

          

          
        </div><!-- parse-method -->

      
        <div id="parse_block_metadata_line-method" class="method-detail ">
          <a name="method-c-parse_block_metadata_line"></a>

          
          <div class="method-heading">
            <span class="method-name">parse_block_metadata_line</span><span
              class="method-args">(reader, parent, attributes, options = {})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Parse the next line if it contains metadata for the following
block</p>

<p>This method handles lines with the following content:</p>
<ul><li>
<p>line or block comment</p>
</li><li>
<p>anchor</p>
</li><li>
<p>attribute list</p>
</li><li>
<p>block title</p>
</li></ul>

<p>Any attributes found will be inserted into the attributes argument. If the
line contains block metadata, the method returns true, otherwise false.</p>

<p>reader     - the source reader parent     - the parent of the current line
attributes - a Hash of attributes in which any metadata found will be
stored options    - a Hash of options to control processing: (default: {})</p>

<pre>*  :text indicates that lexer is only looking for text content
     and thus the block title should not be captured</pre>

<p>returns true if the line contains metadata, otherwise false</p>
            

            
            <div class="method-source-code" id="parse_block_metadata_line-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1638</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_block_metadata_line</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
  <span class="ruby-identifier">next_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">commentish</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'//'</span>)) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:comment_blk</span>]))
    <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:skip_first_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>, <span class="ruby-value">:preprocess</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">commentish</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:comment</span>])
    <span class="ruby-comment"># do nothing, we'll skip it</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_entry</span>]))
    <span class="ruby-identifier">process_attribute_entry</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">match</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:anchor</span>])
    <span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">','</span>)
    <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] = <span class="ruby-identifier">id</span>
    <span class="ruby-comment"># AsciiDoc always use [id] as the reftext in HTML output,</span>
    <span class="ruby-comment"># but I'd like to do better in Asciidoctor</span>
    <span class="ruby-comment">#parent.document.register(:ids, id)</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">reftext</span>
      <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'reftext'</span>] = <span class="ruby-identifier">reftext</span>
      <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:blk_attr_list</span>])
    <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">parse_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>], [], <span class="ruby-value">:sub_input</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:into</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
  <span class="ruby-comment"># NOTE title doesn't apply to section, but we need to stash it for the first block</span>
  <span class="ruby-comment"># TODO should issue an error if this is found above the document title</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:blk_title</span>]))
    <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'title'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- parse_block_metadata_line-source -->
            
          </div>

          

          
        </div><!-- parse_block_metadata_line-method -->

      
        <div id="parse_block_metadata_lines-method" class="method-detail ">
          <a name="method-c-parse_block_metadata_lines"></a>

          
          <div class="method-heading">
            <span class="method-name">parse_block_metadata_lines</span><span
              class="method-args">(reader, parent, attributes = {}, options = {})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Parse lines of metadata until a line of metadata is not found.</p>

<p>This method processes sequential lines containing block metadata, ignoring
blank lines and comments.</p>

<p>reader     - the source reader parent     - the parent to which the lines
belong attributes - a Hash of attributes in which any metadata found will
be stored (default: {}) options    - a Hash of options to control
processing: (default: {})</p>

<pre>*  :text indicates that lexer is only looking for text content
     and thus the block title should not be captured</pre>

<p>returns the Hash of attributes including any metadata found</p>
            

            
            <div class="method-source-code" id="parse_block_metadata_lines-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1609</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_block_metadata_lines</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {}, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">parse_block_metadata_line</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span>)
    <span class="ruby-comment"># discard the line just processed</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">attributes</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- parse_block_metadata_lines-source -->
            
          </div>

          

          
        </div><!-- parse_block_metadata_lines-method -->

      
        <div id="parse_cell_spec-method" class="method-detail ">
          <a name="method-c-parse_cell_spec"></a>

          
          <div class="method-heading">
            <span class="method-name">parse_cell_spec</span><span
              class="method-args">(line, pos = :start)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Parse the cell specs for the current cell.</p>

<p>The cell specs dictate the cell's alignments, styles or filters, colspan,
rowspan and/or repeating content.</p>

<p>returns the Hash of attributes that indicate how to layout and style this
cell in the table.</p>
            

            
            <div class="method-source-code" id="parse_cell_spec-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2023</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_cell_spec</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">pos</span> = <span class="ruby-value">:start</span>)
  <span class="ruby-comment"># the default for the end pos it {} since we</span>
  <span class="ruby-comment"># know we're at a delimiter; when the pos</span>
  <span class="ruby-comment"># is start, we *may* be at a delimiter and</span>
  <span class="ruby-comment"># nil indicates we're not</span>
  <span class="ruby-identifier">spec</span> = (<span class="ruby-identifier">pos</span> <span class="ruby-operator">==</span> <span class="ruby-value">:end</span> <span class="ruby-operator">?</span> {} <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">rest</span> = <span class="ruby-identifier">line</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:table_cellspec</span>][<span class="ruby-identifier">pos</span>]) 
    <span class="ruby-identifier">spec</span> = {}
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">spec</span>, <span class="ruby-identifier">line</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">rest</span> = (<span class="ruby-identifier">pos</span> <span class="ruby-operator">==</span> <span class="ruby-value">:start</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">post_match</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>]
      <span class="ruby-identifier">colspec</span>, <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">split</span> <span class="ruby-string">'.'</span>
      <span class="ruby-identifier">colspec</span> = <span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">==</span> <span class="ruby-string">'+'</span>
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'colspan'</span>] = <span class="ruby-identifier">colspec</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">colspec</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'rowspan'</span>] = <span class="ruby-identifier">rowspec</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">rowspec</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">==</span> <span class="ruby-string">'*'</span>
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'repeatcol'</span>] = <span class="ruby-identifier">colspec</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">colspec</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>]
      <span class="ruby-identifier">colspec</span>, <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">split</span> <span class="ruby-string">'.'</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">colspec</span>)
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'halign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>][<span class="ruby-identifier">colspec</span>]
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">rowspec</span>)
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'valign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>][<span class="ruby-identifier">rowspec</span>]
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>])
      <span class="ruby-identifier">spec</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>[<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>]]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span> 

  [<span class="ruby-identifier">spec</span>, <span class="ruby-identifier">rest</span>]
<span class="ruby-keyword">end</span></pre>
            </div><!-- parse_cell_spec-source -->
            
          </div>

          

          
        </div><!-- parse_cell_spec-method -->

      
        <div id="parse_col_specs-method" class="method-detail ">
          <a name="method-c-parse_col_specs"></a>

          
          <div class="method-heading">
            <span class="method-name">parse_col_specs</span><span
              class="method-args">(records)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Parse the column specs for this table.</p>

<p>The column specs dictate the number of columns, relative width of columns,
default alignments for cells in each column, and/or default styles or
filters applied to the cells in  the column.</p>

<p>Every column spec is guaranteed to have a width</p>

<p>returns a Hash of attributes that specify how to format and layout the
cells in the table.</p>
            

            
            <div class="method-source-code" id="parse_col_specs-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1972</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_col_specs</span>(<span class="ruby-identifier">records</span>)
  <span class="ruby-identifier">specs</span> = []

  <span class="ruby-comment"># check for deprecated syntax</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">records</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:digits</span>])
    <span class="ruby-value">1</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">to_i</span>) {
      <span class="ruby-identifier">specs</span> <span class="ruby-operator">&lt;&lt;</span> {<span class="ruby-string">'width'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">specs</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">records</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">','</span>).<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">record</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># TODO might want to use scan rather than this mega-regexp</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">record</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:table_colspec</span>])
      <span class="ruby-identifier">spec</span> = {}
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>]
        <span class="ruby-comment"># make this an operation</span>
        <span class="ruby-identifier">colspec</span>, <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">split</span> <span class="ruby-string">'.'</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">colspec</span>)
          <span class="ruby-identifier">spec</span>[<span class="ruby-string">'halign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>][<span class="ruby-identifier">colspec</span>]
        <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">rowspec</span>)
          <span class="ruby-identifier">spec</span>[<span class="ruby-string">'valign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>][<span class="ruby-identifier">rowspec</span>]
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># TODO support percentage width</span>
      <span class="ruby-identifier">spec</span>[<span class="ruby-string">'width'</span>] = <span class="ruby-operator">!</span><span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span>

      <span class="ruby-comment"># make this an operation</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>])
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>[<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>]]
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">repeat</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span>

      <span class="ruby-value">1</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-identifier">repeat</span>) {
        <span class="ruby-identifier">specs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">spec</span>.<span class="ruby-identifier">dup</span>
      }
    <span class="ruby-keyword">end</span>
  }
  <span class="ruby-identifier">specs</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- parse_col_specs-source -->
            
          </div>

          

          
        </div><!-- parse_col_specs-method -->

      
        <div id="parse_document_header-method" class="method-detail ">
          <a name="method-c-parse_document_header"></a>

          
          <div class="method-heading">
            <span class="method-name">parse_document_header</span><span
              class="method-args">(reader, document)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Parses the document header of the AsciiDoc source read from the <a
href="Reader.html">Reader</a></p>

<p>Reads the AsciiDoc source from the <a href="Reader.html">Reader</a> until
the end of the document header is reached. The <a
href="Document.html">Document</a> object is populated with information from
the header (document title, document attributes, etc). The document
attributes are then saved to establish a save point to which to rollback
after parsing is complete.</p>

<p>This method assumes that there are no blank lines at the start of the
document, which are automatically removed by the reader.</p>

<p>returns the Hash of orphan block attributes captured above the header</p>
            

            
            <div class="method-source-code" id="parse_document_header-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 72</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_document_header</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-comment"># capture any lines of block-level metadata and plow away any comment lines</span>
  <span class="ruby-comment"># that precede first block</span>
  <span class="ruby-identifier">block_attributes</span> = <span class="ruby-identifier">parse_block_metadata_lines</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

  <span class="ruby-comment"># special case, block title is not allowed above document title,</span>
  <span class="ruby-comment"># carry attributes over to the document body</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'title'</span>)
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">clear_playback_attributes</span> <span class="ruby-identifier">block_attributes</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">save_attributes</span>
    <span class="ruby-identifier">block_attributes</span>[<span class="ruby-string">'invalid-header'</span>] = <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">block_attributes</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># yep, document title logic in AsciiDoc is just insanity</span>
  <span class="ruby-comment"># definitely an area for spec refinement</span>
  <span class="ruby-identifier">assigned_doctitle</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">val</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-string">'doctitle'</span>, <span class="ruby-string">''</span>)).<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">val</span>
    <span class="ruby-identifier">assigned_doctitle</span> = <span class="ruby-identifier">val</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">section_title</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-comment"># check if the first line is the document title</span>
  <span class="ruby-comment"># if so, add a header to the document and parse the header metadata</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_next_line_document_title?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">block_attributes</span>)
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">doctitle</span>, <span class="ruby-identifier">_</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">assigned_doctitle</span>
      <span class="ruby-identifier">document</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">doctitle</span>
      <span class="ruby-identifier">assigned_doctitle</span> = <span class="ruby-identifier">doctitle</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'doctitle'</span>] = <span class="ruby-identifier">section_title</span> = <span class="ruby-identifier">doctitle</span>
    <span class="ruby-comment"># QUESTION: should this be encapsulated in document?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">id</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">block_attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'id'</span>)
      <span class="ruby-identifier">document</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">block_attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'id'</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">parse_header_metadata</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">val</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-string">'doctitle'</span>, <span class="ruby-string">''</span>)).<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">val</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">section_title</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">val</span>
    <span class="ruby-identifier">assigned_doctitle</span> = <span class="ruby-identifier">val</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># restore doctitle attribute to original assignment</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">assigned_doctitle</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'doctitle'</span>] = <span class="ruby-identifier">assigned_doctitle</span>
  <span class="ruby-keyword">end</span>
 
  <span class="ruby-identifier">document</span>.<span class="ruby-identifier">clear_playback_attributes</span> <span class="ruby-identifier">block_attributes</span>
  <span class="ruby-identifier">document</span>.<span class="ruby-identifier">save_attributes</span>
 
  <span class="ruby-comment"># NOTE these are the block-level attributes (not document attributes) that</span>
  <span class="ruby-comment"># precede the first line of content (document title, first section or first block)</span>
  <span class="ruby-identifier">block_attributes</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- parse_document_header-source -->
            
          </div>

          

          
        </div><!-- parse_document_header-method -->

      
        <div id="parse_header_metadata-method" class="method-detail ">
          <a name="method-c-parse_header_metadata"></a>

          
          <div class="method-heading">
            <span class="method-name">parse_header_metadata</span><span
              class="method-args">(reader, document = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Consume and parse the two header lines (line 1 = author info, line
2 = revision info).</p>

<p>Returns the Hash of header metadata. If a <a
href="Document.html">Document</a> object is supplied, the metadata is
applied directly to the attributes of the <a
href="Document.html">Document</a>.</p>

<p>reader   - the <a href="Reader.html">Reader</a> holding the source lines of
the document document - the <a href="Document.html">Document</a> we are
building (default: nil)</p>

<p>Examples</p>

<pre>parse_header_metadata(Reader.new [&quot;Author Name &lt;author@example.org&gt;\n&quot;, &quot;v1.0, 2012-12-21: Coincide w/ end of world.\n&quot;])
# =&gt; {'author' =&gt; 'Author Name', 'firstname' =&gt; 'Author', 'lastname' =&gt; 'Name', 'email' =&gt; 'author@example.org',
#       'revnumber' =&gt; '1.0', 'revdate' =&gt; '2012-12-21', 'revremark' =&gt; 'Coincide w/ end of world.'}</pre>
            

            
            <div class="method-source-code" id="parse_header_metadata-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1420</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_header_metadata</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-comment"># NOTE this will discard away any comment lines, but not skip blank lines</span>
  <span class="ruby-identifier">process_attribute_entries</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

  <span class="ruby-identifier">metadata</span> = {}
  <span class="ruby-identifier">implicit_author</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">implicit_authors</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">author_metadata</span> = <span class="ruby-identifier">process_authors</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>

    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">author_metadata</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-comment"># apply header subs and assign to document</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">author_metadata</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">val</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">val</span> = <span class="ruby-identifier">val</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">apply_header_subs</span>(<span class="ruby-identifier">val</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">val</span>
          <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">val</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">key</span>)
          <span class="ruby-identifier">val</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">implicit_author</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'author'</span>]
        <span class="ruby-identifier">implicit_authors</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'authors'</span>]
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">metadata</span> = <span class="ruby-identifier">author_metadata</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># NOTE this will discard any comment lines, but not skip blank lines</span>
    <span class="ruby-identifier">process_attribute_entries</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

    <span class="ruby-identifier">rev_metadata</span> = {}

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">rev_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span> 
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">rev_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:revision_info</span>])
        <span class="ruby-identifier">rev_metadata</span>[<span class="ruby-string">'revdate'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">strip</span>
        <span class="ruby-identifier">rev_metadata</span>[<span class="ruby-string">'revnumber'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">rstrip</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">rev_metadata</span>[<span class="ruby-string">'revremark'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">rstrip</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># throw it back</span>
        <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">rev_line</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">rev_metadata</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-comment"># apply header subs and assign to document</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">rev_metadata</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">val</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">val</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">apply_header_subs</span>(<span class="ruby-identifier">val</span>)
          <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">val</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">key</span>)
          <span class="ruby-identifier">val</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">metadata</span>.<span class="ruby-identifier">update</span> <span class="ruby-identifier">rev_metadata</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># NOTE this will discard any comment lines, but not skip blank lines</span>
    <span class="ruby-identifier">process_attribute_entries</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-comment"># process author attribute entries that override (or stand in for) the implicit author line</span>
    <span class="ruby-identifier">author_metadata</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'author'</span>) <span class="ruby-operator">&amp;&amp;</span>
        (<span class="ruby-identifier">author_line</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'author'</span>]) <span class="ruby-operator">!=</span> <span class="ruby-identifier">implicit_author</span>
      <span class="ruby-comment"># do not allow multiple, process as names only</span>
      <span class="ruby-identifier">author_metadata</span> = <span class="ruby-identifier">process_authors</span> <span class="ruby-identifier">author_line</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">false</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'authors'</span>) <span class="ruby-operator">&amp;&amp;</span>
        (<span class="ruby-identifier">author_line</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'authors'</span>]) <span class="ruby-operator">!=</span> <span class="ruby-identifier">implicit_authors</span>
      <span class="ruby-comment"># allow multiple, process as names only</span>
      <span class="ruby-identifier">author_metadata</span> = <span class="ruby-identifier">process_authors</span> <span class="ruby-identifier">author_line</span>, <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">authors</span> = []
      <span class="ruby-identifier">author_key</span> = <span class="ruby-node">&quot;author_#{authors.size + 1}&quot;</span>
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-identifier">author_key</span>
        <span class="ruby-identifier">authors</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">author_key</span>]
        <span class="ruby-identifier">author_key</span> = <span class="ruby-node">&quot;author_#{authors.size + 1}&quot;</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">authors</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
        <span class="ruby-comment"># do not allow multiple, process as names only</span>
        <span class="ruby-identifier">author_metadata</span> = <span class="ruby-identifier">process_authors</span> <span class="ruby-identifier">authors</span>.<span class="ruby-identifier">first</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">authors</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
        <span class="ruby-comment"># allow multiple, process as names only</span>
        <span class="ruby-identifier">author_metadata</span> = <span class="ruby-identifier">process_authors</span> <span class="ruby-identifier">authors</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">'; '</span>), <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">author_metadata</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">update</span> <span class="ruby-identifier">author_metadata</span>

      <span class="ruby-comment"># special case</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'email'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'email_1'</span>)
        <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'email'</span>] = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'email_1'</span>]
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">metadata</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- parse_header_metadata-source -->
            
          </div>

          

          
        </div><!-- parse_header_metadata-method -->

      
        <div id="parse_section_title-method" class="method-detail ">
          <a name="method-c-parse_section_title"></a>

          
          <div class="method-heading">
            <span class="method-name">parse_section_title</span><span
              class="method-args">(reader, document)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Parse the section title from the current position of the reader</p>

<p>Parse a single or double-line section title. After this method is called,
the <a href="Reader.html">Reader</a> will be positioned at the line after
the section title.</p>

<p>reader  - the source reader, positioned at a section title document- the
current document</p>

<p>Examples</p>

<pre>reader.lines
# =&gt; [&quot;Foo\n&quot;, &quot;~~~\n&quot;]

title, level, id, single = parse_section_title(reader, document)

title
# =&gt; &quot;Foo&quot;
level
# =&gt; 2
id
# =&gt; nil
single
# =&gt; false

line1
# =&gt; &quot;==== Foo\n&quot;

title, level, id, single = parse_section_title(reader, document)

title
# =&gt; &quot;Foo&quot;
level
# =&gt; 3
id
# =&gt; nil
single
# =&gt; true</pre>

<p>returns an Array of [String, Integer, String, Boolean], representing the
id, title, level and line count of the <a href="Section.html">Section</a>,
or nil.</p>
            

            
            <div class="method-source-code" id="parse_section_title-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1372</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-identifier">line1</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
  <span class="ruby-identifier">sect_id</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">sect_title</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">sect_level</span> = <span class="ruby-value">-1</span>
  <span class="ruby-identifier">single_line</span> = <span class="ruby-keyword">true</span>

  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">line1</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'='</span>) <span class="ruby-operator">||</span> (<span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:markdown_syntax</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'#'</span>))) <span class="ruby-operator">&amp;&amp;</span>
      (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_title</span>]))
    <span class="ruby-identifier">sect_id</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>]
    <span class="ruby-identifier">sect_title</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]
    <span class="ruby-identifier">sect_level</span> = <span class="ruby-identifier">single_line_section_level</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">line2</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line2</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">SECTION_LEVELS</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">line2</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line2</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_underline</span>]) <span class="ruby-operator">&amp;&amp;</span>
      (<span class="ruby-identifier">name_match</span> = <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_name</span>])) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-comment"># chomp so that a (non-visible) endline does not impact calculation</span>
      (<span class="ruby-identifier">line1</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">line2</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">size</span>).<span class="ruby-identifier">abs</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">anchor_match</span> = <span class="ruby-identifier">name_match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:anchor_embedded</span>]) 
        <span class="ruby-identifier">sect_id</span> = <span class="ruby-identifier">anchor_match</span>[<span class="ruby-value">2</span>]
        <span class="ruby-identifier">sect_title</span> = <span class="ruby-identifier">anchor_match</span>[<span class="ruby-value">1</span>]
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">sect_title</span> = <span class="ruby-identifier">name_match</span>[<span class="ruby-value">1</span>]
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">sect_level</span> = <span class="ruby-identifier">section_level</span> <span class="ruby-identifier">line2</span>
      <span class="ruby-identifier">single_line</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">sect_level</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">sect_level</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attr</span>(<span class="ruby-string">'leveloffset'</span>, <span class="ruby-value">0</span>).<span class="ruby-identifier">to_i</span>
  <span class="ruby-keyword">end</span>
  [<span class="ruby-identifier">sect_id</span>, <span class="ruby-identifier">sect_title</span>, <span class="ruby-identifier">sect_level</span>, <span class="ruby-identifier">single_line</span>]
<span class="ruby-keyword">end</span></pre>
            </div><!-- parse_section_title-source -->
            
          </div>

          

          
        </div><!-- parse_section_title-method -->

      
        <div id="parse_style_attribute-method" class="method-detail ">
          <a name="method-c-parse_style_attribute"></a>

          
          <div class="method-heading">
            <span class="method-name">parse_style_attribute</span><span
              class="method-args">(attributes)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Parse the first positional attribute and assign named attributes</p>

<p>Parse the first positional attribute to extract the style, role and id
parts, assign the values to their cooresponding attribute keys and return
both the original style attribute and the parsed value from the first
positional attribute.</p>

<p>attributes - The Hash of attributes to process</p>

<p>Examples</p>

<pre>puts attributes
=&gt; {1 =&gt; &quot;abstract#intro.lead&quot;, &quot;style&quot; =&gt; &quot;preamble&quot;}

parse_style_attribute(attributes)
=&gt; [&quot;abstract&quot;, &quot;preamble&quot;]

puts attributes
=&gt; {1 =&gt; &quot;abstract#intro.lead&quot;, &quot;style&quot; =&gt; &quot;abstract&quot;, &quot;id&quot; =&gt; &quot;intro&quot;, &quot;role&quot; =&gt; &quot;lead&quot;}</pre>

<p>Returns a two-element Array of the parsed style from the first positional
attribute and the original style that was replaced</p>
            

            
            <div class="method-source-code" id="parse_style_attribute-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2088</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_style_attribute</span>(<span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">original_style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>]
  <span class="ruby-identifier">raw_style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">raw_style</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">raw_style</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">' '</span>)
    <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">raw_style</span>
    [<span class="ruby-identifier">raw_style</span>, <span class="ruby-identifier">original_style</span>]
  <span class="ruby-comment"># FIXME this logic could be condensed</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">hash_index</span> = <span class="ruby-identifier">raw_style</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">'#'</span>)
    <span class="ruby-identifier">dot_index</span> = <span class="ruby-identifier">raw_style</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">'.'</span>) 
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">hash_index</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">dot_index</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">hash_index</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">dot_index</span>)
      <span class="ruby-identifier">parsed_style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = (<span class="ruby-identifier">hash_index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">raw_style</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span>(<span class="ruby-identifier">hash_index</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>)] <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>)
      <span class="ruby-identifier">id</span> = <span class="ruby-identifier">raw_style</span>[(<span class="ruby-identifier">hash_index</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)<span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">dot_index</span>.<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">id</span>, <span class="ruby-identifier">roles</span> = <span class="ruby-identifier">id</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">'.'</span>, <span class="ruby-value">2</span>)
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] = <span class="ruby-identifier">id</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'role'</span>] = <span class="ruby-identifier">roles</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">'.'</span>, <span class="ruby-string">' '</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] = <span class="ruby-identifier">id</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">dot_index</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">hash_index</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">dot_index</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">hash_index</span>)
      <span class="ruby-identifier">parsed_style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = (<span class="ruby-identifier">dot_index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">raw_style</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span>(<span class="ruby-identifier">dot_index</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>)] <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>)
      <span class="ruby-identifier">roles</span> = <span class="ruby-identifier">raw_style</span>[(<span class="ruby-identifier">dot_index</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)<span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">hash_index</span>.<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">roles</span>, <span class="ruby-identifier">id</span> = <span class="ruby-identifier">roles</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">'#'</span>, <span class="ruby-value">2</span>)
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] = <span class="ruby-identifier">id</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'role'</span>] = <span class="ruby-identifier">roles</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">'.'</span>, <span class="ruby-string">' '</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'role'</span>] = <span class="ruby-identifier">roles</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">'.'</span>, <span class="ruby-string">' '</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">parsed_style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">raw_style</span>
    <span class="ruby-keyword">end</span>

    [<span class="ruby-identifier">parsed_style</span>, <span class="ruby-identifier">original_style</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- parse_style_attribute-source -->
            
          </div>

          

          
        </div><!-- parse_style_attribute-method -->

      
        <div id="process_attribute_entries-method" class="method-detail ">
          <a name="method-c-process_attribute_entries"></a>

          
          <div class="method-heading">
            <span class="method-name">process_attribute_entries</span><span
              class="method-args">(reader, parent, attributes = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="process_attribute_entries-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1671</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">process_attribute_entries</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_comment_lines</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">process_attribute_entry</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
    <span class="ruby-comment"># discard line just processed</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_comment_lines</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- process_attribute_entries-source -->
            
          </div>

          

          
        </div><!-- process_attribute_entries-method -->

      
        <div id="process_attribute_entry-method" class="method-detail ">
          <a name="method-c-process_attribute_entry"></a>

          
          <div class="method-heading">
            <span class="method-name">process_attribute_entry</span><span
              class="method-args">(reader, parent, attributes = nil, match = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="process_attribute_entry-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1680</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">process_attribute_entry</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">match</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">match</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_entry</span>]) <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span>
    <span class="ruby-identifier">name</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
    <span class="ruby-identifier">value</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-string">''</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">end_with?</span> <span class="ruby-constant">LINE_BREAK</span>
      <span class="ruby-identifier">value</span>.<span class="ruby-identifier">chop!</span>.<span class="ruby-identifier">rstrip!</span>
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
        <span class="ruby-identifier">next_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">strip</span>
        <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">end_with?</span> <span class="ruby-constant">LINE_BREAK</span>
          <span class="ruby-identifier">value</span> = <span class="ruby-node">&quot;#{value} #{next_line.chop.rstrip}&quot;</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">value</span> = <span class="ruby-node">&quot;#{value} #{next_line}&quot;</span>
          <span class="ruby-keyword">break</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">store_attribute</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>, <span class="ruby-identifier">attributes</span>)
    <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- process_attribute_entry-source -->
            
          </div>

          

          
        </div><!-- process_attribute_entry-method -->

      
        <div id="process_authors-method" class="method-detail ">
          <a name="method-c-process_authors"></a>

          
          <div class="method-heading">
            <span class="method-name">process_authors</span><span
              class="method-args">(author_line, names_only = false, multiple = true)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Parse the author line into a Hash of author metadata</p>

<p>author_line  - the String author line names_only   - a Boolean flag that
indicates whether to process line as</p>

<pre>names only or names with emails (default: false)</pre>

<p>multiple     - a Boolean flag that indicates whether to process multiple</p>

<pre>semicolon-separated entries in the author line (default: true)</pre>

<p>returns a Hash of author metadata</p>
            

            
            <div class="method-source-code" id="process_authors-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1532</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">process_authors</span>(<span class="ruby-identifier">author_line</span>, <span class="ruby-identifier">names_only</span> = <span class="ruby-keyword">false</span>, <span class="ruby-identifier">multiple</span> = <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">author_metadata</span> = {}
  <span class="ruby-identifier">keys</span> = [<span class="ruby-string">'author'</span>, <span class="ruby-string">'authorinitials'</span>, <span class="ruby-string">'firstname'</span>, <span class="ruby-string">'middlename'</span>, <span class="ruby-string">'lastname'</span>, <span class="ruby-string">'email'</span>]
  <span class="ruby-identifier">author_entries</span> = <span class="ruby-identifier">multiple</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">author_line</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">';'</span>).<span class="ruby-identifier">map</span>(&amp;<span class="ruby-value">:strip</span>) <span class="ruby-operator">:</span> [<span class="ruby-identifier">author_line</span>]
  <span class="ruby-identifier">author_entries</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">author_entry</span>, <span class="ruby-identifier">idx</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">author_entry</span>.<span class="ruby-identifier">strip!</span>
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">author_entry</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">key_map</span> = {}
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">idx</span>.<span class="ruby-identifier">zero?</span>
      <span class="ruby-identifier">keys</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">key_map</span>[<span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_sym</span>] = <span class="ruby-identifier">key</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">keys</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">key_map</span>[<span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_sym</span>] = <span class="ruby-node">&quot;#{key}_#{idx + 1}&quot;</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">segments</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">names_only</span>
      <span class="ruby-comment"># splitting on ' ' will collapse repeating spaces</span>
      <span class="ruby-identifier">segments</span> = <span class="ruby-identifier">author_entry</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">' '</span>, <span class="ruby-value">3</span>)
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">author_entry</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:author_info</span>]))
      <span class="ruby-identifier">segments</span> = <span class="ruby-identifier">match</span>.<span class="ruby-identifier">to_a</span>
      <span class="ruby-identifier">segments</span>.<span class="ruby-identifier">shift</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">segments</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:firstname</span>]] = <span class="ruby-identifier">fname</span> = <span class="ruby-identifier">segments</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:author</span>]] = <span class="ruby-identifier">fname</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:authorinitials</span>]] = <span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">segments</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">segments</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:middlename</span>]] = <span class="ruby-identifier">mname</span> = <span class="ruby-identifier">segments</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:lastname</span>]] = <span class="ruby-identifier">lname</span> = <span class="ruby-identifier">segments</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:author</span>]] = [<span class="ruby-identifier">fname</span>, <span class="ruby-identifier">mname</span>, <span class="ruby-identifier">lname</span>].<span class="ruby-identifier">join</span> <span class="ruby-string">' '</span>
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:authorinitials</span>]] = [<span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], <span class="ruby-identifier">mname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], <span class="ruby-identifier">lname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]].<span class="ruby-identifier">join</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">segments</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:lastname</span>]] = <span class="ruby-identifier">lname</span> = <span class="ruby-identifier">segments</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:author</span>]] = [<span class="ruby-identifier">fname</span>, <span class="ruby-identifier">lname</span>].<span class="ruby-identifier">join</span> <span class="ruby-string">' '</span>
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:authorinitials</span>]] = [<span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], <span class="ruby-identifier">lname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]].<span class="ruby-identifier">join</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:email</span>]] = <span class="ruby-identifier">segments</span>[<span class="ruby-value">3</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">names_only</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">segments</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:author</span>]] = <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:firstname</span>]] = <span class="ruby-identifier">fname</span> = <span class="ruby-identifier">author_entry</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">squeeze</span>(<span class="ruby-string">' '</span>)
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:authorinitials</span>]] = <span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">author_metadata</span>[<span class="ruby-string">'authorcount'</span>] = <span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
    <span class="ruby-comment"># only assign the _1 attributes if there are multiple authors</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">keys</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-node">&quot;#{key}_1&quot;</span>] = <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">author_metadata</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-identifier">key</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">idx</span>.<span class="ruby-identifier">zero?</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-string">'authors'</span>] = <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:author</span>]]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-string">'authors'</span>] = <span class="ruby-node">&quot;#{author_metadata['authors']}, #{author_metadata[key_map[:author]]}&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">author_metadata</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- process_authors-source -->
            
          </div>

          

          
        </div><!-- process_authors-method -->

      
        <div id="reset_block_indent-21-method" class="method-detail ">
          <a name="method-c-reset_block_indent-21"></a>

          
          <div class="method-heading">
            <span class="method-name">reset_block_indent!</span><span
              class="method-args">(lines, indent = 0)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Remove the indentation (block offset) shared by all the lines, then indent
the lines by the specified amount if specified</p>

<p>Trim the leading whitespace (indentation) equivalent to the length of the
indent on the least indented line. If the indent argument is specified,
indent the lines by this many spaces (columns).</p>

<p>The purpose of this method is to shift a block of text to align to the left
margin, while still preserving the relative indentation between lines</p>

<p>lines  - the Array of String lines to process indent - the integer number
of spaces to add to the beginning</p>

<pre>of each line; if this value is nil, the existing
space is preserved (optional, default: 0)</pre>

<p>Examples</p>

<pre>source = &lt;&lt;EOS
    def names
      @name.split ' ')
    end
EOS

source.lines.entries
# =&gt; [&quot;    def names\n&quot;, &quot;      @names.split ' '\n&quot;, &quot;    end\n&quot;]

Lexer.reset_block_indent(source.lines.entries)
# =&gt; [&quot;def names\n&quot;, &quot;  @names.split ' '\n&quot;, &quot;end\n&quot;]

puts Lexer.reset_block_indent(source.lines.entries).join
# =&gt; def names
# =&gt;   @names.split ' '
# =&gt; end</pre>

<p>returns the Array of String lines with block offset removed</p>
            

            
            <div class="method-source-code" id="reset_block_indent-21-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2162</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reset_block_indent!</span>(<span class="ruby-identifier">lines</span>, <span class="ruby-identifier">indent</span> = <span class="ruby-value">0</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">empty?</span>

  <span class="ruby-identifier">tab_detected</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-comment"># TODO make tab size configurable</span>
  <span class="ruby-identifier">tab_expansion</span> = <span class="ruby-string">'    '</span>
  <span class="ruby-comment"># strip leading block indent</span>
  <span class="ruby-identifier">offsets</span> = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># break if the first char is non-whitespace</span>
    <span class="ruby-keyword">break</span> [] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">chomp</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>].<span class="ruby-identifier">lstrip</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">include?</span> <span class="ruby-string">&quot;\t&quot;</span>
      <span class="ruby-identifier">tab_detected</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-identifier">line</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-string">&quot;\t&quot;</span>, <span class="ruby-identifier">tab_expansion</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">flush_line</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">lstrip</span>).<span class="ruby-identifier">empty?</span>
      <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">offset</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">flush_line</span>.<span class="ruby-identifier">length</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
      <span class="ruby-keyword">break</span> []
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">offset</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">offsets</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">offsets</span> = <span class="ruby-identifier">offsets</span>.<span class="ruby-identifier">compact</span>).<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">offset</span> = <span class="ruby-identifier">offsets</span>.<span class="ruby-identifier">min</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-string">&quot;\t&quot;</span>, <span class="ruby-identifier">tab_expansion</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">tab_detected</span>
        <span class="ruby-identifier">line</span>[<span class="ruby-identifier">offset</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] <span class="ruby-operator">||</span> <span class="ruby-string">&quot;\n&quot;</span>
      }
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">indent</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">padding</span> = <span class="ruby-string">' '</span> * <span class="ruby-identifier">indent</span>
    <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-node">%(#{padding}#{line})</span> }
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- reset_block_indent-21-source -->
            
          </div>

          

          
        </div><!-- reset_block_indent-21-method -->

      
        <div id="resolve_list_marker-method" class="method-detail ">
          <a name="method-c-resolve_list_marker"></a>

          
          <div class="method-heading">
            <span class="method-name">resolve_list_marker</span><span
              class="method-args">(list_type, marker, ordinal = 0, validate = false)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Resolve the 0-index marker for this list item</p>

<p>For ordered lists, match the marker used for this list item against the
known list markers and determine which marker is the first (0-index) marker
in its number series.</p>

<p>For callout lists, return &lt;1&gt;.</p>

<p>For bulleted lists, return the marker as passed to this method.</p>

<p>list_type  - The Symbol context of the list marker     - The String marker
for this list item ordinal    - The position of this list item in the list
validate   - Whether to validate the value of the marker</p>

<p>Returns the String 0-index marker for this list item</p>
            

            
            <div class="method-source-code" id="resolve_list_marker-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1750</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">marker</span>, <span class="ruby-identifier">ordinal</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">validate</span> = <span class="ruby-keyword">false</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:olist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">marker</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'.'</span>)
    <span class="ruby-identifier">resolve_ordered_list_marker</span>(<span class="ruby-identifier">marker</span>, <span class="ruby-identifier">ordinal</span>, <span class="ruby-identifier">validate</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:colist</span>
    <span class="ruby-string">'&lt;1&gt;'</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">marker</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- resolve_list_marker-source -->
            
          </div>

          

          
        </div><!-- resolve_list_marker-method -->

      
        <div id="resolve_ordered_list_marker-method" class="method-detail ">
          <a name="method-c-resolve_ordered_list_marker"></a>

          
          <div class="method-heading">
            <span class="method-name">resolve_ordered_list_marker</span><span
              class="method-args">(marker, ordinal = 0, validate = false)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Resolve the 0-index marker for this ordered list item</p>

<p>Match the marker used for this ordered list item against the known ordered
list markers and determine which marker is the first (0-index) marker in
its number series.</p>

<p>The purpose of this method is to normalize the implicit numbered markers so
that they can be compared against other list items.</p>

<p>marker   - The marker used for this list item ordinal  - The 0-based index
of the list item (default: 0) validate - Perform validation that the marker
provided is the proper</p>

<pre>marker in the sequence (default: false)</pre>

<p>Examples</p>

<pre>marker = 'B.'
Lexer::resolve_ordered_list_marker(marker, 1, true)
# =&gt; 'A.'</pre>

<p>Returns the String of the first marker in this number series</p>
            

            
            <div class="method-source-code" id="resolve_ordered_list_marker-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1781</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">resolve_ordered_list_marker</span>(<span class="ruby-identifier">marker</span>, <span class="ruby-identifier">ordinal</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">validate</span> = <span class="ruby-keyword">false</span>)
  <span class="ruby-identifier">number_style</span> = <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">ORDERED_LIST_MARKER_PATTERNS</span>[<span class="ruby-identifier">s</span>]) }
  <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">actual</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">number_style</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:arabic</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">ordinal</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'1.'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:loweralpha</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-identifier">expected</span> = (<span class="ruby-string">'a'</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">ord</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ordinal</span>).<span class="ruby-identifier">chr</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">'.'</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'a.'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:upperalpha</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-identifier">expected</span> = (<span class="ruby-string">'A'</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">ord</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ordinal</span>).<span class="ruby-identifier">chr</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">'.'</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'A.'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:lowerroman</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-comment"># TODO report this in roman numerals; see https://github.com/jamesshipton/roman-numeral/blob/master/lib/roman_numeral.rb</span>
        <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">ordinal</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">roman_numeral_to_int</span>(<span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">')'</span>))
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'i)'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:upperroman</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-comment"># TODO report this in roman numerals; see https://github.com/jamesshipton/roman-numeral/blob/master/lib/roman_numeral.rb</span>
        <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">ordinal</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">roman_numeral_to_int</span>(<span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">')'</span>))
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'I)'</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">expected</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">actual</span>
    <span class="ruby-comment"># FIXME I need a reader reference or line number to report line number</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;asciidoctor: WARNING: list item index: expected #{expected}, got #{actual}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">marker</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- resolve_ordered_list_marker-source -->
            
          </div>

          

          
        </div><!-- resolve_ordered_list_marker-method -->

      
        <div id="roman_numeral_to_int-method" class="method-detail ">
          <a name="method-c-roman_numeral_to_int"></a>

          
          <div class="method-heading">
            <span class="method-name">roman_numeral_to_int</span><span
              class="method-args">(value)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Internal: Converts a Roman numeral to an integer value.</p>

<p>value - The String Roman numeral to convert</p>

<p>Returns the Integer for this Roman numeral</p>
            

            
            <div class="method-source-code" id="roman_numeral_to_int-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2227</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">roman_numeral_to_int</span>(<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">value</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">downcase</span>
  <span class="ruby-identifier">digits</span> = { <span class="ruby-string">'i'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-string">'v'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">5</span>, <span class="ruby-string">'x'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">10</span> }
  <span class="ruby-identifier">result</span> = <span class="ruby-value">0</span>
  
  (<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-identifier">value</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">digit</span> = <span class="ruby-identifier">digits</span>[<span class="ruby-identifier">value</span>[<span class="ruby-identifier">i</span><span class="ruby-operator">..</span><span class="ruby-identifier">i</span>]]
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">digits</span>[<span class="ruby-identifier">value</span>[<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>]] <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">digit</span>
      <span class="ruby-identifier">result</span> <span class="ruby-operator">-=</span> <span class="ruby-identifier">digit</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">result</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">digit</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- roman_numeral_to_int-source -->
            
          </div>

          

          
        </div><!-- roman_numeral_to_int-method -->

      
        <div id="sanitize_attribute_name-method" class="method-detail ">
          <a name="method-c-sanitize_attribute_name"></a>

          
          <div class="method-heading">
            <span class="method-name">sanitize_attribute_name</span><span
              class="method-args">(name)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Convert a string to a legal attribute name.</p>

<p>name  - the String name of the attribute</p>

<p>Returns a String with the legal AsciiDoc attribute name.</p>

<p>Examples</p>

<pre>sanitize_attribute_name('Foo Bar')
=&gt; 'foobar'

sanitize_attribute_name('foo')
=&gt; 'foo'

sanitize_attribute_name('Foo 3 #-Billy')
=&gt; 'foo3-billy'</pre>
            

            
            <div class="method-source-code" id="sanitize_attribute_name-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2218</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">sanitize_attribute_name</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-identifier">name</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:illegal_attr_name_chars</span>], <span class="ruby-string">''</span>).<span class="ruby-identifier">downcase</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- sanitize_attribute_name-source -->
            
          </div>

          

          
        </div><!-- sanitize_attribute_name-method -->

      
        <div id="section_level-method" class="method-detail ">
          <a name="method-c-section_level"></a>

          
          <div class="method-heading">
            <span class="method-name">section_level</span><span
              class="method-args">(line)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Private: Get the Integer section level based on the characters used in the
ASCII line under the section title.</p>

<p>line - the String line from under the section title.</p>
            

            
            <div class="method-source-code" id="section_level-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1259</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">section_level</span>(<span class="ruby-identifier">line</span>)
  <span class="ruby-constant">SECTION_LEVELS</span>[<span class="ruby-identifier">line</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]]
<span class="ruby-keyword">end</span></pre>
            </div><!-- section_level-source -->
            
          </div>

          

          
        </div><!-- section_level-method -->

      
        <div id="single_line_section_level-method" class="method-detail ">
          <a name="method-c-single_line_section_level"></a>

          
          <div class="method-heading">
            <span class="method-name">single_line_section_level</span><span
              class="method-args">(marker)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="single_line_section_level-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1265</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">single_line_section_level</span>(<span class="ruby-identifier">marker</span>)
  <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- single_line_section_level-source -->
            
          </div>

          

          
        </div><!-- single_line_section_level-method -->

      
        <div id="store_attribute-method" class="method-detail ">
          <a name="method-c-store_attribute"></a>

          
          <div class="method-heading">
            <span class="method-name">store_attribute</span><span
              class="method-args">(name, value, doc = nil, attrs = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Public: Store the attribute in the document and register attribute entry if
accessible</p>

<p>name  - the String name of the attribute to store value - the String value
of the attribute to store doc   - the <a href="Document.html">Document</a>
being parsed attrs - the attributes for the current context</p>

<p>returns a 2-element array containing the attribute name and value</p>
            

            
            <div class="method-source-code" id="store_attribute-source">
<pre>
<span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1714</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">store_attribute</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">doc</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">attrs</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">'!'</span>)
    <span class="ruby-comment"># a nil value signals the attribute should be deleted (undefined)</span>
    <span class="ruby-identifier">value</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">name</span> = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">chop</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">name</span> = <span class="ruby-identifier">sanitize_attribute_name</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-identifier">accessible</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">accessible</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">delete_attribute</span>(<span class="ruby-identifier">name</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">set_attribute</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-operator">!</span><span class="ruby-identifier">accessible</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">attrs</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-constant">Document</span><span class="ruby-operator">::</span><span class="ruby-constant">AttributeEntry</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>).<span class="ruby-identifier">save_to</span>(<span class="ruby-identifier">attrs</span>)
  <span class="ruby-keyword">end</span>

  [<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>]
<span class="ruby-keyword">end</span></pre>
            </div><!-- store_attribute-source -->
            
          </div>

          

          
        </div><!-- store_attribute-method -->

      
      </div><!-- public-class-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  

  </div><!-- documentation -->

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

