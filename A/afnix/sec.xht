<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- afnix web application extension (wax) service -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<!-- page head -->
<head>
<title>
Standard Security Module</title>
<meta http-equiv="context-type" content="text/html; charset=utf-8"/>
<link href="style.css" type="text/css" rel="stylesheet"/>
<meta name="author" content="Amaury Darsch"/>
<meta name="copyright" content="1999-2012"/>
</head>
<!-- page body -->
<body>
<table>
<tr>
<td class="logo">
<img src="afnix.png" alt="AFNIX Writing System" width="120" height="120"/>
</td>
<td class="title">
Standard Security Module</td>
</tr>
</table>
<hr/>
<div class="chapter">
Standard Security Module</div>
<hr/>
<p class="text">
 The <em>Standard Security</em> module is an original implementation of several standards and techniques used in the field of cryptography. The module provides the objects than enables message hashing, symetric and assymetric ciphers and digital signature computation. The implementation follows the recommendation from NIST and PKCS and the standard reference that it implements is always attached to the underlying object. </p>
<div class="section">
Hash objects</div>
<p class="text">
 Hashing is the ability to generate an <em>almost</em> unique representation from a string. Although, there is no guarantee that two different string will not produce the same result -- known as a collision -- the sophistication of the hashing function attempt to minimize such eventuality. The hashing process is not reversible. There are several hashing functions available in the public domain. To name a few, MD5 is the <em>message digest 5</em>, and SHA is the <em>secure hash algorithm</em>. The following table illustrates the size of the result with different hashing functions. </p>
<table class="text">
<tr class="text">
<th class="text">
Function</th>
<th class="text">
Result size</th>
</tr>
<tr class="text">
<td class="text">
MD-2</td>
<td class="text">
128 bits</td>
</tr>
<tr class="text">
<td class="text">
MD-4</td>
<td class="text">
128 bits</td>
</tr>
<tr class="text">
<td class="text">
MD-5</td>
<td class="text">
128 bits</td>
</tr>
<tr class="text">
<td class="text">
SHA-1</td>
<td class="text">
160 bits</td>
</tr>
<tr class="text">
<td class="text">
SHA-224</td>
<td class="text">
224 bits</td>
</tr>
<tr class="text">
<td class="text">
SHA-256</td>
<td class="text">
256 bits</td>
</tr>
<tr class="text">
<td class="text">
SHA-384</td>
<td class="text">
384 bits</td>
</tr>
<tr class="text">
<td class="text">
SHA-512</td>
<td class="text">
512 bits</td>
</tr>
</table>
<p/>
<p class="subsect">
Hasher object</p>
<p class="text">
 The <tt class="code">Hasher</tt> class is a text hashing computation class. The class computes a <em>hash value </em> from a literal object, a buffer or an input stream. Once computed, the hash value is stored as an array of bytes that can be retrieved one by one or at all in the form of a string representation. </p>
<p class="subsect">
Creating a hasher</p>
<p class="text">
 Several hasher objects are available in the module. For example, the <tt class="code">Md5</tt> object is the hasher object that implements the MD-5 algorithm. The constructor does not take any argument. </p>
<pre class="frame">
<![CDATA[# get a  MD-5 hasher
const md (afnix:sec:Md5)
# check the object
afnix:sec:hasher-p md # true

]]></pre>
<p class="text">
 The <tt class="code">compute</tt> method computes the hash value. For example, the string "abc" returns the value <em>"900150983CD24FB0D6963F7D28E17F72"</em> which is 16 bytes long. </p>
<pre class="frame">
<![CDATA[const hval (md:compute "abc")

]]></pre>
<p class="subsect">
Creating a SHA hasher</p>
<p class="text">
 There are several SHA objects that produces results of different size as indicated in the next table. </p>
<table class="text">
<tr class="text">
<th class="text">
Hasher</th>
<th class="text">
Size</th>
<th class="text">
Constructor</th>
</tr>
<tr class="text">
<td class="text">
SHA-1</td>
<td class="text">
160 bits</td>
<td class="text">
Sha1</td>
</tr>
<tr class="text">
<td class="text">
SHA-224</td>
<td class="text">
224 bits</td>
<td class="text">
Sha224</td>
</tr>
<tr class="text">
<td class="text">
SHA-256</td>
<td class="text">
256 bits</td>
<td class="text">
Sha256</td>
</tr>
<tr class="text">
<td class="text">
SHA-384</td>
<td class="text">
384 bits</td>
<td class="text">
Sha384</td>
</tr>
<tr class="text">
<td class="text">
SHA-512</td>
<td class="text">
512 bits</td>
<td class="text">
Sha512</td>
</tr>
</table>
<p/>
<p class="text">
 The <tt class="code">compute</tt> method computes the hash value. For example, the string "abc" returns with SHA-1 the 20 bytes long value: </p>
<p class="text">
<em>"A9993E364706816ABA3E25717850C26C9CD0D89D"</em></p>
<div class="section">
Cipher key principles</div>
<p class="text">
 Cipher key management is an important concept in the ciphering land. In a simple mode, a key is used by a cipher to encode some data. Although the key can be any sequence of bytes, it is preferable to have the key built from a specific source such like a pass-phrase. A cipher key comes basically into two flavors: keys for symmetric ciphers and keys for asymmetric ciphers. A key for a symmetric cipher is easy to derive and generally follows a standard process which is independent of the cipher itself. A key for an asymmetric cipher is more complex to derive and is generally dependent on the cipher itself. </p>
<p class="subsect">
Key operations</p>
<p class="text">
 The basic operations associated with a key are the key identification by type and size. The key type is an item that identifies the key nature. The <tt class="code">get-type</tt> method returns the key type as specified by the table below. </p>
<table class="text">
<tr class="text">
<th class="text">
Key</th>
<th class="text">
Description</th>
</tr>
<tr class="text">
<td class="text">
KSYM</td>
<td class="text">
Symmetric cipher key</td>
</tr>
<tr class="text">
<td class="text">
KRSA</td>
<td class="text">
Asymmetric RSA cipher key</td>
</tr>
<tr class="text">
<td class="text">
KMAC</td>
<td class="text">
Message authentication key</td>
</tr>
<tr class="text">
<td class="text">
KDSA</td>
<td class="text">
Message signature key</td>
</tr>
</table>
<p/>
<p class="text">
 The message authentication key as represented by the <tt class="code">KMAC</tt> symbol is similar to the symmetric key. The key type can be obtained with the <tt class="code">get-type</tt> method. </p>
<pre class="frame">
<![CDATA[# get the key type
const type (key:get-type)

]]></pre>
<p class="text">
 The key size is the canonical size as specified by the key or the cipher specification. The <tt class="code">get-bits</tt> returns the key size in bits. The <tt class="code">get-size</tt> returns the key size in bytes rounded to the nearest value. The table below describes the nature of the key size returned. </p>
<table class="text">
<tr class="text">
<th class="text">
Key</th>
<th class="text">
Type</th>
<th class="text">
Description</th>
</tr>
<tr class="text">
<td class="text">
KSYM</td>
<td class="text">
byte</td>
<td class="text">
Byte array size</td>
</tr>
<tr class="text">
<td class="text">
KRSA</td>
<td class="text">
bits</td>
<td class="text">
Modulus size</td>
</tr>
<tr class="text">
<td class="text">
KMAC</td>
<td class="text">
byte</td>
<td class="text">
Byte array size</td>
</tr>
<tr class="text">
<td class="text">
KDSA</td>
<td class="text">
bits</td>
<td class="text">
Signature size</td>
</tr>
</table>
<p/>
<pre class="frame">
<![CDATA[const bits (key:get-bits)
const size (key:get-size)

]]></pre>
<p class="subsect">
Key representation</p>
<p class="text">
 Unfortunately, it is not easy to represent a key, since the representation depends on the key's type. For example, a symmetric key can be formatted as a simple octet string. On the other hand, a RSA key has two components; namely the modulus and the exponent, which needs to be distinguished and therefore making the representation more difficult. Other cipher keys are even more complicated. For this reason, the representation model is a relaxed one. The <tt class="code">format</tt> method can be called without argument to obtain an unique octet string representation if this representation is possible. If the key representation requires some parameters, the format method may accept one or several arguments to distinguish the key components. </p>
<table class="text">
<tr class="text">
<th class="text">
Key</th>
<th class="text">
Argument</th>
<th class="text">
Description</th>
</tr>
<tr class="text">
<td class="text">
KSYM</td>
<td class="text">
none</td>
<td class="text">
Symmetric key octet string</td>
</tr>
<tr class="text">
<td class="text">
KRSA</td>
<td class="text">
RSA-MODULUS</td>
<td class="text">
RSA modulus octet string</td>
</tr>
<tr class="text">
<td class="text">
KRSA</td>
<td class="text">
RSA-PUBLIC-EXPONENT</td>
<td class="text">
RSA public exponent octet string</td>
</tr>
<tr class="text">
<td class="text">
KRSA</td>
<td class="text">
RSA-SECRET-EXPONENT</td>
<td class="text">
RSA secret exponent octet string</td>
</tr>
<tr class="text">
<td class="text">
KMAC</td>
<td class="text">
none</td>
<td class="text">
Message authentication key octet string</td>
</tr>
<tr class="text">
<td class="text">
KDSA</td>
<td class="text">
DSA-P-PRIME</td>
<td class="text">
DSA secret prime octet string</td>
</tr>
<tr class="text">
<td class="text">
KDSA</td>
<td class="text">
DSA-Q-PRIME</td>
<td class="text">
DSA secret prime octet string</td>
</tr>
<tr class="text">
<td class="text">
KDSA</td>
<td class="text">
DSA-SECRET-KEY</td>
<td class="text">
DSA secret key</td>
</tr>
<tr class="text">
<td class="text">
KDSA</td>
<td class="text">
DSA-PUBLIC-KEY</td>
<td class="text">
DSA public key</td>
</tr>
<tr class="text">
<td class="text">
KDSA</td>
<td class="text">
DSA-PUBLIC-GENERATOR</td>
<td class="text">
DSA public generator</td>
</tr>
</table>
<p/>
<pre class="frame">
<![CDATA[# get a simple key representation
println (key:format)
# get a rsa modulus key representation
println (key:format afnix:sec:Key:RSA-MODULUS)

]]></pre>
<p class="text">
 There are other key representations. The natural one is the byte representation for a symmetric key, while a number based representation is generally more convenient with asymmetric keys. The <tt class="code">get-byte</tt> method returns a key byte by index if possible. The <tt class="code">get-relatif-key</tt> returns a key value by relatif number if possible. </p>
<div class="section">
Symmetric cipher key</div>
<p class="subsect">
Creating a symmetric cipher key</p>
<p class="text">
 The <tt class="code">Key</tt> class can be used to create a cipher key suitable for a symmetric cipher. By default a 128 bits random key is generated, but the key can be also generated from an octet string. </p>
<pre class="frame">
<![CDATA[const  key  (afnix:sec:Key)
assert true (afnix:sec:key-p key)

]]></pre>
<p class="text">
 The constructor also supports the use of an octet string representation of the key. </p>
<pre class="frame">
<![CDATA[# create an octet string key
const  key  (afnix:sec:Key "0123456789ABCDEF")
assert true (afnix:sec:key-p key)

]]></pre>
<p class="subsect">
Symmetric key functions</p>
<p class="text">
 The basic operation associated with a symmetric key is the byte extraction. The <tt class="code">get-size</tt> method can be used to determine the byte key size. Once the key size has been obtained, the key byte can be accessed by index with the <tt class="code">get-byte</tt> method. </p>
<pre class="frame">
<![CDATA[# create a 256 random symmetric key
const key  (afnix:sec:Key afnix:sec:Key:KSYM 256)
# get the key size
const size (key:get-size)
# get the first byte
const byte (key:get-byte 0)

]]></pre>
<div class="section">
Asymmetric cipher key</div>
<p class="text">
 An asymmetric cipher key can be generated for a particular asymmetric cipher, such like RSA. Generally, the key contains several components identified as the public and secret key components. These components are highly dependent on the cipher type. Under some circumstances, all components might not be available. </p>
<p class="subsect">
Creating an asymmetric cipher key</p>
<p class="text">
 The <tt class="code">Key</tt> class can be used to create a specific asymmetric cipher key. Generally, the key is created by type and and bits size. </p>
<pre class="frame">
<![CDATA[# create a 1024 bits rsa key
const  key  (afnix:sec:Key afnix:sec:Key:KRSA 1024)

]]></pre>
<p class="text">
 An asymmetric cipher key constructor is extremely dependent on the cipher type. For this reason, there is no constructor that can operate with a pass-phrase. </p>
<p class="subsect">
Asymmetric key functions</p>
<p class="text">
 The basic operation associated with a asymmetric key is the relatif based representation which is generally available for all key components. For example, in the case of the RSA cipher, the modulus, the public and secret exponents can be obtained in a relatif number based representation with the help of the <tt class="code">get-relatif-key</tt> method. </p>
<pre class="frame">
<![CDATA[# create a 512 rsa key
const key  (afnix:sec:Key afnix:sec:Key:KRSA 512)
# get the key modulus
const kmod (
  key:get-relatif-key afnix:sec:Key:RSA-MODULUS)
# get the public exponent
const pexp (
  key:get-relatif-key afnix:sec:Key:RSA-PUBLIC-EXPONENT)
# get the secret exponent
const sexp (
  key:get-relatif-key afnix:sec:Key:RSA-SECRET-EXPONENT)

]]></pre>
<div class="section">
Message authentication key</div>
<p class="subsect">
Creating a message authentication key</p>
<p class="text">
 The <tt class="code">Key</tt> class can also be used to create a message authentication key suitable for a message authentication code generator or validator. By default a 128 bits random key is generated, but the key can be also generated from an octet string. </p>
<pre class="frame">
<![CDATA[const  key  (afnix:sec:Key afnix:sec:Key:KMAC)
assert true (afnix:sec:key-p key)

]]></pre>
<p class="text">
 The constructor also supports the use of an octet string as a key representation. </p>
<pre class="frame">
<![CDATA[# create an octet string key
const key (
  afnix:sec:Key afnix:sec:Key:KMAC "0123456789ABCDEF")
assert true (afnix:sec:key-p key)

]]></pre>
<p class="subsect">
Message authentication key functions</p>
<p class="text">
 The basic operation associated with a message authentication key is the byte extraction. The <tt class="code">get-size</tt> method can be used to determine the byte key size. Once the key size has been obtained, the key byte can be accessed by index with the <tt class="code">get-byte</tt> method. </p>
<pre class="frame">
<![CDATA[# create a 256 random message authentication key
const key  (afnix:sec:Key afnix:sec:Key:KMAC 256)
# get the key size
const size (key:get-size)
# get the first byte
const byte (key:get-byte 0)

]]></pre>
<p class="subsect">
Signature key functions</p>
<p class="text">
 The basic operation associated with a signature key is the relatif based representation which is generally available for all key components. For example, in the case of the DSA signer, the prime numbers, the public and secret components can be obtained in a relatif number based representation with the help of the <tt class="code">get-relatif-key</tt> method. </p>
<pre class="frame">
<![CDATA[# create a 1024 dsa key
const key  (afnix:sec:Key afnix:sec:Key:KDSA)
# get the key size
const size (key:get-size)
# get the secret component
const sexp (
  key:get-relatif-key afnix:sec:Key:DSA-SECRET-KEY)

]]></pre>
<div class="section">
Stream cipher</div>
<p class="text">
 A stream cipher is an object that encodes an input stream into an output stream. The data are read from the input stream, encoded and transmitted onto the output stream. There are basically two types of stream ciphers known as symmetric cipher and asymmetric cipher. </p>
<p class="subsect">
Symmetric cipher</p>
<p class="text">
 A symmetric cipher is a cipher that encodes and decode data with the same key. Normally, the key is kept secret, and the data are encoded by block. For this reason, symmetric cipher are also called block cipher. In normal mode, a symmetric cipher is created with key and the data are encoded from an input stream as long as they are available. The block size depends on the nature of the cipher. As of today, the recommended symmetric cipher is the <em>Advanced Encryption Standard</em> or AES, also known as Rijndael. </p>
<p class="subsect">
Asymmetric cipher</p>
<p class="text">
 An asymmetric cipher is a cipher that encodes and decode data with two keys. Normally, the data are encoded with a public key and decoded with a private key. In this model, anybody can encode a data stream, but only one person can read them. Obviously, the model can be reverse to operate in a kind of signature mode, where only one person can encode the data stream and anybody can read them. Asymmetric cipher are particularly useful when operating on unsecured channels. In this model, one end can send its public key as a mean for other people to crypt data that can only be read by the sender who is supposed to have the private key. As of today, the recommended asymmetric ciphers are RSA and DH. </p>
<p class="subsect">
Serial cipher</p>
<p class="text">
 A serial cipher is a cipher that encodes and decode data on a byte basis. Normally, the data are encoded and decoded with the same key, thus making the symmetric cipher key, the ideal candidate for a serial cipher key. Since the data is encoded on a byte basis, it can be used efficiently with a stream. However, the serial cipher does not define a block size and therefore require some mechanism to prevent a buffer overrun when reading bytes from a stream. For this reason, the serial cipher defines a default <em>serial block size</em> that can be used to buffer the stream data. A method is provided in the class to control the buffer size and is by default set to 4Kib bytes. </p>
<p class="subsect">
Cipher base class</p>
<p class="text">
 The <tt class="code">Cipher</tt> base class is an abstract class that supports the symmetric, asymmetric and serial cipher models. A cipher object has a name and is bound to a key that is used by the cipher. The class provides some base methods that can be used to retrieve some information about the cipher. The <tt class="code">get-name</tt> method returns the cipher name. The <tt class="code">set-key</tt> and <tt class="code">get-key</tt> methods are both used to set or retrieve the cipher key. </p>
<p class="text">
 The cipher operating mode can be found with the <tt class="code">get-reverse</tt> method. If the <tt class="code">get-reverse</tt> method returns true, the cipher is operating in decoding mode. Note that a <tt class="code">set-reverse</tt> method also exists. </p>
<div class="section">
Block cipher</div>
<p class="text">
 A block cipher is an object that encodes an input stream with a symmetric cipher bound to a unique key. Since a block cipher is symmetric, the data can be coded and later decoded to their original form. The difference with the <tt class="code">Cipher</tt> base class is that the <tt class="code">BlockCipher</tt> class provides a <tt class="code">get-block-size</tt> method which returns the cipher block size. </p>
<p class="subsect">
Block Cipher base</p>
<p class="text">
 The <tt class="code">BlockCipher</tt> class is a base class for the block cipher engine. The class implements the <tt class="code">stream</tt> method that reads from an input stream and write into an output stream. The <tt class="code">BlockCipher</tt> class is an abstract class and cannot be instantiated by itself. The object is actually created by using a cipher algorithm class such like the <tt class="code">Aes</tt> class. </p>
<pre class="frame">
<![CDATA[trans count (cipher:stream os is)

]]></pre>
<p class="text">
 The <tt class="code">stream</tt> method returns the number of characters that have been encoded. Care should be taken that most of the stream cipher operates by block and therefore, will block until a complete block has been read from the input stream, unless the end of stream is read. The block cipher is always associated with a padding scheme. By default, the NIST 800-38A recommendation is associated with the block cipher, but can be changed with the <tt class="code">set-padding-mode</tt>. </p>
<p class="subsect">
Creating a block cipher</p>
<p class="text">
 A <tt class="code">BlockCipher</tt> object can be created with a cipher constructor. As of today, the <em>Advanced Encryption
	Standard</em> or AES is the recommended symmetric cipher. The <tt class="code">Aes</tt> class creates a new block cipher that conforms to the AES standard. </p>
<pre class="frame">
<![CDATA[const cipher (afnix:sec:Aes)

]]></pre>
<p class="text">
 A block cipher can be created with a key and eventually a reverse flag. With one argument, the block cipher key is associated with the cipher. Such key can be created as indicated in the previous section. The reverse flag is used to determine if the cipher operate in encoding or decoding mode. By default, the cipher operates in coding mode. </p>
<pre class="frame">
<![CDATA[# create a 256 bits random key
const key (afnix:sec:Key afnix:sec:KSYM 256)
# create an aes block cipher
const aes (afnix:sec:Aes key)

]]></pre>
<p class="subsect">
Block cipher information</p>
<p class="text">
 The <tt class="code">BlockCipher</tt> class is derived from the <tt class="code">Cipher</tt> class and contains several methods that provide information about the cipher. This include the cipher block size with the <tt class="code">get-block-size</tt> method. </p>
<pre class="frame">
<![CDATA[println (aes:get-block-size)

]]></pre>
<div class="section">
Input cipher</div>
<p class="text">
 In the presence of a <tt class="code">Cipher</tt> object, it is difficult to read an input stream and encode the character of a block basis. Furthermore, the existence of various method for block padding makes the coding operation even more difficult. For this reason, the <tt class="code">InputCipher</tt> class provides the necessary method to code or decode an input stream in various mode of operations. </p>
<p class="subsect">
Input cipher mode</p>
<p class="text">
 The <tt class="code">InputCipher</tt> class is an input stream that binds an input stream with a cipher. The class acts like an input stream, read the character from the bounded input stream and encode or decode them from the bended cipher. The <tt class="code">InputCipher</tt> defines several modes of operations. In <em>electronic codebook mode</em> or ECB, the character are encoded in a block basis. In <em>cipher block chaining</em> mode, the block are encoded by doing an XOR operation with the previous block. Other modes are also available such like <em>cipher feedback mode</em> and <em>output feedback
	mode</em>. </p>
<p class="subsect">
Creating an input cipher</p>
<p class="text">
 By default an input cipher is created with a cipher object. Eventually, an input stream and/or the input mode can be specified at the object construction. </p>
<pre class="frame">
<![CDATA[# create a key
const key (afnix:sec:Key "hello world")
# create a direct cipher
const aes (afnix:sec:Aes key)
# create an input cipher
const ic (afnix:sec:InputCipher aes)

]]></pre>
<p class="text">
 In this example, the input cipher is created in ECB mode. The input stream is later associated with the <tt class="code">set-is</tt> method. </p>
<p class="subsect">
Input cipher operation</p>
<p class="text">
 The <tt class="code">InputCipher</tt> class operates with one or several input streams. The <tt class="code">set-is</tt> method sets the input stream. Read operation can be made with the help of the <tt class="code">valid-p</tt> predicate. </p>
<pre class="frame">
<![CDATA[while (ic:valid-p) (os:write (ic:read))

]]></pre>
<p class="text">
 Since the <tt class="code">InputCipher</tt> operates like an input stream, the stream can be read as long as the <tt class="code">valid-p</tt> predicate returns true. Note that the <tt class="code">InputCipher</tt> manages automatically the padding operations with the mode associated with the block cipher. </p>
<div class="section">
Asymmetric cipher</div>
<p class="text">
 A public cipher is an object that encodes an input stream with a asymmetric cipher bound to a public and secret key. In theory, there is no difference between a block cipher and a public cipher. Furthermore, the interface provided by the engine is the same for both objects. </p>
<p class="subsect">
Public cipher</p>
<p class="text">
 A public cipher is an asymmetric stream cipher which operates with an asymmetric key. The main difference between a block cipher and a public cipher is the key nature as well as the encoded block size. With an asymmetric cipher, the size of the message to encode is generally not the same as the encoded block, because a message padding operation must occurs for each message block. </p>
<pre class="frame">
<![CDATA[trans count (cipher:stream os is)

]]></pre>
<p class="text">
 The <tt class="code">stream</tt> method returns the number of characters that have been encoded. Like the block cipher, the <tt class="code">stream</tt> method encodes an input stream or a buffer object. The number of encoded bytes is returned by the method. </p>
<p class="subsect">
Creating a public cipher</p>
<p class="text">
 A <tt class="code">PublicCipher</tt> object can be created with a cipher constructor. The <em>RSA</em> asymmetric cipher is the typical example of public cipher. It is created by binding a RSA key to it. For security reasons, the key size must be large enough, typically with a size of at lease 1024 bits. </p>
<pre class="frame">
<![CDATA[const key (afnix:sec:Key afnix:sec:Key:KRSA 1024)
const rsa (afnix:sec:Rsa key)

]]></pre>
<p class="text">
 A block cipher can be created with a key and eventually a reverse flag. Additional constructors are available to support various padding mode. Such padding mode depends on the cipher type. For example, the RSA cipher supports the ISO 18033-2 padding mode with a KDF1 or KDF2 object. Such constructor requires a hasher object as well. </p>
<pre class="frame">
<![CDATA[# create a 1024 bits rsa key
const key (afnix:sec:Key afnix:sec:KRSA 1024)
# create a SHA-1 hasher
const ash (afnix:sec:Sha1)
# create a rsa public cipher
const rsa (afnix:sec:Rsa key ash "Demo")
# set the padding mode
rsa:set-padding-mode afnix:sec:Rsa:PAD-OAEP-K1

]]></pre>
<p class="subsect">
Public cipher padding mode</p>
<p class="text">
 Like any cipher, a padding mode can be associated with the cipher. The <tt class="code">set-padding-mode</tt> method can be used to set or change the padding mode. Depending on the padding mode type, additional objects might be needed at construction. </p>
<table class="text">
<tr class="text">
<th class="text">
Cipher</th>
<th class="text">
Padding mode</th>
<th class="text">
Default</th>
</tr>
<tr class="text">
<td class="text">
RSA</td>
<td class="text">
PKCS 1.5, PKCS 2.1, ISO/IEC 18033-2</td>
<td class="text">
PKCS 1.5</td>
</tr>
</table>
<p/>
<p class="text">
 The default padding mode depends on the cipher type. For RSA, the default padding mode is set to PKCS 1.5 for compatibility reason. </p>
<div class="section">
Signature objects</div>
<p class="text">
 A digital signature is a unique representation, supposedly non forgeable, designed to authenticate a document, in whatever form it is represented. For example, a signature is used to sign a certificate which is used during the process of establish a secured connection over the Internet. A signature can also be used to sign a <em>courrier</em> or keys as it is in the Openssh protocol. Digital signatures come into several flavors eventually associated with the signed document. Sometimes, the signature acts as a container and permits to retrieve the document itself. Whatever the method, the principle remains the same. As of today technology, there are two standards used to sign document as indicated below. </p>
<table class="text">
<tr class="text">
<th class="text">
Standard</th>
<th class="text">
Name</th>
</tr>
<tr class="text">
<td class="text">
DSS</td>
<td class="text">
Digital Signature Standard</td>
</tr>
<tr class="text">
<td class="text">
RSA</td>
<td class="text">
RSA based signature</td>
</tr>
</table>
<p/>
<p class="subsect">
Signer and signature objects</p>
<p class="text">
 The process of generating a signature is done with the help of a <tt class="code">Signer</tt> object. A signer object is a generic object, similar in functionality to the hasher object. The result produced by a signer object is a <tt class="code">Signature</tt> object which holds the generated signature. </p>
<p class="subsect">
Signature key</p>
<p class="text">
 The process of generating a signature often requires the use of a key. Such key can be generated with the help of the <tt class="code">Key</tt> object. The nature of the key will depend on the target signature. The following table is a resume of the supported keys. </p>
<table class="text">
<tr class="text">
<th class="text">
Standard</th>
<th class="text">
Key</th>
<th class="text">
Signer</th>
</tr>
<tr class="text">
<td class="text">
DSS</td>
<td class="text">
KDSA</td>
<td class="text">
Dsa</td>
</tr>
</table>
<p/>
<p class="text">
 In the case of DSS, a key can be generated automatically, although this process is time consuming. The default key size is 1024 bits. </p>
<pre class="frame">
<![CDATA[const key (afnix:sec:Key afnix:sec:Key:KDSA)
assert 1024 (key:get-bits)

]]></pre>
<p class="subsect">
Creating a signer</p>
<p class="text">
 A <tt class="code">Signer</tt> object is created with a particular signature object such like DSA. The <tt class="code">Dsa</tt> object is a signer object that implements the <em>Digital Signature
	Algorithm</em> as specified by the <em>Digital Signature
	Standard (DSS)</em> in <em>FIPS-PUB 186-3</em>. </p>
<pre class="frame">
<![CDATA[# create a dsa signer
const dsa (afnix:sec:Dsa key)
assert true (afnix:sec:dsa-p dsa)

]]></pre>
<p class="subsect">
Creating a signature</p>
<p class="text">
 A signature is created with the help of the <tt class="code">compute</tt> method. The <tt class="code">Signature</tt> object is similar to the <tt class="code">Hasher</tt> and operates with string or streams. </p>
<pre class="frame">
<![CDATA[# create a signature object
const sgn   (dsa:compute "afnix")
assert true (afnix:sec:signature-p sgn)

]]></pre>
<p class="text">
 Once the signature is created, each data can be accessed directly with the associated component mapper. In the case of DSS, there are two components as show below. </p>
<pre class="frame">
<![CDATA[# get the DSS S component
sgn:get-relatif-component 
afnix:sec:Signature:DSA-S-COMPONENT
# get the DSS R component
sgn:get-relatif-component 
afnix:sec:Signature:DSA-R-COMPONENT

]]></pre>
<hr/>
<div class="appendix">
Standard Security Reference</div>
<hr/>
<p/>
<div class="elem">
Hasher</div>
<p class="text">
 The <tt class="code">Hasher</tt> class is a base class that is used to build a message hash. The hash result is stored in an array of bytes and can be retrieved byte by byte or as a formatted printable string. This class does not have a constructor. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>hasher-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Nameable
</i>
</pre>
<p class="elem">
Methods</p>
<div class="frame">
<i>reset</i><i> (&rarr; none)</i><i> (none)</i><hr/>
<p class="text">

	  The reset method reset the hasher object with its
	  associated internal states.
	</p>
</div>
<p/>
<div class="frame">
<i>hash-p</i><i> (&rarr; Boolean)</i><i> (String)</i><hr/>
<p class="text">

	  The hash-p predicate returns true if the string argument
	  is potentially a hash value. It is not possible, with our current
	  technology, to reverse a hash value to one or several
	  representations, nor it is possible to assert that such value exists.
	</p>
</div>
<p/>
<div class="frame">
<i>get-byte</i><i> (&rarr; Byte)</i><i> (Integer)</i><hr/>
<p class="text">

	  The get-byte method returns the hash byte value by
	  index. The argument is the byte index which must be in the range
	  of the hash result length.
	</p>
</div>
<p/>
<div class="frame">
<i>format</i><i> (&rarr; String)</i><i> (none)</i><hr/>
<p class="text">

	  The format method return a string representation of
	  the hash value.
	</p>
</div>
<p/>
<div class="frame">
<i>compute</i><i> (&rarr; String)</i><i> (Literal|Buffer|InputStream)</i><hr/>
<p class="text">

	  The compute method computes the hash value from a
	  string, a buffer or an input stream. The method returns a string
	  representation of the result hash value. When the argument is a 
	  buffer object or an input stream, the characters are consumed from the
	  object.
	</p>
</div>
<p/>
<div class="frame">
<i>derive</i><i> (&rarr; String)</i><i> (String)</i><hr/>
<p class="text">

	  The derive method computes the hash value from an
	  octet string which is converted before the hash computation. The
	  method returns a string representation of the result hash value.
	</p>
</div>
<p/>
<div class="frame">
<i>get-hash-length</i><i> (&rarr; Integer)</i><i> (none)</i><hr/>
<p class="text">

	  The get-hash-length method returns the hasher
	  length in bytes.
	</p>
</div>
<p/>
<div class="frame">
<i>get-result-length</i><i> (&rarr; Integer)</i><i> (none)</i><hr/>
<p class="text">

	  The get-result-length method returns the hasher
	  result length in bytes. The result length is less or equal to
	  the hasher length and is set at construction.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Md2</div>
<p class="text">
 The <tt class="code">Md2</tt> class is a hashing class that implements the MD-2 algorithm. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>md2-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Hasher
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Md2</i><i> (none)</i><hr/>
<p class="text">

	  The Md2 constructor creates a default hashing
	  object that implements the MD-2 algorithm.
	</p>
</div>
<p/>
<div class="frame">
<i>Md2</i><i> (Integer)</i><hr/>
<p class="text">

	  The Md2 constructor creates a MD-2 hashing
	  object with a result length. The argument is the hasher result
	  length that must be less or equal to the hasher length.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Md4</div>
<p class="text">
 The <tt class="code">Md4</tt> class is a hashing class that implements the MD-4 algorithm. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>md4-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Hasher
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Md4</i><i> (none)</i><hr/>
<p class="text">

	  The Md4 constructor creates a default hashing
	  object that implements the MD-4 algorithm.
	</p>
</div>
<p/>
<div class="frame">
<i>Md4</i><i> (Integer)</i><hr/>
<p class="text">

	  The Md4 constructor creates a MD-4 hashing
	  object with a result length. The argument is the hasher result
	  length that must be less or equal to the hasher length.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Md5</div>
<p class="text">
 The <tt class="code">Md5</tt> class is a hashing class that implements the MD-5 algorithm. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>md5-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Hasher
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Md5</i><i> (none)</i><hr/>
<p class="text">

	  The Md5 constructor creates a default hashing
	  object that implements the MD-5 algorithm.
	</p>
</div>
<p/>
<div class="frame">
<i>Md5</i><i> (Integer)</i><hr/>
<p class="text">

	  The Md5 constructor creates a MD-5 hashing
	  object with a result length. The argument is the hasher result
	  length that must be less or equal to the hasher length.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Sha1</div>
<p class="text">
 The <tt class="code">Sha1</tt> class is a hashing class that implements the SHA-1 algorithm. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>sha1-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Hasher
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Sha1</i><i> (none)</i><hr/>
<p class="text">

	  The Sha1 constructor creates a default hashing
	  object that implements the SHA-1 algorithm.
	</p>
</div>
<p/>
<div class="frame">
<i>Sha1</i><i> (Integer)</i><hr/>
<p class="text">

	  The Sha1 constructor creates a SHA-1 hashing
	  object with a result length. The argument is the hasher result
	  length that must be less or equal to the hasher length.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Sha224</div>
<p class="text">
 The <tt class="code">Sha224</tt> class is a hashing class that implements the SHA-224 algorithm. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>sha224-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Hasher
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Sha224</i><i> (none)</i><hr/>
<p class="text">

	  The Sha224 constructor creates a default hashing
	  object that implements the SHA-224 algorithm.
	</p>
</div>
<p/>
<div class="frame">
<i>Sha224</i><i> (Integer)</i><hr/>
<p class="text">

	  The Sha224 constructor creates a SHA-224 hashing
	  object with a result length. The argument is the hasher result
	  length that must be less or equal to the hasher length.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Sha256</div>
<p class="text">
 The <tt class="code">Sha256</tt> class is a hashing class that implements the SHA-256 algorithm. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>sha256-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Hasher
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Sha256</i><i> (none)</i><hr/>
<p class="text">

	  The Sha256 constructor creates a default hashing
	  object that implements the SHA-256 algorithm.
	</p>
</div>
<p/>
<div class="frame">
<i>Sha256</i><i> (Integer)</i><hr/>
<p class="text">

	  The Sha256 constructor creates a SHA-256 hashing
	  object with a result length. The argument is the hasher result
	  length that must be less or equal to the hasher length.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Sha384</div>
<p class="text">
 The <tt class="code">Sha384</tt> class is a hashing class that implements the SHA-384 algorithm. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>sha384-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Hasher
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Sha384</i><i> (none)</i><hr/>
<p class="text">

	  The Sha384 constructor creates a default hashing
	  object that implements the SHA-384 algorithm.
	</p>
</div>
<p/>
<div class="frame">
<i>Sha384</i><i> (Integer)</i><hr/>
<p class="text">

	  The Sha384 constructor creates a SHA-384 hashing
	  object with a result length. The argument is the hasher result
	  length that must be less or equal to the hasher length.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Sha512</div>
<p class="text">
 The <tt class="code">Sha512</tt> class is a hashing class that implements the SHA-512 algorithm. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>sha512-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Hasher
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Sha512</i><i> (none)</i><hr/>
<p class="text">

	  The Sha512 constructor creates a default hashing
	  object that implements the SHA-512 algorithm.
	</p>
</div>
<p/>
<div class="frame">
<i>Sha512</i><i> (Integer)</i><hr/>
<p class="text">

	  The Sha512 constructor creates a SHA-512 hashing
	  object with a result length. The argument is the hasher result
	  length that must be less or equal to the hasher length.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Key</div>
<p class="text">
 The <tt class="code">Key</tt> class is an original class used to store a particular key or to generate one. A key is designed to operate with a variety of cipher that can be either symmetric or asymmetric. In the symmetric case, the key is generally an array of bytes. Asymmetric key are generally stored in the form of number list that can be computed or loaded by value. By default, a random 128 bit symmetric key is created. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>key-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Object
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Key</i><i> (none)</i><hr/>
<p class="text">

	  The Key constructor creates a default cipher key.
	  The key is generated with random bytes and is 128 bits long.
	</p>
</div>
<p/>
<div class="frame">
<i>Key</i><i> (String)</i><hr/>
<p class="text">

	  The Key constructor creates a symmetric key from an
	  octet string. The octet string argument determines the size of
	  the key. The octet string argument is compatible with the string
	  obtained from the format method.
	</p>
</div>
<p/>
<div class="frame">
<i>Key</i><i> (Item)</i><hr/>
<p class="text">

	  The Key constructor creates a key by type. If the
	  key type is KSYM, a symmetric 128 bytes random key is
	  generated. If the key type is KRSA, a 1024 bits RSA
	  random key is generated.
	</p>
</div>
<p/>
<div class="frame">
<i>Key</i><i> (Item Integer|String|Vector)</i><hr/>
<p class="text">

	  The Key constructor creates a key by type. The
	  first argument is the key type to generate. The second argument
	  is either the key size, the key octet string or the key byte values.
	  In the first form, an integer argument specifies the key size in bytes
	  or bits depending on the key nature. In the second form, a string is 
	  used as octet string to represent the key. In the third form, a vector
	  of byte values can be used to load the key.
	</p>
</div>
<p/>
<p class="elem">
Constants</p>
<div class="frame">
<i>KSYM</i><hr/>
<p class="text">

	  The KSYM constant indicates that the key is a 
	  symmetric key.
	</p>
</div>
<p/>
<div class="frame">
<i>KRSA</i><hr/>
<p class="text">

	  The KRSA constant indicates that the key is a 
	  asymmetric RSA key.
	</p>
</div>
<p/>
<div class="frame">
<i>KMAC</i><hr/>
<p class="text">

	  The KMAC constant indicates that the key is a 
	  message authentication (MAC) key.
	</p>
</div>
<p/>
<div class="frame">
<i>RSA-MODULUS</i><hr/>
<p class="text">

	  The RSA-MODULUS constant corresponds to the RSA
	  modulus value.
	</p>
</div>
<p/>
<div class="frame">
<i>RSA-PUBLIC-EXPONENT</i><hr/>
<p class="text">

	  The RSA-PUBLIC-EXPONENT constant corresponds to the RSA
	  public exponent value which is generally 65537.
	</p>
</div>
<p/>
<div class="frame">
<i>RSA-SECRET-EXPONENT</i><hr/>
<p class="text">

	  The RSA-SECRET-EXPONENT constant corresponds to the RSA
	  secret exponent value.
	</p>
</div>
<p/>
<p class="elem">
Methods</p>
<div class="frame">
<i>get-byte</i><i> (&rarr; Byte)</i><i> (Integer)</i><hr/>
<p class="text">

	  The get-byte method returns a key byte value by index.
	  The index must be in the key range or an exception is
	  raised. This method is primarily used with symmetric key.
	</p>
</div>
<p/>
<div class="frame">
<i>get-type</i><i> (&rarr; Item)</i><i> (none)</i><hr/>
<p class="text">

	  The get-type method returns the key type in the
	  form of an item object.
	</p>
</div>
<p/>
<div class="frame">
<i>get-bits</i><i> (&rarr; Integer)</i><i> (none)</i><hr/>
<p class="text">

	  The get-bits method returns the key size in bits.
	</p>
</div>
<p/>
<div class="frame">
<i>get-size</i><i> (&rarr; Integer)</i><i> (none)</i><hr/>
<p class="text">

	  The get-size method returns the key size in bytes.
	</p>
</div>
<p/>
<div class="frame">
<i>format</i><i> (&rarr; String)</i><i> (none|Item)</i><hr/>
<p class="text">

	  The format method returns a string representation
	  of the key. In the first form, without argument, the key is
	  returned as an octet string if possible. In the second form, the
	  key value is returned as an octet string based on the key
	  element to access.
	</p>
</div>
<p/>
<div class="frame">
<i>get-relatif-key</i><i> (&rarr; Relatif)</i><i> (Item)</i><hr/>
<p class="text">

	  The get-relatif-key method returns a relatif
	  representation of a key element. This method is well suited for
	  asymmetric key. The key value is returned as a relatif based on
	  the key element to access.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Kdf</div>
<p class="text">
 The <tt class="code">Kdf</tt> class is an abstract class used to model key derivation function. The class provides only a byte buffer which can be accessed by index. In the key derivation functions land, there are numerous standards, such like PKCS 2.1, IEEE P1363-2000, ISO/IEC 18033-2. All of these standards have sometimes conflicting definitions. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>kdf-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Nameable
</i>
</pre>
<p class="elem">
Methods</p>
<div class="frame">
<i>reset</i><i> (&rarr; none)</i><i> (none)</i><hr/>
<p class="text">

	  The reset method reset the internal state of the kdf
	  object.
	</p>
</div>
<p/>
<div class="frame">
<i>get-size</i><i> (&rarr; Integer)</i><i> (none)</i><hr/>
<p class="text">

	  The get-size method returns the kdf size in bytes.
	</p>
</div>
<p/>
<div class="frame">
<i>get-byte</i><i> (&rarr; Byte)</i><i> (Integer)</i><hr/>
<p class="text">

	  The get-byte method returns a kdf byte value by index.
	  The index must be in the key range or an exception is raised.
	</p>
</div>
<p/>
<div class="frame">
<i>format</i><i> (&rarr; String)</i><i> (none)</i><hr/>
<p class="text">

	  The format method returns a string representation
	  of the derived key.
	</p>
</div>
<p/>
<div class="frame">
<i>derive</i><i> (&rarr; String)</i><i> (String)</i><hr/>
<p class="text">

	  The derive method returns a string representation
	  of a derived key computed from the octet string argument.
	</p>
</div>
<p/>
<div class="frame">
<i>compute</i><i> (&rarr; String)</i><i> (String)</i><hr/>
<p class="text">

	  The compute method returns a string representation
	  of a derived key computed from the string argument.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Hkdf</div>
<p class="text">
 The <tt class="code">Hkdf</tt> class is an abstract class used to model key derivation function based on hash function. The class maintains a hasher object that is used to derive the key from an octet string. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>hashed-kdf-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Kdf
</i>
</pre>
<p class="elem">
Methods</p>
<div class="frame">
<i>get-hasher</i><i> (&rarr; none)</i><i> (none)</i><hr/>
<p class="text">

	  The get-hasher method returns the hasher object
	  associated with the key derivation function object.
	  object.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Kdf1</div>
<p class="text">
 The <tt class="code">Kdf1</tt> class is a hashed key derivation function class that implements the KDF1 specification as defined by ISO/IEC 18033-2. The class is strictly equivalent to the mask generation function (MGF1) defined in PKCS 2.1. On the other hand, this implementation does not conform to the KDF1 specification of IEEE 1363-2000 which is somehow rather bizarre. The class operates in theory with any type of hasher object as long as the octet string is not too long. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>kdf1-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Hkdf
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Kdf1</i><i> (Hasher Integer)</i><hr/>
<p class="text">

	  The Kdf1 constructor creates a KDF1 key derivation
	  function object. The first argument is the hasher object to bind
	  and the second argument is the kdf size.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Kdf2</div>
<p class="text">
 The <tt class="code">Kdf2</tt> class is a hashed key derivation function class that implements the KDF2 specification as defined by ISO/IEC 18033-2. The class is strictly equivalent to the key function derivation (KDF1) except that the internal counter runs from 1 to k instead of 0 to k-1. The class operates in theory with any type of hasher object as long as the octet string is not too long. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>kdf2-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Hkdf
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Kdf2</i><i> (Hasher Integer)</i><hr/>
<p class="text">

	  The Kdf2 constructor creates a KDF2 key derivation
	  function object. The first argument is the hasher object to bind
	  and the second argument is the kdf size.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Cipher</div>
<p class="text">
 The <tt class="code">Cipher</tt> class is a base class that is used to implement a cipher. A cipher is used to encrypt or decrypt a message. There are basically two types of ciphers, namely symmetric cipher and asymmetric cipher. For the base class operation, only the cipher name and key is needed. A reverse flag controls whether or not an encryption operation must be reversed. A reset method can also be used to reset the internal cipher state. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>cipher-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Nameable
</i>
</pre>
<p class="elem">
Methods</p>
<div class="frame">
<i>reset</i><i> (&rarr; none)</i><i> (none)</i><hr/>
<p class="text">

	  The reset method reset the cipher internal state.
	</p>
</div>
<p/>
<div class="frame">
<i>stream</i><i> (&rarr; Integer)</i><i> (OutputStream InputStream)</i><hr/>
<p class="text">

	  The stream method process an input stream and write
	  into an output stream. The method returns the number of
	  character processed. The first argument is the output stream
	  used to write the coded characters. The second argument is the
	  input stream used to read the characters.
	</p>
</div>
<p/>
<div class="frame">
<i>set-key</i><i> (&rarr; none)</i><i> (Key)</i><hr/>
<p class="text">

	  The set-key method sets the cipher key. The first
	  argument is the key to set.
	</p>
</div>
<p/>
<div class="frame">
<i>get-key</i><i> (&rarr; Key)</i><i> (none)</i><hr/>
<p class="text">

	  The get-key method returns the cipher key.
	</p>
</div>
<p/>
<div class="frame">
<i>set-reverse</i><i> (&rarr; none)</i><i> (Boolean)</i><hr/>
<p class="text">

	  The set-reverse method sets the cipher reverse
	  flag. The first argument is the flag to set. If the flag is true,
	  the cipher operates in reverse mode. If the flag is false, the
	  cipher operates in direct mode.
	</p>
</div>
<p/>
<div class="frame">
<i>get-reverse</i><i> (&rarr; Boolean)</i><i> (none)</i><hr/>
<p class="text">

	  The get-reverse method returns the cipher reverse
	  flag. If the flag is true, the cipher operates in reverse
	  mode. If the flag is false, the cipher operates in direct mode.
	</p>
</div>
<p/>
<p/>
<div class="elem">
BlockCipher</div>
<p class="text">
 The <tt class="code">BlockCipher</tt> class is an abstract class that is used to implement a symmetric block cipher. By default the cipher operates in encryption mode. When the reverse flag is set, the decryption mode is activated. For a block cipher, a block size controls the cipher operations. The class also defines the constants that control the block padding with the associated methods. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>block-cipher-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Cipher
</i>
</pre>
<p class="elem">
Constants</p>
<div class="frame">
<i>PAD-NONE</i><hr/>
<p class="text">

	  The PAD-NONE constant indicates that the block should
	  not be padded.
	</p>
</div>
<p/>
<div class="frame">
<i>PAD-BIT-MODE</i><hr/>
<p class="text">

	  The PAD-BIT constant indicates that the block
	  should be padded in bit mode.
	</p>
</div>
<p/>
<div class="frame">
<i>PAD-ANSI-X923</i><hr/>
<p class="text">

	  The PAD-ANSI-X923 constant indicates that the block
	  should be padded according to ANSI X 923 standard.
	</p>
</div>
<p/>
<div class="frame">
<i>PAD-NIST-800</i><hr/>
<p class="text">

	  The PAD-NIST-800 constant indicates that the block
	  should be padded according to NIST 800-38A recommendations. This
	  is the default mode.      
	</p>
</div>
<p/>
<p class="elem">
Methods</p>
<div class="frame">
<i>get-block-size</i><i> (&rarr; Integer)</i><i> (none)</i><hr/>
<p class="text">

	  The get-block-size method returns the cipher block size.
	</p>
</div>
<p/>
<div class="frame">
<i>set-padding-mode</i><i> (&rarr; none)</i><i> (Item)</i><hr/>
<p class="text">

	  The set-padding-mode method sets the cipher padding
	  mode.
	</p>
</div>
<p/>
<div class="frame">
<i>get-padding-mode</i><i> (&rarr; Item)</i><i> (none)</i><hr/>
<p class="text">

	  The get-padding-mode method returns the cipher
	  padding mode.
	</p>
</div>
<p/>
<p/>
<div class="elem">
InputCipher</div>
<p class="text">
 The <tt class="code">InputCipher</tt> class is an stream interface that can stream out an input stream from a cipher. In other word, an input stream is read and block are encoded as long as the input stream read characters. If the cipher is nil, the input cipher simply read the input stream and is therefore transparent. The class acts like an input stream, read the character from the bounded input stream and encode or decode them from the bounded cipher. The <tt class="code">InputCipher</tt> defines several modes of operations. In <em>electronic codebook mode</em> or ECB, the character are encoded in a block basis. In <em>cipher block chaining</em> mode, the block are encoded by doing an XOR operation with the previous block. Other modes such like <em>cipher feedback mode</em> and <em>output feedback mode</em> are also defined. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>input-cipher-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Input
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>InputCipher</i><i> (Cipher)</i><hr/>
<p class="text">

	  The InputCipher constructor creates an input cipher
	  with a cipher object. The first argument is the cipher to used
	  for processing.
	</p>
</div>
<p/>
<div class="frame">
<i>InputCipher</i><i> (Cipher Input)</i><hr/>
<p class="text">

	  The InputCipher constructor creates an input cipher
	  with a cipher object and an input stream. The first argument is
	  the cipher to used for processing. The second argument is the
	  input stream object used for the character reading.
	</p>
</div>
<p/>
<div class="frame">
<i>InputCipher</i><i> (Cipher InputStream Item)</i><hr/>
<p class="text">

	  The InputCipher constructor creates an input cipher
	  with a cipher object, an input stream and a mode. The first
	  argument is the cipher to used for processing. The second
	  argument is the input stream object used for the character
	  reading.  The third argument is the input cipher mode which can
	  be either ECB, CBC, CFB or OFB.
	</p>
</div>
<p/>
<p class="elem">
Constants</p>
<div class="frame">
<i>ECB</i><hr/>
<p class="text">

	  The ECB constant indicates that the input cipher is
	  to operate in electronic codebook mode. This mode is
	  the default mode.
	</p>
</div>
<p/>
<div class="frame">
<i>CBC</i><hr/>
<p class="text">

	  The CBC constant indicates that the input cipher is
	  to operate in cipher chaining block mode.
	</p>
</div>
<p/>
<div class="frame">
<i>CFB</i><hr/>
<p class="text">

	  The CFB constant indicates that the input cipher is
	  to operate in cipher feedback block mode.
	</p>
</div>
<p/>
<div class="frame">
<i>OFB</i><hr/>
<p class="text">

	  The OFB constant indicates that the input cipher is
	  to operate in output feedback block mode.
	</p>
</div>
<p/>
<p class="elem">
Methods</p>
<div class="frame">
<i>reset</i><i> (&rarr; none)</i><i> (none)</i><hr/>
<p class="text">

	  The reset method reset the input cipher object.
	</p>
</div>
<p/>
<div class="frame">
<i>get-mode</i><i> (&rarr; Item)</i><i> (none)</i><hr/>
<p class="text">

	  The get-mode method returns the input cipher
	  operating mode.
	</p>
</div>
<p/>
<div class="frame">
<i>set-iv</i><i> (&rarr; none)</i><i> (String|Buffer)</i><hr/>
<p class="text">

	  The set-iv method sets the input cipher initial
	  vector. In the first form, the initial vector is set from an
	  octet string. In the second form, the initial vector is set from
	  a buffer object.
	</p>
</div>
<p/>
<div class="frame">
<i>get-iv</i><i> (&rarr; String)</i><i> (none)</i><hr/>
<p class="text">

	  The get-iv method returns the input cipher initial
	  vector as an octet string.
	</p>
</div>
<p/>
<div class="frame">
<i>set-is</i><i> (&rarr; none)</i><i> (InputStream)</i><hr/>
<p class="text">

	  The set-is method sets the input cipher input stream.
	  This method can be used to chain multiple input streams in a
	  unique coding session.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Aes</div>
<p class="text">
 The <tt class="code">Aes</tt> class is a block cipher class that implements the <em>advanced encryption standard</em> (AES), originally known as Rijndael. This is an original implementation that conforms to the standard FIPS PUB 197. It should be noted that the AES standard, unlike Rijndael, defines a fixed block size of 16 bytes (4 words) and 3 keys sizes (128, 192, 256). </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>aes-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>BlockCipher
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Aes</i><i> (Key)</i><hr/>
<p class="text">

	  The Aes constructor creates a direct cipher with a key.
	  The first argument is the key used by the cipher.
	</p>
</div>
<p/>
<div class="frame">
<i>Aes</i><i> (Key Boolean)</i><hr/>
<p class="text">

	  The Aes constructor creates a cipher with a key and
	  a reverse flag. The first argument is the key used by the
	  cipher. The second argument is the reverse flag.
	</p>
</div>
<p/>
<p/>
<div class="elem">
PublicCipher</div>
<p class="text">
 The <tt class="code">PublicCipher</tt> class is an abstract class that is used to implement an asymmetric cipher. An asymmetric cipher or public key cipher is designed to operate with a public key and a secret key. Depending on the use model, the public key might be used to crypt the data, and the secret key to decrypt. The basic assumption around a public cipher is that the secret key cannot be derived from the public key. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>public-cipher-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Cipher
</i>
</pre>
<p class="elem">
Methods</p>
<div class="frame">
<i>get-message-size</i><i> (&rarr; Integer)</i><i> (none)</i><hr/>
<p class="text">

	  The get-message-size method returns the cipher
	  message size.
	</p>
</div>
<p/>
<div class="frame">
<i>get-crypted-size</i><i> (&rarr; Integer)</i><i> (none)</i><hr/>
<p class="text">

	  The get-crypted-size method returns the cipher
	  crypted block size.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Rsa</div>
<p class="text">
 The <tt class="code">Rsa</tt> class is a public cipher class that implements the RSA algorithm as described by PKCS 2.1, RFC 2437 and ISO 18033-2. The class implements also some padding mechanism described in PKCS 1.5, 2.1 and ISO 18033-2. The RSA algorithm is a public cryptographic cipher based on a secret and public keys. The class operates in crypting mode by default and uses the public key to do the encryption while the secret key is used in reverse (decryption) mode. By default, the PKCS 1.5 type 2 padding is used. The ISO RSA-REM1 padding with a key derivation function (KDF1) is equivalent to PKCS 2.1 padding with the mask generation function (MGF1). The ISO RSA-REM1 padding with KDF2 is not described in the PKCS 2.1. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>rsa-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>PublicCipher
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Rsa</i><i> (none)</i><hr/>
<p class="text">

	  The Rsa constructor creates a default RSA public
	  cipher by binding a 1024 bits random key.
	</p>
</div>
<p/>
<div class="frame">
<i>Rsa</i><i> (Key)</i><hr/>
<p class="text">

	  The Rsa constructor creates a RSA public cipher by
	  binding the key argument.
	</p>
</div>
<p/>
<div class="frame">
<i>Rsa</i><i> (Key Boolean)</i><hr/>
<p class="text">

	  The Rsa constructor creates a RSA public cipher by
	  binding the key argument and the reverse flag. The first
	  argument is the key to bind. The second argument is the reverse
	  flag to set.
	</p>
</div>
<p/>
<div class="frame">
<i>Rsa</i><i> (Key Hasher String)</i><hr/>
<p class="text">

	  The Rsa constructor creates a RSA public cipher by
	  binding the key argument and OAEP padding objects. The first
	  argument is the key to bind. The second argument is hasher
	  object to use with the OAEP padding mode. The third argument is
	  an optional label to be used by the KDF object.
	</p>
</div>
<p/>
<p class="elem">
Constants</p>
<div class="frame">
<i>PAD-PKCS-11</i><hr/>
<p class="text">

	  The PAD-PKCS-11 constant indicates that the PKCS
	  1.5 type 1 block should be used to pad the message.
	</p>
</div>
<p/>
<div class="frame">
<i>PAD-PKCS-12</i><hr/>
<p class="text">

	  The PAD-PKCS-12 constant indicates that the PKCS
	  1.5 type 3 block should be used to pad the message.
	</p>
</div>
<p/>
<div class="frame">
<i>PAD-OAEP-K1</i><hr/>
<p class="text">

	  The PAD-OAEP-K1 constant indicates that the ISO/IEC
	  18033-2 OAEP with KDF1 should be used to pad the message.
	</p>
</div>
<p/>
<div class="frame">
<i>PAD-OAEP-K2</i><hr/>
<p class="text">

	  The PAD-OAEP-K2 constant indicates that the ISO/IEC
	  18033-2 OAEP with KDF2 should be used to pad the message.
	</p>
</div>
<p/>
<p class="elem">
Methods</p>
<div class="frame">
<i>get-hasher</i><i> (&rarr; Hasher)</i><i> (none)</i><hr/>
<p class="text">

	  The get-hasher method returns the hasher object
	  used by the OAEP padding mode.
	</p>
</div>
<p/>
<div class="frame">
<i>set-hasher</i><i> (&rarr; none)</i><i> (Hasher)</i><hr/>
<p class="text">

	  The set-hasher method sets the hasher object used by
	  the OAEP padding mode.
	</p>
</div>
<p/>
<div class="frame">
<i>get-padding-mode</i><i> (&rarr; Item)</i><i> (none)</i><hr/>
<p class="text">

	  The get-padding-mode method returns the cipher
	  padding mode.
	</p>
</div>
<p/>
<div class="frame">
<i>set-padding-mode</i><i> (&rarr; none)</i><i> (Item)</i><hr/>
<p class="text">

	  The set-padding-mode method sets the cipher padding
	  mode.
	</p>
</div>
<p/>
<div class="frame">
<i>get-padding-label</i><i> (&rarr; String)</i><i> (none)</i><hr/>
<p class="text">

	  The get-padding-label method returns the cipher
	  padding label.
	</p>
</div>
<p/>
<div class="frame">
<i>set-padding-label</i><i> (&rarr; none)</i><i> (String)</i><hr/>
<p class="text">

	  The set-padding-mode method sets the cipher padding
	  label.
	</p>
</div>
<p/>
<div class="frame">
<i>get-padding-seed</i><i> (&rarr; String)</i><i> (none)</i><hr/>
<p class="text">

	  The get-padding-seed method returns the cipher
	  padding seed.
	</p>
</div>
<p/>
<div class="frame">
<i>set-padding-seed</i><i> (&rarr; none)</i><i> (String)</i><hr/>
<p class="text">

	  The set-padding-seed method sets the cipher padding
	  seed.
	</p>
</div>
<p/>
<div class="frame">
<i>pkcs-primitive</i><i> (&rarr; Relatif)</i><i> (Integer|Relatif)</i><hr/>
<p class="text">

	  The pkcs-primitive method compute a relatif value
	  from a relatif argument by either crypting or decrypting the
	  argument.
	  seed.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Signer</div>
<p class="text">
 The <tt class="code">Signer</tt> class is a base class that is used to build a message signature. The signature result is stored in a special signature object which is algorithm dependent. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>signer-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Nameable
</i>
</pre>
<p class="elem">
Methods</p>
<div class="frame">
<i>reset</i><i> (&rarr; none)</i><i> (none)</i><hr/>
<p class="text">

	  The reset method reset the signer object with its
	  associated internal states.
	</p>
</div>
<p/>
<div class="frame">
<i>compute</i><i> (&rarr; Signature)</i><i> (Literal|Buffer|InputStream)</i><hr/>
<p class="text">

	  The compute method computes the signature from a
	  string, a buffer or an input stream. The method returns a signature
	  object. When the argument is a buffer object or an input stream,
	  the characters are consumed from the object.
	</p>
</div>
<p/>
<div class="frame">
<i>derive</i><i> (&rarr; Signature)</i><i> (String)</i><hr/>
<p class="text">

	  The derive method computes the signature from an
	  octet string which is converted before the signature
	  computation. The method returns a signature object.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Signature</div>
<p class="text">
 The <tt class="code">Signature</tt> class is a container class designed to store a message signature. The signature object is produced by a signing process, implemented in the form of a digital signature algorithm such like RSA or DSA. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>signature-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Object
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Signature</i><i> (none)</i><hr/>
<p class="text">

	  The Signature constructor creates an empty signature.
	</p>
</div>
<p/>
<p class="elem">
Constants</p>
<div class="frame">
<i>NIL</i><hr/>
<p class="text">

	  The NIL constant indicates that the signature is a
	  null signature.
	</p>
</div>
<p/>
<div class="frame">
<i>DSA</i><hr/>
<p class="text">

	  The DSA constant indicates that the signature is
	  conforming to DSS.
	</p>
</div>
<p/>
<div class="frame">
<i>DSA-S-COMPONENT</i><hr/>
<p class="text">

	  The DSA-S-COMPONENT constant corresponds to the DSA
	  S component value.
	</p>
</div>
<p/>
<div class="frame">
<i>DSA-R-COMPONENT</i><hr/>
<p class="text">

	  The DSA-R-COMPONENT constant corresponds to the DSA
	  R component value.
	</p>
</div>
<p/>
<p class="elem">
Methods</p>
<div class="frame">
<i>reset</i><i> (&rarr; none)</i><i> (none)</i><hr/>
<p class="text">

	  The reset method reset the signature object to a null
	  signature.
	</p>
</div>
<p/>
<div class="frame">
<i>format</i><i> (&rarr; String)</i><i> (Item)</i><hr/>
<p class="text">

	  The format method returns a string representation
	  of the signature component. The signature component is returned
	  as an octet string based on the signature component to access.
	</p>
</div>
<p/>
<div class="frame">
<i>get-relatif-component</i><i> (&rarr; Relatif)</i><i> (Item)</i><hr/>
<p class="text">

	  The get-relatif-component method returns a relatif
	  representation of a signature component.
	</p>
</div>
<p/>
<p/>
<div class="elem">
Dsa</div>
<p class="text">
 The <tt class="code">Dsa</tt> class is an original implementation of the Digital Signature Standard (DSS) as published in FIPS PUB 186-3. This class implements the Digital Signature Algorithm (DSA) with an approved key length of 1024, 2048 and 3072 bits with a 160, 224 and 256 bits hash function which is part of the SHA family. </p>
<p class="elem">
Predicate</p>
<pre class="frame">
<i>dsa-p

</i></pre>
<p class="elem">
Inheritance</p>
<pre class="frame">
<i>Signer
</i>
</pre>
<p class="elem">
Constructors</p>
<div class="frame">
<i>Dsa</i><i> (none)</i><hr/>
<p class="text">

	  The Dsa constructor creates a signer object with a
	  default DSA key.
	</p>
</div>
<p/>
<div class="frame">
<i>Dsa</i><i> (Key)</i><hr/>
<p class="text">

	  The Dsa constructor creates a signer object with a
	  DSA key as its argument.
	</p>
</div>
<p/>
<div class="frame">
<i>Dsa</i><i> (Key Relatif)</i><hr/>
<p class="text">

	  The Dsa constructor creates a signer object with a
	  DSA key as its first argument and a fixed k argument as
	  specified by DSS.
	</p>
</div>
<p/>
</body>
</html>
