<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ActiViz .NET: Kitware.VTK.vtkPolynomialSolversUnivariate Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ActiViz .NET
   &#160;<span id="projectnumber">5.8.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_kitware.html">Kitware</a>      </li>
      <li class="navelem"><a class="el" href="namespace_kitware_1_1_v_t_k.html">VTK</a>      </li>
      <li class="navelem"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html">vtkPolynomialSolversUnivariate</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Kitware.VTK.vtkPolynomialSolversUnivariate Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Kitware::VTK::vtkPolynomialSolversUnivariate" --><!-- doxytag: inherits="Kitware::VTK::vtkObject" -->
<p><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html" title="vtkPolynomialSolversUnivariate - polynomial solvers">vtkPolynomialSolversUnivariate</a> - polynomial solvers  
 <a href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Kitware.VTK.vtkPolynomialSolversUnivariate:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate__inherit__graph.svg" width="310" height="272"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Kitware.VTK.vtkPolynomialSolversUnivariate:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate__coll__graph.svg" width="598" height="787"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a4048930d714412fb77d5be402e49d75f">vtkPolynomialSolversUnivariate</a> (IntPtr rawCppThis, bool callDisposalMethod, bool strong)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically generated constructor - called from generated code. DO NOT call directly.  <a href="#a4048930d714412fb77d5be402e49d75f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a57cfcd2540e56eefc11231ff77f10f81">vtkPolynomialSolversUnivariate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Undocumented Block.  <a href="#a57cfcd2540e56eefc11231ff77f10f81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#af9561d280b008c7b3f2c30964add4e9c">IsA</a> (string type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Undocumented Block.  <a href="#af9561d280b008c7b3f2c30964add4e9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">new <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html">vtkPolynomialSolversUnivariate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a8a696e7db453a4cca94035445fe90a62">NewInstance</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Undocumented Block.  <a href="#a8a696e7db453a4cca94035445fe90a62"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static new <br class="typebreak"/>
<a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html">vtkPolynomialSolversUnivariate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a8f20d54e05cf1cb1fa0031d70f148842">New</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Undocumented Block.  <a href="#a8f20d54e05cf1cb1fa0031d70f148842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a10f7ec38c39518a275ce34ba34801a4e">FerrariSolve</a> (IntPtr c, IntPtr r, IntPtr m, double tol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraically extracts REAL roots of the quartic polynomial with REAL coefficients X^4 + c[0] X^3 + c[1] X^2 + c[2] X + c[3] and stores them (when they exist) and their respective multiplicities in the <em>r</em> and <em>m</em> arrays, based on Ferrari's method. Some numerical noise can be filtered by the use of a tolerance <em>tol</em> instead of equality with 0 (one can use, e.g., VTK_DBL_EPSILON). Returns the number of roots. Warning: it is the user's responsibility to pass a non-negative <em>tol</em>.  <a href="#a10f7ec38c39518a275ce34ba34801a4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#af202c14e902cd9d8da8d6290123f904c">FilterRoots</a> (IntPtr P, int d, IntPtr upperBnds, int rootcount, double diameter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This uses the derivative sequence to filter possible roots of a polynomial. First it sorts the roots and removes any duplicates. If the number of sign changes of the derivative sequence at a root at upperBnds[i] == that at upperBnds[i] - diameter then the i^th value is removed from upperBnds. It returns the new number of roots.  <a href="#af202c14e902cd9d8da8d6290123f904c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a9226c40f9708fc6ae7de8400340d11dd">GetDivisionTolerance</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/get the tolerance used when performing polynomial Euclidean division to find polynomial roots. This tolerance is used to decide whether the coefficient(s) of a polynomial remainder are close enough to zero to be neglected.  <a href="#a9226c40f9708fc6ae7de8400340d11dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a1e8c1adc4e83cf9c05cc12f56d42c7f6">HabichtBisectionSolve</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P[0] X^d + ... + P[d-1] X + P[d] \]" src="form_74.png"/>
</p>
<p> in ]<em>a</em>[0] ; <em>a</em>[1]] using the Habicht sequence (polynomial coefficients are REAL) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.).  <a href="#a1e8c1adc4e83cf9c05cc12f56d42c7f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a12751b02a9e9bdb12c305b0819e821f9">HabichtBisectionSolve</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P[0] X^d + ... + P[d-1] X + P[d] \]" src="form_74.png"/>
</p>
<p> in ]<em>a</em>[0] ; <em>a</em>[1]] using the Habicht sequence (polynomial coefficients are REAL) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.).  <a href="#a12751b02a9e9bdb12c305b0819e821f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a566c7422feeb13d069d20d499e29791a">HabichtBisectionSolve</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType, bool divideGCD)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P[0] X^d + ... + P[d-1] X + P[d] \]" src="form_74.png"/>
</p>
<p> in ]<em>a</em>[0] ; <em>a</em>[1]] using the Habicht sequence (polynomial coefficients are REAL) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.).  <a href="#a566c7422feeb13d069d20d499e29791a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static new int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a4032b308fdc1516d73790a1f480d36c8">IsTypeOf</a> (string type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Undocumented Block.  <a href="#a4032b308fdc1516d73790a1f480d36c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a57bb1e5c577ca41e04f34a6f978512ff">LinBairstowSolve</a> (IntPtr c, int d, IntPtr r, ref double tolerance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeks all REAL roots of the <em>d</em> -th degree polynomial c[0] X^d + ... + c[d-1] X + c[d] = 0 equation Lin-Bairstow's method ( polynomial coefficients are REAL ) and stores the <em>nr</em> roots found ( multiple roots are multiply stored ) in <em>r</em>. <em>tolerance</em> is the user-defined solver tolerance; this variable may be relaxed by the iterative solver if needed. Returns <em>nr</em>. Warning: it is the user's responsibility to make sure the <em>r</em> array is large enough to contain the maximal number of expected roots.  <a href="#a57bb1e5c577ca41e04f34a6f978512ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static new <br class="typebreak"/>
<a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html">vtkPolynomialSolversUnivariate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a06251d4acb26944c05d22893d1596d73">SafeDownCast</a> (<a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_object_base.html">vtkObjectBase</a> o)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Undocumented Block.  <a href="#a06251d4acb26944c05d22893d1596d73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#acb15c00a59b591eea00e81e4c9e8c55a">SetDivisionTolerance</a> (double tol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/get the tolerance used when performing polynomial Euclidean division to find polynomial roots. This tolerance is used to decide whether the coefficient(s) of a polynomial remainder are close enough to zero to be neglected.  <a href="#acb15c00a59b591eea00e81e4c9e8c55a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ac2e2fc84e9c84dc4559077e29b30029e">SolveCubic</a> (double c0, double c1, double c2, double c3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a cubic equation c0*t^3 + c1*t^2 + c2*t + c3 = 0 when c0, c1, c2, and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Return array contains number of (real) roots (counting multiple roots as one) followed by roots themselves. The value in roots[4] is a integer giving further information about the roots (see return codes for int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ac2e2fc84e9c84dc4559077e29b30029e" title="Solves a cubic equation c0*t^3 + c1*t^2 + c2*t + c3 = 0 when c0, c1, c2, and c3 are REAL...">SolveCubic()</a> ).  <a href="#ac2e2fc84e9c84dc4559077e29b30029e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a3926686957a7846ead9320d0a6615ea0">SolveCubic</a> (double c0, double c1, double c2, double c3, IntPtr r1, IntPtr r2, IntPtr r3, IntPtr num_roots)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a cubic equation when c0, c1, c2, And c3 Are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Roots and number of real roots are stored in user provided variables r1, r2, r3, and num_roots. Note that the function can return the following integer values describing the roots: (0)-no solution; (-1)-infinite number of solutions; (1)-one distinct real root of multiplicity 3 (stored in r1); (2)-two distinct real roots, one of multiplicity 2 (stored in r1 &amp; r2); (3)-three distinct real roots; (-2)-quadratic equation with complex conjugate solution (real part of root returned in r1, imaginary in r2); (-3)-one real root and a complex conjugate pair (real root in r1 and real part of pair in r2 and imaginary in r3).  <a href="#a3926686957a7846ead9320d0a6615ea0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a50f10c503120e218d0018504dfd6cf1c">SolveLinear</a> (double c0, double c1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a linear equation c2*t + c3 = 0 when c2 and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Return array contains number of roots followed by roots themselves.  <a href="#a50f10c503120e218d0018504dfd6cf1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aed3a228c52ff7073f84ae6b2794b147c">SolveLinear</a> (double c0, double c1, IntPtr r1, IntPtr num_roots)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a linear equation c2*t + c3 = 0 when c2 and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Root and number of (real) roots are stored in user provided variables r2 and num_roots.  <a href="#aed3a228c52ff7073f84ae6b2794b147c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aca3ebe64030bc09bdfcf702f578e7f2b">SolveQuadratic</a> (double c0, double c1, double c2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a quadratic equation c1*t^2 + c2*t + c3 = 0 when c1, c2, and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Return array contains number of (real) roots (counting multiple roots as one) followed by roots themselves. Note that roots[3] contains a return code further describing solution - see documentation for <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ac2e2fc84e9c84dc4559077e29b30029e" title="Solves a cubic equation c0*t^3 + c1*t^2 + c2*t + c3 = 0 when c0, c1, c2, and c3 are REAL...">SolveCubic()</a> for meaning of return codes.  <a href="#aca3ebe64030bc09bdfcf702f578e7f2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ad7390acaa297d68ccbb87aa12525c70e">SolveQuadratic</a> (double c0, double c1, double c2, IntPtr r1, IntPtr r2, IntPtr num_roots)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a quadratic equation c1*t^2 + c2*t + c3 = 0 when c1, c2, and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Roots and number of roots are stored in user provided variables r1, r2, num_roots.  <a href="#ad7390acaa297d68ccbb87aa12525c70e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a57d872fd84a382dfbac229e6a8ad858c">SolveQuadratic</a> (IntPtr c, IntPtr r, IntPtr m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraically extracts REAL roots of the quadratic polynomial with REAL coefficients c[0] X^2 + c[1] X + c[2] and stores them (when they exist) and their respective multiplicities in the <em>r</em> and <em>m</em> arrays. Returns either the number of roots, or -1 if ininite number of roots.  <a href="#a57d872fd84a382dfbac229e6a8ad858c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aec79d45b6b33e39f1aed5374a7d15953">SturmBisectionSolve</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial P[0] X^d + ... + P[d-1] X + P[d] in ]<em>a</em>[0] ; <em>a</em>[1]] using Sturm's theorem ( polynomial coefficients are REAL ) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.).  <a href="#aec79d45b6b33e39f1aed5374a7d15953"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ad176e894081797d2b3ef51045aae0720">SturmBisectionSolve</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial P[0] X^d + ... + P[d-1] X + P[d] in ]<em>a</em>[0] ; <em>a</em>[1]] using Sturm's theorem ( polynomial coefficients are REAL ) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.).  <a href="#ad176e894081797d2b3ef51045aae0720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a891556a2035e806e9b9ff0f2e7848027">SturmBisectionSolve</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType, bool divideGCD)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial P[0] X^d + ... + P[d-1] X + P[d] in ]<em>a</em>[0] ; <em>a</em>[1]] using Sturm's theorem ( polynomial coefficients are REAL ) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.).  <a href="#a891556a2035e806e9b9ff0f2e7848027"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a1166e47fe7507cc5d4d0d51f6ab2c3f3">TartagliaCardanSolve</a> (IntPtr c, IntPtr r, IntPtr m, double tol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraically extracts REAL roots of the cubic polynomial with REAL coefficients X^3 + c[0] X^2 + c[1] X + c[2] and stores them (when they exist) and their respective multiplicities in the <em>r</em> and <em>m</em> arrays. Some numerical noise can be filtered by the use of a tolerance <em>tol</em> instead of equality with 0 (one can use, e.g., VTK_DBL_EPSILON). The main differences with SolveCubic are that (1) the polynomial must have unit leading coefficient, (2) complex roots are discarded upfront, (3) non-simple roots are stored only once, along with their respective multiplicities, and (4) some numerical noise is filtered by the use of relative tolerance instead of equality with 0. Returns the number of roots. &lt;i&gt; In memoriam &lt;/i&gt; Niccolo Tartaglia (1500 - 1559), unfairly forgotten.  <a href="#a1166e47fe7507cc5d4d0d51f6ab2c3f3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">new const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a8a2e9fceecb02ded595d4470caa63cc5">MRFullTypeName</a> = &quot;Kitware.VTK.vtkPolynomialSolversUnivariate&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically generated type registration mechanics.  <a href="#a8a2e9fceecb02ded595d4470caa63cc5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static new readonly string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a59f7607dc3cea879df7659d0baba5f51">MRClassNameKey</a> = &quot;30vtkPolynomialSolversUnivariate&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically generated type registration mechanics.  <a href="#a59f7607dc3cea879df7659d0baba5f51"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#abd39651c8450351dfab5052faa6c02d2">Dispose</a> (bool disposing)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically generated protected Dispose method - called from public Dispose or the C# destructor. DO NOT call directly.  <a href="#abd39651c8450351dfab5052faa6c02d2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a4b078cfc0a4be7be7c8d65d67e9d85b7">vtkPolynomialSolversUnivariate_New</a> (ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a09011e5864727e470998b8c7c75232f6">vtkPolynomialSolversUnivariate_FerrariSolve_01</a> (IntPtr c, IntPtr r, IntPtr m, double tol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a7114aaec50dac4a4ad403656d13b395b">vtkPolynomialSolversUnivariate_FilterRoots_02</a> (IntPtr P, int d, IntPtr upperBnds, int rootcount, double diameter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a33e02c6fbd3ccbd7234a756a960eb5af">vtkPolynomialSolversUnivariate_GetDivisionTolerance_03</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aad39e2974920f373c7d7403a86d1b5ce">vtkPolynomialSolversUnivariate_HabichtBisectionSolve_04</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ae9f1d4988769036f6456d7d51c574c7e">vtkPolynomialSolversUnivariate_HabichtBisectionSolve_05</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a8234468930d51be6c8b6d79a88049a25">vtkPolynomialSolversUnivariate_HabichtBisectionSolve_06</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType, byte divideGCD)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a9758c2662c15907dbc5744455dca0337">vtkPolynomialSolversUnivariate_IsA_07</a> (HandleRef pThis, string type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#acd3f59031a645816640bd1f4ad272a06">vtkPolynomialSolversUnivariate_IsTypeOf_08</a> (string type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a1696a8df7f34f7094ec75b56ff7184ea">vtkPolynomialSolversUnivariate_LinBairstowSolve_09</a> (IntPtr c, int d, IntPtr r, ref double tolerance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#af1216750478091e0871cde4ff905c9ea">vtkPolynomialSolversUnivariate_NewInstance_11</a> (HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#acc2dd30288887e48fa08bee949cd70e1">vtkPolynomialSolversUnivariate_SafeDownCast_12</a> (HandleRef o, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ac8f1427d01a0ae27744938bc5b3935cf">vtkPolynomialSolversUnivariate_SetDivisionTolerance_13</a> (double tol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ae122fea39680bc11f587711cf5ba8264">vtkPolynomialSolversUnivariate_SolveCubic_14</a> (double c0, double c1, double c2, double c3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a1de54f005c3a75ab1ce04c2b549a45da">vtkPolynomialSolversUnivariate_SolveCubic_15</a> (double c0, double c1, double c2, double c3, IntPtr r1, IntPtr r2, IntPtr r3, IntPtr num_roots)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ae88616e483d7a2fbc4cd942fb5b1f493">vtkPolynomialSolversUnivariate_SolveLinear_16</a> (double c0, double c1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a7ee219600d159f2800e2ecf3d0281c3a">vtkPolynomialSolversUnivariate_SolveLinear_17</a> (double c0, double c1, IntPtr r1, IntPtr num_roots)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a65cc0730c22f452b2bce497ff546332b">vtkPolynomialSolversUnivariate_SolveQuadratic_18</a> (double c0, double c1, double c2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a695ba3d2b717db169c858632e01e5d60">vtkPolynomialSolversUnivariate_SolveQuadratic_19</a> (double c0, double c1, double c2, IntPtr r1, IntPtr r2, IntPtr num_roots)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ae9d67f37d1a424889caea806c4390b39">vtkPolynomialSolversUnivariate_SolveQuadratic_20</a> (IntPtr c, IntPtr r, IntPtr m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a8c76e9b3e5f1bf18be3a55898cb6a483">vtkPolynomialSolversUnivariate_SturmBisectionSolve_21</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a0c87873b21592770c05c85e5d6e7dcbf">vtkPolynomialSolversUnivariate_SturmBisectionSolve_22</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aacc2e215a1628f144ce17c8cbe0f4aab">vtkPolynomialSolversUnivariate_SturmBisectionSolve_23</a> (IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType, byte divideGCD)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static internal int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a165a930b02ad3b2994aaabdcfaae8aa1">vtkPolynomialSolversUnivariate_TartagliaCardanSolve_24</a> (IntPtr c, IntPtr r, IntPtr m, double tol)</td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a62e709736d4e7e46b159b0224bdc54c5">vtkPolynomialSolversUnivariate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically generated type registration mechanics.  <a href="#a62e709736d4e7e46b159b0224bdc54c5"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html" title="vtkPolynomialSolversUnivariate - polynomial solvers">vtkPolynomialSolversUnivariate</a> - polynomial solvers </p>
<p>Description <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html" title="vtkPolynomialSolversUnivariate - polynomial solvers">vtkPolynomialSolversUnivariate</a> provides solvers for univariate polynomial equations with real coefficients. The Tartaglia-Cardan and Ferrari solvers work on polynomials of fixed degree 3 and 4, respectively. The Lin-Bairstow and Sturm solvers work on polynomials of arbitrary degree. The Sturm solver is the most robust solver but only reports roots within an interval and does not report multiplicities. The Lin-Bairstow solver reports multiplicities.</p>
<p>For difficult polynomials, you may wish to use FilterRoots to eliminate some of the roots reported by the Sturm solver. FilterRoots evaluates the derivatives near each root to eliminate cases where a local minimum or maximum is close to zero.</p>
<p>Thanks Thanks to Philippe Pebay, Korben Rusek, David Thompson, and Maurice Rojas for implementing these solvers. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a62e709736d4e7e46b159b0224bdc54c5"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate" ref="a62e709736d4e7e46b159b0224bdc54c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a62e709736d4e7e46b159b0224bdc54c5">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically generated type registration mechanics. </p>

</div>
</div>
<a class="anchor" id="a4048930d714412fb77d5be402e49d75f"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate" ref="a4048930d714412fb77d5be402e49d75f" args="(IntPtr rawCppThis, bool callDisposalMethod, bool strong)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a62e709736d4e7e46b159b0224bdc54c5">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>rawCppThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>callDisposalMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strong</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically generated constructor - called from generated code. DO NOT call directly. </p>

</div>
</div>
<a class="anchor" id="a57cfcd2540e56eefc11231ff77f10f81"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate" ref="a57cfcd2540e56eefc11231ff77f10f81" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a62e709736d4e7e46b159b0224bdc54c5">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Undocumented Block. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abd39651c8450351dfab5052faa6c02d2"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::Dispose" ref="abd39651c8450351dfab5052faa6c02d2" args="(bool disposing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#abd39651c8450351dfab5052faa6c02d2">Kitware.VTK.vtkPolynomialSolversUnivariate.Dispose</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disposing</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically generated protected Dispose method - called from public Dispose or the C# destructor. DO NOT call directly. </p>

<p>Reimplemented from <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_object.html#a582c6b8c847a0d9f877bb24f23dc82b0">Kitware.VTK.vtkObject</a>.</p>

</div>
</div>
<a class="anchor" id="a10f7ec38c39518a275ce34ba34801a4e"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::FerrariSolve" ref="a10f7ec38c39518a275ce34ba34801a4e" args="(IntPtr c, IntPtr r, IntPtr m, double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a10f7ec38c39518a275ce34ba34801a4e">Kitware.VTK.vtkPolynomialSolversUnivariate.FerrariSolve</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Algebraically extracts REAL roots of the quartic polynomial with REAL coefficients X^4 + c[0] X^3 + c[1] X^2 + c[2] X + c[3] and stores them (when they exist) and their respective multiplicities in the <em>r</em> and <em>m</em> arrays, based on Ferrari's method. Some numerical noise can be filtered by the use of a tolerance <em>tol</em> instead of equality with 0 (one can use, e.g., VTK_DBL_EPSILON). Returns the number of roots. Warning: it is the user's responsibility to pass a non-negative <em>tol</em>. </p>

</div>
</div>
<a class="anchor" id="af202c14e902cd9d8da8d6290123f904c"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::FilterRoots" ref="af202c14e902cd9d8da8d6290123f904c" args="(IntPtr P, int d, IntPtr upperBnds, int rootcount, double diameter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#af202c14e902cd9d8da8d6290123f904c">Kitware.VTK.vtkPolynomialSolversUnivariate.FilterRoots</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rootcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>diameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This uses the derivative sequence to filter possible roots of a polynomial. First it sorts the roots and removes any duplicates. If the number of sign changes of the derivative sequence at a root at upperBnds[i] == that at upperBnds[i] - diameter then the i^th value is removed from upperBnds. It returns the new number of roots. </p>

</div>
</div>
<a class="anchor" id="a9226c40f9708fc6ae7de8400340d11dd"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::GetDivisionTolerance" ref="a9226c40f9708fc6ae7de8400340d11dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a9226c40f9708fc6ae7de8400340d11dd">Kitware.VTK.vtkPolynomialSolversUnivariate.GetDivisionTolerance</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set/get the tolerance used when performing polynomial Euclidean division to find polynomial roots. This tolerance is used to decide whether the coefficient(s) of a polynomial remainder are close enough to zero to be neglected. </p>

</div>
</div>
<a class="anchor" id="a1e8c1adc4e83cf9c05cc12f56d42c7f6"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::HabichtBisectionSolve" ref="a1e8c1adc4e83cf9c05cc12f56d42c7f6" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a1e8c1adc4e83cf9c05cc12f56d42c7f6">Kitware.VTK.vtkPolynomialSolversUnivariate.HabichtBisectionSolve</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P[0] X^d + ... + P[d-1] X + P[d] \]" src="form_74.png"/>
</p>
<p> in ]<em>a</em>[0] ; <em>a</em>[1]] using the Habicht sequence (polynomial coefficients are REAL) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.). </p>
<p><em>intervalType</em> specifies the search interval as follows: 0 = 00 = ]a,b[ 1 = 10 = [a,b[ 2 = 01 = ]a,b] 3 = 11 = [a,b] This defaults to 0.</p>
<p>The last non-zero item in the Habicht sequence is the gcd of P and P'. The parameter divideGCD specifies whether the program should attempt to divide by the gcd and run again. It works better with polynomials known to have high multiplicities. When divideGCD != 0 then it attempts to divide by the GCD, if applicable. This defaults to 0.</p>
<p>Compared to the Sturm solver the Habicht solver is slower, although both are O(d^2). The Habicht solver has the added benefit that it has a built in mechanism to keep the leading coefficients of the result from polynomial division bounded above and below in absolute value. This will tend to keep the coefficients of the polynomials in the sequence from zeroing out prematurely or becoming infinite.</p>
<p>Constructing the Habicht sequence is O(d^2) in both time and space.</p>
<p>Warning: it is the user's responsibility to make sure the <em>upperBnds</em> array is large enough to contain the maximal number of expected roots. Note that <em>nr</em> is smaller or equal to the actual number of roots in ]<em>a</em>[0] ; <em>a</em>[1]] since roots within  are lumped in the same bracket. array is large enough to contain the maximal number of expected upper bounds. </p>

</div>
</div>
<a class="anchor" id="a12751b02a9e9bdb12c305b0819e821f9"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::HabichtBisectionSolve" ref="a12751b02a9e9bdb12c305b0819e821f9" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a1e8c1adc4e83cf9c05cc12f56d42c7f6">Kitware.VTK.vtkPolynomialSolversUnivariate.HabichtBisectionSolve</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P[0] X^d + ... + P[d-1] X + P[d] \]" src="form_74.png"/>
</p>
<p> in ]<em>a</em>[0] ; <em>a</em>[1]] using the Habicht sequence (polynomial coefficients are REAL) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.). </p>
<p><em>intervalType</em> specifies the search interval as follows: 0 = 00 = ]a,b[ 1 = 10 = [a,b[ 2 = 01 = ]a,b] 3 = 11 = [a,b] This defaults to 0.</p>
<p>The last non-zero item in the Habicht sequence is the gcd of P and P'. The parameter divideGCD specifies whether the program should attempt to divide by the gcd and run again. It works better with polynomials known to have high multiplicities. When divideGCD != 0 then it attempts to divide by the GCD, if applicable. This defaults to 0.</p>
<p>Compared to the Sturm solver the Habicht solver is slower, although both are O(d^2). The Habicht solver has the added benefit that it has a built in mechanism to keep the leading coefficients of the result from polynomial division bounded above and below in absolute value. This will tend to keep the coefficients of the polynomials in the sequence from zeroing out prematurely or becoming infinite.</p>
<p>Constructing the Habicht sequence is O(d^2) in both time and space.</p>
<p>Warning: it is the user's responsibility to make sure the <em>upperBnds</em> array is large enough to contain the maximal number of expected roots. Note that <em>nr</em> is smaller or equal to the actual number of roots in ]<em>a</em>[0] ; <em>a</em>[1]] since roots within  are lumped in the same bracket. array is large enough to contain the maximal number of expected upper bounds. </p>

</div>
</div>
<a class="anchor" id="a566c7422feeb13d069d20d499e29791a"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::HabichtBisectionSolve" ref="a566c7422feeb13d069d20d499e29791a" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType, bool divideGCD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a1e8c1adc4e83cf9c05cc12f56d42c7f6">Kitware.VTK.vtkPolynomialSolversUnivariate.HabichtBisectionSolve</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>divideGCD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P[0] X^d + ... + P[d-1] X + P[d] \]" src="form_74.png"/>
</p>
<p> in ]<em>a</em>[0] ; <em>a</em>[1]] using the Habicht sequence (polynomial coefficients are REAL) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.). </p>
<p><em>intervalType</em> specifies the search interval as follows: 0 = 00 = ]a,b[ 1 = 10 = [a,b[ 2 = 01 = ]a,b] 3 = 11 = [a,b] This defaults to 0.</p>
<p>The last non-zero item in the Habicht sequence is the gcd of P and P'. The parameter divideGCD specifies whether the program should attempt to divide by the gcd and run again. It works better with polynomials known to have high multiplicities. When divideGCD != 0 then it attempts to divide by the GCD, if applicable. This defaults to 0.</p>
<p>Compared to the Sturm solver the Habicht solver is slower, although both are O(d^2). The Habicht solver has the added benefit that it has a built in mechanism to keep the leading coefficients of the result from polynomial division bounded above and below in absolute value. This will tend to keep the coefficients of the polynomials in the sequence from zeroing out prematurely or becoming infinite.</p>
<p>Constructing the Habicht sequence is O(d^2) in both time and space.</p>
<p>Warning: it is the user's responsibility to make sure the <em>upperBnds</em> array is large enough to contain the maximal number of expected roots. Note that <em>nr</em> is smaller or equal to the actual number of roots in ]<em>a</em>[0] ; <em>a</em>[1]] since roots within  are lumped in the same bracket. array is large enough to contain the maximal number of expected upper bounds. </p>

</div>
</div>
<a class="anchor" id="af9561d280b008c7b3f2c30964add4e9c"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::IsA" ref="af9561d280b008c7b3f2c30964add4e9c" args="(string type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#af9561d280b008c7b3f2c30964add4e9c">Kitware.VTK.vtkPolynomialSolversUnivariate.IsA</a> </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Undocumented Block. </p>

<p>Reimplemented from <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_object.html#a4f5c49137afd43eb601b4db55c8c3be4">Kitware.VTK.vtkObject</a>.</p>

</div>
</div>
<a class="anchor" id="a4032b308fdc1516d73790a1f480d36c8"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::IsTypeOf" ref="a4032b308fdc1516d73790a1f480d36c8" args="(string type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static new int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a4032b308fdc1516d73790a1f480d36c8">Kitware.VTK.vtkPolynomialSolversUnivariate.IsTypeOf</a> </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Undocumented Block. </p>

<p>Reimplemented from <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_object.html#a46b9d49140cad7c52a40a0e39cb33a1e">Kitware.VTK.vtkObject</a>.</p>

</div>
</div>
<a class="anchor" id="a57bb1e5c577ca41e04f34a6f978512ff"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::LinBairstowSolve" ref="a57bb1e5c577ca41e04f34a6f978512ff" args="(IntPtr c, int d, IntPtr r, ref double tolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a57bb1e5c577ca41e04f34a6f978512ff">Kitware.VTK.vtkPolynomialSolversUnivariate.LinBairstowSolve</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seeks all REAL roots of the <em>d</em> -th degree polynomial c[0] X^d + ... + c[d-1] X + c[d] = 0 equation Lin-Bairstow's method ( polynomial coefficients are REAL ) and stores the <em>nr</em> roots found ( multiple roots are multiply stored ) in <em>r</em>. <em>tolerance</em> is the user-defined solver tolerance; this variable may be relaxed by the iterative solver if needed. Returns <em>nr</em>. Warning: it is the user's responsibility to make sure the <em>r</em> array is large enough to contain the maximal number of expected roots. </p>

</div>
</div>
<a class="anchor" id="a8f20d54e05cf1cb1fa0031d70f148842"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::New" ref="a8f20d54e05cf1cb1fa0031d70f148842" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static new <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html">vtkPolynomialSolversUnivariate</a> <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a8f20d54e05cf1cb1fa0031d70f148842">Kitware.VTK.vtkPolynomialSolversUnivariate.New</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Undocumented Block. </p>

<p>Reimplemented from <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_object.html#a51e254ab30d5c25ac52daa4f97390fdc">Kitware.VTK.vtkObject</a>.</p>

</div>
</div>
<a class="anchor" id="a8a696e7db453a4cca94035445fe90a62"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::NewInstance" ref="a8a696e7db453a4cca94035445fe90a62" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">new <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html">vtkPolynomialSolversUnivariate</a> <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a8a696e7db453a4cca94035445fe90a62">Kitware.VTK.vtkPolynomialSolversUnivariate.NewInstance</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Undocumented Block. </p>

<p>Reimplemented from <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_object.html#a668091b97addc1d9683fcb7fca4ff8a3">Kitware.VTK.vtkObject</a>.</p>

</div>
</div>
<a class="anchor" id="a06251d4acb26944c05d22893d1596d73"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SafeDownCast" ref="a06251d4acb26944c05d22893d1596d73" args="(vtkObjectBase o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static new <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html">vtkPolynomialSolversUnivariate</a> <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a06251d4acb26944c05d22893d1596d73">Kitware.VTK.vtkPolynomialSolversUnivariate.SafeDownCast</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_object_base.html">vtkObjectBase</a>&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Undocumented Block. </p>

<p>Reimplemented from <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_object.html#a1fda566dfacaf0dda423614978432cc8">Kitware.VTK.vtkObject</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate_a06251d4acb26944c05d22893d1596d73_cgraph.svg" width="704" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="acb15c00a59b591eea00e81e4c9e8c55a"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SetDivisionTolerance" ref="acb15c00a59b591eea00e81e4c9e8c55a" args="(double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#acb15c00a59b591eea00e81e4c9e8c55a">Kitware.VTK.vtkPolynomialSolversUnivariate.SetDivisionTolerance</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set/get the tolerance used when performing polynomial Euclidean division to find polynomial roots. This tolerance is used to decide whether the coefficient(s) of a polynomial remainder are close enough to zero to be neglected. </p>

</div>
</div>
<a class="anchor" id="ac2e2fc84e9c84dc4559077e29b30029e"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SolveCubic" ref="ac2e2fc84e9c84dc4559077e29b30029e" args="(double c0, double c1, double c2, double c3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ac2e2fc84e9c84dc4559077e29b30029e">Kitware.VTK.vtkPolynomialSolversUnivariate.SolveCubic</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves a cubic equation c0*t^3 + c1*t^2 + c2*t + c3 = 0 when c0, c1, c2, and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Return array contains number of (real) roots (counting multiple roots as one) followed by roots themselves. The value in roots[4] is a integer giving further information about the roots (see return codes for int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ac2e2fc84e9c84dc4559077e29b30029e" title="Solves a cubic equation c0*t^3 + c1*t^2 + c2*t + c3 = 0 when c0, c1, c2, and c3 are REAL...">SolveCubic()</a> ). </p>

</div>
</div>
<a class="anchor" id="a3926686957a7846ead9320d0a6615ea0"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SolveCubic" ref="a3926686957a7846ead9320d0a6615ea0" args="(double c0, double c1, double c2, double c3, IntPtr r1, IntPtr r2, IntPtr r3, IntPtr num_roots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ac2e2fc84e9c84dc4559077e29b30029e">Kitware.VTK.vtkPolynomialSolversUnivariate.SolveCubic</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>num_roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves a cubic equation when c0, c1, c2, And c3 Are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Roots and number of real roots are stored in user provided variables r1, r2, r3, and num_roots. Note that the function can return the following integer values describing the roots: (0)-no solution; (-1)-infinite number of solutions; (1)-one distinct real root of multiplicity 3 (stored in r1); (2)-two distinct real roots, one of multiplicity 2 (stored in r1 &amp; r2); (3)-three distinct real roots; (-2)-quadratic equation with complex conjugate solution (real part of root returned in r1, imaginary in r2); (-3)-one real root and a complex conjugate pair (real root in r1 and real part of pair in r2 and imaginary in r3). </p>

</div>
</div>
<a class="anchor" id="a50f10c503120e218d0018504dfd6cf1c"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SolveLinear" ref="a50f10c503120e218d0018504dfd6cf1c" args="(double c0, double c1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a50f10c503120e218d0018504dfd6cf1c">Kitware.VTK.vtkPolynomialSolversUnivariate.SolveLinear</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves a linear equation c2*t + c3 = 0 when c2 and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Return array contains number of roots followed by roots themselves. </p>

</div>
</div>
<a class="anchor" id="aed3a228c52ff7073f84ae6b2794b147c"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SolveLinear" ref="aed3a228c52ff7073f84ae6b2794b147c" args="(double c0, double c1, IntPtr r1, IntPtr num_roots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a50f10c503120e218d0018504dfd6cf1c">Kitware.VTK.vtkPolynomialSolversUnivariate.SolveLinear</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>num_roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves a linear equation c2*t + c3 = 0 when c2 and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Root and number of (real) roots are stored in user provided variables r2 and num_roots. </p>

</div>
</div>
<a class="anchor" id="aca3ebe64030bc09bdfcf702f578e7f2b"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SolveQuadratic" ref="aca3ebe64030bc09bdfcf702f578e7f2b" args="(double c0, double c1, double c2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aca3ebe64030bc09bdfcf702f578e7f2b">Kitware.VTK.vtkPolynomialSolversUnivariate.SolveQuadratic</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves a quadratic equation c1*t^2 + c2*t + c3 = 0 when c1, c2, and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Return array contains number of (real) roots (counting multiple roots as one) followed by roots themselves. Note that roots[3] contains a return code further describing solution - see documentation for <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ac2e2fc84e9c84dc4559077e29b30029e" title="Solves a cubic equation c0*t^3 + c1*t^2 + c2*t + c3 = 0 when c0, c1, c2, and c3 are REAL...">SolveCubic()</a> for meaning of return codes. </p>

</div>
</div>
<a class="anchor" id="ad7390acaa297d68ccbb87aa12525c70e"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SolveQuadratic" ref="ad7390acaa297d68ccbb87aa12525c70e" args="(double c0, double c1, double c2, IntPtr r1, IntPtr r2, IntPtr num_roots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aca3ebe64030bc09bdfcf702f578e7f2b">Kitware.VTK.vtkPolynomialSolversUnivariate.SolveQuadratic</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>num_roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves a quadratic equation c1*t^2 + c2*t + c3 = 0 when c1, c2, and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Roots and number of roots are stored in user provided variables r1, r2, num_roots. </p>

</div>
</div>
<a class="anchor" id="a57d872fd84a382dfbac229e6a8ad858c"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SolveQuadratic" ref="a57d872fd84a382dfbac229e6a8ad858c" args="(IntPtr c, IntPtr r, IntPtr m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aca3ebe64030bc09bdfcf702f578e7f2b">Kitware.VTK.vtkPolynomialSolversUnivariate.SolveQuadratic</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Algebraically extracts REAL roots of the quadratic polynomial with REAL coefficients c[0] X^2 + c[1] X + c[2] and stores them (when they exist) and their respective multiplicities in the <em>r</em> and <em>m</em> arrays. Returns either the number of roots, or -1 if ininite number of roots. </p>

</div>
</div>
<a class="anchor" id="aec79d45b6b33e39f1aed5374a7d15953"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SturmBisectionSolve" ref="aec79d45b6b33e39f1aed5374a7d15953" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aec79d45b6b33e39f1aed5374a7d15953">Kitware.VTK.vtkPolynomialSolversUnivariate.SturmBisectionSolve</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial P[0] X^d + ... + P[d-1] X + P[d] in ]<em>a</em>[0] ; <em>a</em>[1]] using Sturm's theorem ( polynomial coefficients are REAL ) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.). </p>
<p>intervalType specifies the search interval as follows: 0 = 00 = ]a,b[ 1 = 10 = [a,b[ 2 = 01 = ]a,b] 3 = 11 = [a,b] This defaults to 0.</p>
<p>The last non-zero item in the Sturm sequence is the gcd of P and P'. The parameter divideGCD specifies whether the program should attempt to divide by the gcd and run again. It works better with polynomials known to have high multiplicities. When divideGCD != 0 then it attempts to divide by the GCD, if applicable. This defaults to 0.</p>
<p>Constructing the Sturm sequence is O(d^2) in both time and space.</p>
<p>Warning: it is the user's responsibility to make sure the <em>upperBnds</em> array is large enough to contain the maximal number of expected roots. Note that <em>nr</em> is smaller or equal to the actual number of roots in ]<em>a</em>[0] ; <em>a</em>[1]] since roots within  are lumped in the same bracket. array is large enough to contain the maximal number of expected upper bounds. </p>

</div>
</div>
<a class="anchor" id="ad176e894081797d2b3ef51045aae0720"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SturmBisectionSolve" ref="ad176e894081797d2b3ef51045aae0720" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aec79d45b6b33e39f1aed5374a7d15953">Kitware.VTK.vtkPolynomialSolversUnivariate.SturmBisectionSolve</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial P[0] X^d + ... + P[d-1] X + P[d] in ]<em>a</em>[0] ; <em>a</em>[1]] using Sturm's theorem ( polynomial coefficients are REAL ) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.). </p>
<p>intervalType specifies the search interval as follows: 0 = 00 = ]a,b[ 1 = 10 = [a,b[ 2 = 01 = ]a,b] 3 = 11 = [a,b] This defaults to 0.</p>
<p>The last non-zero item in the Sturm sequence is the gcd of P and P'. The parameter divideGCD specifies whether the program should attempt to divide by the gcd and run again. It works better with polynomials known to have high multiplicities. When divideGCD != 0 then it attempts to divide by the GCD, if applicable. This defaults to 0.</p>
<p>Constructing the Sturm sequence is O(d^2) in both time and space.</p>
<p>Warning: it is the user's responsibility to make sure the <em>upperBnds</em> array is large enough to contain the maximal number of expected roots. Note that <em>nr</em> is smaller or equal to the actual number of roots in ]<em>a</em>[0] ; <em>a</em>[1]] since roots within  are lumped in the same bracket. array is large enough to contain the maximal number of expected upper bounds. </p>

</div>
</div>
<a class="anchor" id="a891556a2035e806e9b9ff0f2e7848027"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::SturmBisectionSolve" ref="a891556a2035e806e9b9ff0f2e7848027" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType, bool divideGCD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aec79d45b6b33e39f1aed5374a7d15953">Kitware.VTK.vtkPolynomialSolversUnivariate.SturmBisectionSolve</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>divideGCD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds all REAL roots (within tolerance <em>tol</em>) of the <em>d</em> -th degree polynomial P[0] X^d + ... + P[d-1] X + P[d] in ]<em>a</em>[0] ; <em>a</em>[1]] using Sturm's theorem ( polynomial coefficients are REAL ) and returns the count <em>nr</em>. All roots are bracketed in the  first ]<em>upperBnds</em>[i] - <em>tol</em> ; <em>upperBnds</em>[i]] intervals. Returns -1 if anything went wrong (such as: polynomial does not have degree <em>d</em>, the interval provided by the other is absurd, etc.). </p>
<p>intervalType specifies the search interval as follows: 0 = 00 = ]a,b[ 1 = 10 = [a,b[ 2 = 01 = ]a,b] 3 = 11 = [a,b] This defaults to 0.</p>
<p>The last non-zero item in the Sturm sequence is the gcd of P and P'. The parameter divideGCD specifies whether the program should attempt to divide by the gcd and run again. It works better with polynomials known to have high multiplicities. When divideGCD != 0 then it attempts to divide by the GCD, if applicable. This defaults to 0.</p>
<p>Constructing the Sturm sequence is O(d^2) in both time and space.</p>
<p>Warning: it is the user's responsibility to make sure the <em>upperBnds</em> array is large enough to contain the maximal number of expected roots. Note that <em>nr</em> is smaller or equal to the actual number of roots in ]<em>a</em>[0] ; <em>a</em>[1]] since roots within  are lumped in the same bracket. array is large enough to contain the maximal number of expected upper bounds. </p>

</div>
</div>
<a class="anchor" id="a1166e47fe7507cc5d4d0d51f6ab2c3f3"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::TartagliaCardanSolve" ref="a1166e47fe7507cc5d4d0d51f6ab2c3f3" args="(IntPtr c, IntPtr r, IntPtr m, double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a1166e47fe7507cc5d4d0d51f6ab2c3f3">Kitware.VTK.vtkPolynomialSolversUnivariate.TartagliaCardanSolve</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Algebraically extracts REAL roots of the cubic polynomial with REAL coefficients X^3 + c[0] X^2 + c[1] X + c[2] and stores them (when they exist) and their respective multiplicities in the <em>r</em> and <em>m</em> arrays. Some numerical noise can be filtered by the use of a tolerance <em>tol</em> instead of equality with 0 (one can use, e.g., VTK_DBL_EPSILON). The main differences with SolveCubic are that (1) the polynomial must have unit leading coefficient, (2) complex roots are discarded upfront, (3) non-simple roots are stored only once, along with their respective multiplicities, and (4) some numerical noise is filtered by the use of relative tolerance instead of equality with 0. Returns the number of roots. &lt;i&gt; In memoriam &lt;/i&gt; Niccolo Tartaglia (1500 - 1559), unfairly forgotten. </p>

</div>
</div>
<a class="anchor" id="a09011e5864727e470998b8c7c75232f6"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_FerrariSolve_01" ref="a09011e5864727e470998b8c7c75232f6" args="(IntPtr c, IntPtr r, IntPtr m, double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a09011e5864727e470998b8c7c75232f6">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_FerrariSolve_01</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7114aaec50dac4a4ad403656d13b395b"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_FilterRoots_02" ref="a7114aaec50dac4a4ad403656d13b395b" args="(IntPtr P, int d, IntPtr upperBnds, int rootcount, double diameter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a7114aaec50dac4a4ad403656d13b395b">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_FilterRoots_02</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rootcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>diameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a33e02c6fbd3ccbd7234a756a960eb5af"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_GetDivisionTolerance_03" ref="a33e02c6fbd3ccbd7234a756a960eb5af" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal double <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a33e02c6fbd3ccbd7234a756a960eb5af">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_GetDivisionTolerance_03</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aad39e2974920f373c7d7403a86d1b5ce"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_HabichtBisectionSolve_04" ref="aad39e2974920f373c7d7403a86d1b5ce" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aad39e2974920f373c7d7403a86d1b5ce">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_HabichtBisectionSolve_04</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9f1d4988769036f6456d7d51c574c7e"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_HabichtBisectionSolve_05" ref="ae9f1d4988769036f6456d7d51c574c7e" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ae9f1d4988769036f6456d7d51c574c7e">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_HabichtBisectionSolve_05</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8234468930d51be6c8b6d79a88049a25"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_HabichtBisectionSolve_06" ref="a8234468930d51be6c8b6d79a88049a25" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType, byte divideGCD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a8234468930d51be6c8b6d79a88049a25">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_HabichtBisectionSolve_06</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>divideGCD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9758c2662c15907dbc5744455dca0337"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_IsA_07" ref="a9758c2662c15907dbc5744455dca0337" args="(HandleRef pThis, string type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a9758c2662c15907dbc5744455dca0337">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_IsA_07</a> </td>
          <td>(</td>
          <td class="paramtype">HandleRef&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acd3f59031a645816640bd1f4ad272a06"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_IsTypeOf_08" ref="acd3f59031a645816640bd1f4ad272a06" args="(string type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#acd3f59031a645816640bd1f4ad272a06">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_IsTypeOf_08</a> </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1696a8df7f34f7094ec75b56ff7184ea"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_LinBairstowSolve_09" ref="a1696a8df7f34f7094ec75b56ff7184ea" args="(IntPtr c, int d, IntPtr r, ref double tolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a1696a8df7f34f7094ec75b56ff7184ea">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_LinBairstowSolve_09</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b078cfc0a4be7be7c8d65d67e9d85b7"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_New" ref="a4b078cfc0a4be7be7c8d65d67e9d85b7" args="(ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal IntPtr <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a4b078cfc0a4be7be7c8d65d67e9d85b7">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_New</a> </td>
          <td>(</td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>mteStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>mteIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>rawRefCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af1216750478091e0871cde4ff905c9ea"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_NewInstance_11" ref="af1216750478091e0871cde4ff905c9ea" args="(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal IntPtr <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#af1216750478091e0871cde4ff905c9ea">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_NewInstance_11</a> </td>
          <td>(</td>
          <td class="paramtype">HandleRef&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>mteStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>mteIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>rawRefCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acc2dd30288887e48fa08bee949cd70e1"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SafeDownCast_12" ref="acc2dd30288887e48fa08bee949cd70e1" args="(HandleRef o, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal IntPtr <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#acc2dd30288887e48fa08bee949cd70e1">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SafeDownCast_12</a> </td>
          <td>(</td>
          <td class="paramtype">HandleRef&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>mteStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>mteIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>rawRefCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac8f1427d01a0ae27744938bc5b3935cf"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SetDivisionTolerance_13" ref="ac8f1427d01a0ae27744938bc5b3935cf" args="(double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal void <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ac8f1427d01a0ae27744938bc5b3935cf">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SetDivisionTolerance_13</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae122fea39680bc11f587711cf5ba8264"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SolveCubic_14" ref="ae122fea39680bc11f587711cf5ba8264" args="(double c0, double c1, double c2, double c3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal IntPtr <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ae122fea39680bc11f587711cf5ba8264">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SolveCubic_14</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1de54f005c3a75ab1ce04c2b549a45da"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SolveCubic_15" ref="a1de54f005c3a75ab1ce04c2b549a45da" args="(double c0, double c1, double c2, double c3, IntPtr r1, IntPtr r2, IntPtr r3, IntPtr num_roots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a1de54f005c3a75ab1ce04c2b549a45da">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SolveCubic_15</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>num_roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae88616e483d7a2fbc4cd942fb5b1f493"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SolveLinear_16" ref="ae88616e483d7a2fbc4cd942fb5b1f493" args="(double c0, double c1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal IntPtr <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ae88616e483d7a2fbc4cd942fb5b1f493">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SolveLinear_16</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7ee219600d159f2800e2ecf3d0281c3a"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SolveLinear_17" ref="a7ee219600d159f2800e2ecf3d0281c3a" args="(double c0, double c1, IntPtr r1, IntPtr num_roots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a7ee219600d159f2800e2ecf3d0281c3a">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SolveLinear_17</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>num_roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a65cc0730c22f452b2bce497ff546332b"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SolveQuadratic_18" ref="a65cc0730c22f452b2bce497ff546332b" args="(double c0, double c1, double c2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal IntPtr <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a65cc0730c22f452b2bce497ff546332b">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SolveQuadratic_18</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a695ba3d2b717db169c858632e01e5d60"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SolveQuadratic_19" ref="a695ba3d2b717db169c858632e01e5d60" args="(double c0, double c1, double c2, IntPtr r1, IntPtr r2, IntPtr num_roots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a695ba3d2b717db169c858632e01e5d60">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SolveQuadratic_19</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>num_roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9d67f37d1a424889caea806c4390b39"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SolveQuadratic_20" ref="ae9d67f37d1a424889caea806c4390b39" args="(IntPtr c, IntPtr r, IntPtr m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#ae9d67f37d1a424889caea806c4390b39">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SolveQuadratic_20</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c76e9b3e5f1bf18be3a55898cb6a483"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SturmBisectionSolve_21" ref="a8c76e9b3e5f1bf18be3a55898cb6a483" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a8c76e9b3e5f1bf18be3a55898cb6a483">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SturmBisectionSolve_21</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c87873b21592770c05c85e5d6e7dcbf"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SturmBisectionSolve_22" ref="a0c87873b21592770c05c85e5d6e7dcbf" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a0c87873b21592770c05c85e5d6e7dcbf">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SturmBisectionSolve_22</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aacc2e215a1628f144ce17c8cbe0f4aab"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_SturmBisectionSolve_23" ref="aacc2e215a1628f144ce17c8cbe0f4aab" args="(IntPtr P, int d, IntPtr a, IntPtr upperBnds, double tol, int intervalType, byte divideGCD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#aacc2e215a1628f144ce17c8cbe0f4aab">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_SturmBisectionSolve_23</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>upperBnds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>divideGCD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a165a930b02ad3b2994aaabdcfaae8aa1"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::vtkPolynomialSolversUnivariate_TartagliaCardanSolve_24" ref="a165a930b02ad3b2994aaabdcfaae8aa1" args="(IntPtr c, IntPtr r, IntPtr m, double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static internal int <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a165a930b02ad3b2994aaabdcfaae8aa1">Kitware.VTK.vtkPolynomialSolversUnivariate.vtkPolynomialSolversUnivariate_TartagliaCardanSolve_24</a> </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a59f7607dc3cea879df7659d0baba5f51"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::MRClassNameKey" ref="a59f7607dc3cea879df7659d0baba5f51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">new readonly string <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a59f7607dc3cea879df7659d0baba5f51">Kitware.VTK.vtkPolynomialSolversUnivariate.MRClassNameKey</a> = &quot;30vtkPolynomialSolversUnivariate&quot;<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically generated type registration mechanics. </p>

<p>Reimplemented from <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_object.html#a07bda1bc8e89401f0b03936f1495ec1d">Kitware.VTK.vtkObject</a>.</p>

</div>
</div>
<a class="anchor" id="a8a2e9fceecb02ded595d4470caa63cc5"></a><!-- doxytag: member="Kitware::VTK::vtkPolynomialSolversUnivariate::MRFullTypeName" ref="a8a2e9fceecb02ded595d4470caa63cc5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">new const string <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_polynomial_solvers_univariate.html#a8a2e9fceecb02ded595d4470caa63cc5">Kitware.VTK.vtkPolynomialSolversUnivariate.MRFullTypeName</a> = &quot;Kitware.VTK.vtkPolynomialSolversUnivariate&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically generated type registration mechanics. </p>

<p>Reimplemented from <a class="el" href="class_kitware_1_1_v_t_k_1_1vtk_object.html#a7d240769d1a3c755103642a208272043">Kitware.VTK.vtkObject</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>csharp/<a class="el" href="vtk_polynomial_solvers_univariate_8cs.html">vtkPolynomialSolversUnivariate.cs</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 21 2012 21:55:14 for ActiViz .NET by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
