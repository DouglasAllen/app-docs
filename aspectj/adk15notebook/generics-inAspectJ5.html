<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Generics in AspectJ 5</title><link rel="stylesheet" type="text/css" href="aspectj-docs.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="The AspectJTM 5 Development Kit Developer's Notebook"><link rel="up" href="generics.html" title="Chapter 3. Generics"><link rel="prev" href="generics.html" title="Chapter 3. Generics"><link rel="next" href="autoboxing.html" title="Chapter 4. Autoboxing and Unboxing"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Generics in AspectJ 5</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="generics.html">Prev</a> </td><th width="60%" align="center">Chapter 3. Generics</th><td width="20%" align="right"> <a accesskey="n" href="autoboxing.html">Next</a></td></tr></table><hr></div><div class="sect1" title="Generics in AspectJ 5"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="generics-inAspectJ5"></a>Generics in AspectJ 5</h2></div></div></div><p>
        AspectJ 5 provides full support for all of the Java 5 language features, including generics. Any legal Java 5 program is a 
        legal AspectJ 5 progam. In addition, AspectJ 5 provides support for generic and parameterized types in pointcuts, inter-type
        declarations, and declare statements.  Parameterized types may freely be used within aspect members, and support is 
        also provided for generic <span class="emphasis"><em>abstract</em></span> aspects.
      </p><div class="sect2" title="Matching generic and parameterized types in pointcut expressions"><div class="titlepage"><div><div><h3 class="title"><a name="matching-generic-and-parameterized-types-in-pointcut-expressions"></a>Matching generic and parameterized types in pointcut expressions</h3></div></div></div><p>
            The simplest way to work with generic and parameterized types in pointcut expressions and type patterns
            is simply to use the raw type name. For example, the type pattern <code class="literal">List</code> will match
            the generic type <code class="literal">List&lt;E&gt;</code> and any parameterization of that type 
            (<code class="literal">List&lt;String&gt;, List&lt;?&gt;, List&lt;? extends Number&gt;</code> and so on. This 
            ensures that pointcuts written in existing code that is not generics-aware will continue to work as
            expected in AspectJ 5. It is also the recommended way to match against generic and parameterized types
            in AspectJ 5 unless you explicitly wish to narrow matches to certain parameterizations of a generic type.
          </p><p>Generic methods and constructors, and members defined in generic types, may use type variables
          as part of their signature. For example:</p><pre class="programlisting">
          public class Utils {
            
            /** static generic method */
            static &lt;T&gt; T first(List&lt;T&gt; ts) { ... }
            
            /** instance generic method */
            &lt;T extends Number&gt; T max(T t1, T t2) { ... }
                
          }
          
          public class G&lt;T&gt; {
           
             // field with parameterized type
             T myData;
             
             // method with parameterized return type
             public List&lt;T&gt; getAllDataItems() {...}
              
          }
		</pre><p>
            AspectJ 5 does not allow the use of type variables in pointcut expressions and type patterns. Instead, members that
            use type parameters as part of their signature are matched by their <span class="emphasis"><em>erasure</em></span>. Java 5 defines the
            rules for determing the erasure of a type as follows.
          </p><p>Let <code class="literal">|T|</code> represent the erasure of some type <code class="literal">T</code>. Then:</p><table border="0" summary="Simple list" class="simplelist"><tr><td>The erasure of a parameterized type <code class="literal">T&lt;T1,...,Tn&gt;</code> is <code class="literal">|T|</code>.
            For example, the erasure of <code class="literal">List&lt;String&gt;</code> is <code class="literal">List</code>.</td></tr><tr><td>The erasure of a nested type <code class="literal">T.C</code> is <code class="literal">|T|.C</code>. For example,
            the erasure of the nested type <code class="literal">Foo&lt;T&gt;.Bar</code> is <code class="literal">Foo.Bar</code>.</td></tr><tr><td>The erasure of an array type <code class="literal">T[]</code> is <code class="literal">|T|[]</code>. For example,
            the erasure of <code class="literal">List&lt;String&gt;[]</code> is <code class="literal">List[]</code>.</td></tr><tr><td>The erasure of a type variable is its leftmost bound. For example, the erasure of a 
            type variable <code class="literal">P</code> is <code class="literal">Object</code>, and the erasure of a type
            variable <code class="literal">N extends Number</code> is <code class="literal">Number</code>.</td></tr><tr><td>The erasure of every other type is the type itself</td></tr></table><p>Applying these rules to the earlier examples, we find that the methods defined in <code class="literal">Utils</code>
          can be matched by a signature pattern matching <code class="literal">static Object Utils.first(List)</code> and
          <code class="literal">Number Utils.max(Number, Number)</code> respectively. The members of the generic type
          <code class="literal">G</code> can be matched by a signature pattern matching <code class="literal">Object G.myData</code> and
          <code class="literal">public List G.getAllDataItems()</code> respectively.</p><div class="sect3" title="Restricting matching using parameterized types"><div class="titlepage"><div><div><h4 class="title"><a name="idp32462304"></a>Restricting matching using parameterized types</h4></div></div></div><p>Pointcut matching can be further restricted to match only given parameterizations of parameter types (methods and constructors), return
          types (methods) and field types (fields). This is achieved by specifying a parameterized type pattern at the appropriate point 
          in the signature pattern. For example, given the class <code class="literal">Foo</code>:</p><pre class="programlisting">
          public class Foo {
            
            List&lt;String&gt; myStrings;
            List&lt;Float&gt;  myFloats;
                
            public List&lt;String&gt; getStrings() { return myStrings; }
            public List&lt;Float&gt; getFloats() { return myFloats; }
                
            public void addStrings(List&lt;String&gt; evenMoreStrings) {
               myStrings.addAll(evenMoreStrings);   
            }
                
          }
		</pre><p>Then a <code class="literal">get</code> join point for the field <code class="literal">myStrings</code> can be matched by the
        pointcut <code class="literal">get(List Foo.myStrings)</code> and by the pointcut <code class="literal">get(List&lt;String&gt; Foo.myStrings)</code>,
        but <span class="emphasis"><em>not</em></span> by the pointcut <code class="literal">get(List&lt;Number&gt; *)</code>.</p><p>A <code class="literal">get</code> join point for the field <code class="literal">myFloats</code> can be matched by the
        pointcut <code class="literal">get(List Foo.myFloats)</code>, the pointcut <code class="literal">get(List&lt;Float&gt; *)</code>,
        and the pointcut <code class="literal">get(List&lt;Number+&gt; *)</code>. This last example shows how AspectJ type
        patterns can be used to match type parameters types just like any other type. The pointcut
        <code class="literal">get(List&lt;Double&gt; *)</code> does <span class="emphasis"><em>not</em></span> match.</p><p>The execution of the methods <code class="literal">getStrings</code> and <code class="literal">getFloats</code> can be
        matched by the pointcut expression <code class="literal">execution(List get*(..))</code>, and the pointcut
        expression <code class="literal">execution(List&lt;*&gt; get*(..))</code>, but only <code class="literal">getStrings</code>
        is matched by <code class="literal">execution(List&lt;String&gt; get*(..))</code> and only <code class="literal">getFloats</code>
        is matched by <code class="literal">execution(List&lt;Number+&gt; get*(..))</code></p><p>A call to the method <code class="literal">addStrings</code> can be matched by the pointcut expression
        <code class="literal">call(* addStrings(List))</code> and by the expression <code class="literal">call(* addStrings(List&lt;String&gt;))</code>,
        but <span class="emphasis"><em>not</em></span> by the expression <code class="literal">call(* addStrings(List&lt;Number&gt;))</code>.
        </p><p>Remember that any type variable reference in a generic member is
        <span class="emphasis"><em>always</em></span> matched by its erasure. Thus given the following
        example:</p><pre class="programlisting">
          class G&lt;T&gt; {
  	
	        List&lt;T&gt; foo(List&lt;String&gt; ls) { return null; }
	
          }
		</pre><p>The execution of <code class="literal">foo</code> can be matched by
        <code class="literal">execution(List foo(List))</code>, 
        <code class="literal">execution(List foo(List&lt;String&gt;&gt;))</code>, and 
        <code class="literal">execution(* foo(List&lt;String&lt;))</code>but 
        <span class="emphasis"><em>not</em></span> by <code class="literal">execution(List&lt;Object&gt; foo(List&lt;String&gt;&gt;)</code>
        since the erasure of <code class="literal">List&lt;T&gt;</code> is <code class="literal">List</code>
        and not <code class="literal">List&lt;Object&gt;</code>.
        </p></div><div class="sect3" title="Generic wildcards and signature matching"><div class="titlepage"><div><div><h4 class="title"><a name="idp32491168"></a>Generic wildcards and signature matching</h4></div></div></div><p>
            When it comes to signature matching, a type parameterized using a generic wildcard is a distinct type.
            For example, <code class="literal">List&lt;?&gt;</code> is a very different type to <code class="literal">List&lt;String&gt;</code>,
            even though a variable of type <code class="literal">List&lt;String&gt;</code> can be assigned to a variable of
            type <code class="literal">List&lt;?&gt;</code>. Given the methods:
          </p><pre class="programlisting">
          class C {

            public void foo(List&lt;? extends Number&gt; listOfSomeNumberType) {}
            
            public void bar(List&lt;?&gt; listOfSomeType) {}
            
            public void goo(List&lt;Double&gt; listOfDoubles) {}	
	
          }
		</pre><div class="variablelist"><dl><dt><span class="term">execution(* C.*(List))</span></dt><dd><p>Matches an execution join point for any of the three methods.
            </p></dd><dt><span class="term">execution(* C.*(List&lt;? extends Number&gt;))</span></dt><dd><p>matches only the
          execution of <code class="literal">foo</code>, and <span class="emphasis"><em>not</em></span> the execution
          of <code class="literal">goo</code> since <code class="literal">List&lt;? extends Number&gt;</code> and 
          <code class="literal">List&lt;Double&gt;</code> are distinct types.
            </p></dd><dt><span class="term">execution(* C.*(List&lt;?&gt;))</span></dt><dd><p>matches only the execution of <code class="literal">bar</code>.
            </p></dd><dt><span class="term">execution(* C.*(List&lt;? extends Object+&gt;))</span></dt><dd><p>matches both the execution of <code class="literal">foo</code> and the execution of <code class="literal">bar</code> 
          since the upper bound of <code class="literal">List&lt;?&gt;</code> is implicitly <code class="literal">Object</code>.
            </p></dd></dl></div></div><div class="sect3" title="Treatment of bridge methods"><div class="titlepage"><div><div><h4 class="title"><a name="idp32508784"></a>Treatment of bridge methods</h4></div></div></div><p>Under certain circumstances a Java 5 compiler is required to create <span class="emphasis"><em>bridge
          methods</em></span> that support the compilation of programs using raw types. Consider the types</p><pre class="programlisting">
          class Generic&lt;T&gt; {
	
        	public T foo(T someObject) {
	        	return someObject;
	        }
	
          }

          class SubGeneric&lt;N extends Number&gt; extends Generic&lt;N&gt; {
	
	        public N foo(N someNumber) {
		      return someNumber;
	        }
		
          }
		</pre><p>The class <code class="literal">SubGeneric</code> extends <code class="literal">Generic</code>
		 and overrides the method <code class="literal">foo</code>. Since the upper bound of the type variable
		 <code class="literal">N</code> in <code class="literal">SubGeneric</code> is different to the upper bound of
		 the type variable <code class="literal">T</code> in <code class="literal">Generic</code>, the method <code class="literal">foo</code>
		 in <code class="literal">SubGeneric</code> has a different erasure to the method <code class="literal">foo</code>
		 in <code class="literal">Generic</code>. This is an example of a case where a Java 5 compiler will create
		 a <span class="emphasis"><em>bridge method</em></span> in <code class="literal">SubGeneric</code>. Although you never see it,
		 the bridge method will look something like this:</p><pre class="programlisting">
	        public Object foo(Object arg) {
	          Number n = (Number) arg; // "bridge" to the signature defined in this type
		      return foo(n);
	        }
		</pre><p>Bridge methods are synthetic artefacts generated as a result of a particular compilation strategy and
		 have no execution join points in AspectJ 5. So the pointcut <code class="literal">execution(Object SubGeneric.foo(Object))</code>
		 does not match anything. (The pointcut <code class="literal">execution(Object Generic.foo(Object))</code> matches the
		 execution of <code class="literal">foo</code> in both <code class="literal">Generic</code> and <code class="literal">SubGeneric</code> since
		 both are implementations of <code class="literal">Generic.foo</code>).
		 </p><p>It <span class="emphasis"><em>is</em></span> possible to <span class="emphasis"><em>call</em></span> a bridge method as the following short
		 code snippet demonstrates. Such a call <span class="emphasis"><em>does</em></span> result in a call join point for the call to
		 the method.		 
		 </p><pre class="programlisting">
           SubGeneric rawType = new SubGeneric();
           rawType.foo("hi");  // call to bridge method (will result in a runtime failure in this case)
           Object n = new Integer(5);
           rawType.foo(n);     // call to bridge method that would succeed at runtime
		</pre></div><div class="sect3" title="Runtime type matching with this(), target() and args()"><div class="titlepage"><div><div><h4 class="title"><a name="idp32527632"></a>Runtime type matching with this(), target() and args()</h4></div></div></div><p>The <code class="literal">this()</code>, <code class="literal">target()</code>, and
          <code class="literal">args()</code> pointcut expressions all match based on the runtime
          type of their arguments. Because Java 5 implements generics using erasure, it is not
          possible to ask at runtime whether an object is an instance of a given parameterization of a type
          (only whether or not it is an instance of the erasure of that parameterized type). Therefore
          AspectJ 5 does not support the use of parameterized types with the <code class="literal">this()</code> and
          <code class="literal">target()</code> pointcuts. Parameterized types may however be used in conjunction with
          <code class="literal">args()</code>. Consider the following class
          </p><pre class="programlisting">
         public class C {
           
           public void foo(List&lt;String&gt; listOfStrings) {}
               
           public void bar(List&lt;Double&gt; listOfDoubles) {}
               
           public void goo(List&lt;? extends Number&gt; listOfSomeNumberType) {}
         
         }
		</pre><div class="variablelist"><dl><dt><span class="term">args(List)</span></dt><dd><p>will match an execution or call join point for any of
              these methods
              </p></dd><dt><span class="term">args(List&lt;String&gt;)</span></dt><dd><p>will match an execution
              or call join point for <code class="literal">foo</code>.
              </p></dd><dt><span class="term">args(List&lt;Double&gt;)</span></dt><dd><p>matches an execution or call join point for <code class="literal">bar</code>, and <span class="emphasis"><em>may</em></span> match
              at an execution or call join point for <code class="literal">goo</code> since it is legitimate to pass an
              object of type <code class="literal">List&lt;Double&gt;</code> to a method expecting a <code class="literal">List&lt;? extends Number&gt;</code>.
              </p><p>
                  In this situation a runtime test would normally be applied to ascertain whether or not the argument
              was indeed an instance of the required type. However, in the case of parameterized types such a test is not
              possible and therefore AspectJ 5 considers this a match, but issues an <span class="emphasis"><em>unchecked</em></span> warning.
              For example, compiling the aspect <code class="literal">A</code> below with the class <code class="literal">C</code> produces the 
              compilation warning: "unchecked match of List&lt;Double&gt; with List&lt;? extends Number&gt; when argument is 
              an instance of List at join point method-execution(void C.goo(List&lt;? extends Number&gt;)) [Xlint:uncheckedArgument]";
              </p></dd></dl></div><pre class="programlisting">
         public aspect A {

            before(List&lt;Double&gt; listOfDoubles) : execution(* C.*(..)) &amp;&amp; args(listOfDoubles) {
               for (Double d : listOfDoubles) {
                  // do something
               }
            }           
         
         }
		</pre><p>Like all Lint messages, the <code class="literal">uncheckedArgument</code> warning can be
            configured in severity from the default warning level to error or even ignore if preferred.
            In addition, AspectJ 5 offers the annotation <code class="literal">@SuppressAjWarnings</code> which is
            the AspectJ equivalent of Java's <code class="literal">@SuppressWarnings</code> annotation. If the
            advice is annotated with <code class="literal">@SuppressWarnings</code> then <span class="emphasis"><em>all</em></span>
            lint warnings issued during matching of pointcut associated with the advice will be
            suppressed. To suppress just an <code class="literal">uncheckedArgument</code> warning, use the
            annotation <code class="literal">@SuppressWarnings("uncheckedArgument")</code> as in the following 
            examples:
            </p><pre class="programlisting">
         import org.aspectj.lang.annotation.SuppressAjWarnings
         public aspect A {

            @SuppressAjWarnings   // will not see *any* lint warnings for this advice
            before(List&lt;Double&gt; listOfDoubles) : execution(* C.*(..)) &amp;&amp; args(listOfDoubles) {
               for (Double d : listOfDoubles) {
                  // do something
               }
            }           
            
            @SuppressAjWarnings("uncheckedArgument")   // will not see *any* lint warnings for this advice
            before(List&lt;Double&gt; listOfDoubles) : execution(* C.*(..)) &amp;&amp; args(listOfDoubles) {
               for (Double d : listOfDoubles) {
                  // do something
               }
            }       
         
         }
		</pre><p>
              The safest way to deal with <code class="literal">uncheckedArgument</code> warnings however is to restrict the pointcut
              to match only at those join points where the argument is guaranteed to match. This is achieved by combining
              <code class="literal">args</code> with a <code class="literal">call</code> or <code class="literal">execution</code> signature matching 
              pointcut. In the following example the advice will match the execution of <code class="literal">bar</code> but not
              of <code class="literal">goo</code> since the signature of <code class="literal">goo</code> is not matched by the execution pointcut
              expression.
            </p><pre class="programlisting">
         public aspect A {

            before(List&lt;Double&gt; listOfDoubles) : execution(* C.*(List&lt;Double&gt;)) &amp;&amp; args(listOfDoubles) {
               for (Double d : listOfDoubles) {
                  // do something
               }
            }           
         
         }
		</pre><p>Generic wildcards can be used in args type patterns, and matching follows regular Java 5 assignability rules. For
            example, <code class="literal">args(List&lt;?&gt;)</code> will match a list argument of any type, and 
            <code class="literal">args(List&lt;? extends Number&gt;)</code> will match an argument of type
            <code class="literal">List&lt;Number&gt;, List&lt;Double&gt;, List&lt;Float&gt;</code> and so on. Where a match cannot be 
            fully statically determined, the compiler will once more issue an <code class="literal">uncheckedArgument</code> warning.
            </p><p>Consider the following program:</p><pre class="programlisting">
         public class C {
         
            public static void main(String[] args) {
               C c = new C();
               List&lt;String&gt; ls = new ArrayList&lt;String&gt;();
               List&lt;Double&gt; ld = new ArrayList&lt;Double&gt;();
               c.foo("hi");
               c.foo(ls);
               c.foo(ld);
            }
         
            public void foo(Object anObject) {}         
         }
         
         aspect A {
             before(List&lt;? extends Number&gt; aListOfSomeNumberType) 
               : call(* foo(..)) &amp;&amp; args(aListOfSomeNumberType) {
                // process list... 
             }
         }
		</pre><p>From the signature of <code class="literal">foo</code> all we know is that the runtime argument will be an instance of 
            <code class="literal">Object</code>.Compiling this program gives the unchecked argument warning: 
            "unchecked match of List&lt;? extends Number&gt; with List when argument is 
              an instance of List at join point method-execution(void C.foo(Object)) [Xlint:uncheckedArgument]".
              The advice will not execute at the call join point for <code class="literal">c.foo("hi")</code> since <code class="literal">String</code>
              is not an instance of <code class="literal">List</code>. The advice <span class="emphasis"><em>will</em></span> execute at the call join points
              for <code class="literal">c.foo(ls)</code> and <code class="literal">c.foo(ld)</code> since in both cases the argument is an instance of
              <code class="literal">List</code>.
            </p><p>Combine a wildcard argument type with a signature pattern to avoid unchecked argument matches. In the example
            below we use the signature pattern <code class="literal">List&lt;Number+&gt;</code> to match a call to any method taking
            a <code class="literal">List&lt;Number&gt;, List&lt;Double&gt;, List&lt;Float&gt;</code> and so on. In addition the 
            signature pattern <code class="literal">List&lt;? extends Number+&gt;</code> can be used to match a call to a method
            declared to take a <code class="literal">List&lt;? extends Number&gt;</code>, <code class="literal">List&lt;? extends Double&gt;</code>
            and so on. Taken together, these restrict matching to only
            those join points at which the argument is guaranteed to be an instance of <code class="literal">List&lt;? extends Number&gt;</code>.</p><pre class="programlisting">
         aspect A {
             before(List&lt;? extends Number&gt; aListOfSomeNumberType) 
               : (call(* foo(List&lt;Number+&gt;)) || call(* foo(List&lt;? extends Number+&gt;))) 
                 &amp;&amp; args(aListOfSomeNumberType) {
                 // process list... 
             }
         }
		</pre></div><div class="sect3" title="Binding return values in after returning advice"><div class="titlepage"><div><div><h4 class="title"><a name="idp32577424"></a>Binding return values in after returning advice</h4></div></div></div><p>
            After returning advice can be used to bind the return value from a matched join point. AspectJ 5 supports the use of
            a parameterized type in the returning clause, with matching following the same rules as described for args. For
            example, the following aspect matches the execution of any method returning a <code class="literal">List</code>, and makes
            the returned list available to the body of the advice. 
          </p><pre class="programlisting">
         public aspect A {

           pointcut executionOfAnyMethodReturningAList() : execution(List *(..));
           
           after() returning(List&lt;?&gt; listOfSomeType) : executionOfAnyMethodReturningAList() {
             for (Object element : listOfSomeType) {
                // process element...
             }
           }
         
         }
		</pre><p>The pointcut uses the raw type pattern <code class="literal">List</code>, and hence it
          matches methods returning any kind of list (<code class="literal">List&lt;String&gt;, List&lt;Double&gt;</code>, 
          and so on). We've chosen to bind the returned list as the parameterized type 
          <code class="literal">List&lt;?&gt;</code> in the advice since Java's type checking will now ensure
          that we only perform safe operations on the list.</p><p>Given the class</p><pre class="programlisting">
         public class C {
           
           public List&lt;String&gt; foo(List&lt;String&gt; listOfStrings) {...}
               
           public List&lt;Double&gt; bar(List&lt;Double&gt; listOfDoubles) {...}
               
           public List&lt;? extends Number&gt; goo(List&lt;? extends Number&gt; listOfSomeNumberType) {...}
         
         }
		</pre><p>The advice in the aspect below will run after the execution of <code class="literal">bar</code>
          and bind the return value. It will also run after the execution of <code class="literal">goo</code> and
          bind the return value, but gives an <code class="literal">uncheckedArgument</code> warning during
          compilation. It does <span class="emphasis"><em>not</em></span> run after the execution of <code class="literal">foo</code>.
          </p><pre class="programlisting">
         public aspect Returning {
         
           after() returning(List&lt;Double&gt; listOfDoubles) : execution(* C.*(..)) {
              for(Double d : listOfDoubles) {
                 // process double...
              }   
           }
         
         }
		</pre><p>As with <code class="literal">args</code> you can guarantee that after returning advice only
		executes on lists <span class="emphasis"><em>statically determinable</em></span> to be of the right
		type by specifying a return type pattern in the associated pointcut. The 
		<code class="literal">@SuppressAjWarnings</code> annotation can also be used if desired.</p></div><div class="sect3" title="Declaring pointcuts inside generic types"><div class="titlepage"><div><div><h4 class="title"><a name="idp32592016"></a>Declaring pointcuts inside generic types</h4></div></div></div><p>Pointcuts can be declared in both classes and aspects. A pointcut declared in a generic
            type may use the type variables of the type in which it is declared. All references to
            a pointcut declared in a generic type from outside of that type must be via a parameterized type reference, 
            and not a raw type reference.</p><p>Consider the generic type <code class="literal">Generic</code> with a pointcut <code class="literal">foo</code>:
            </p><pre class="programlisting">
         public class Generic&lt;T&gt; {
         
            /**
             * matches the execution of any implementation of a method defined for T
             */
            public pointcut foo() : execution(* T.*(..));
         
         }
		</pre><p>Such a pointcut must be refered to using a parameterized reference as shown
		below.</p><pre class="programlisting">
         public aspect A {
         
           // runs before the execution of any implementation of a method defined for MyClass
           before() : Generic&lt;MyClass&gt;.foo() {
              // ...   
           }
           
           // runs before the execution of any implementation of a method defined for YourClass
           before() : Generic&lt;YourClass&gt;.foo() {
               // ...
           }
         
           // results in a compilation error - raw type reference
           before() : Generic.foo() { }
         
         }
		</pre></div></div><div class="sect2" title="Inter-type Declarations"><div class="titlepage"><div><div><h3 class="title"><a name="inter-type-declarations"></a>Inter-type Declarations</h3></div></div></div><p>
            AspectJ 5 supports the inter-type declaration of generic methods, and of members on
            generic types. For generic methods, the syntax is exactly as for a regular method
            declaration, with the addition of the target type specification:
          </p><div class="variablelist"><dl><dt><span class="term">&lt;T extends Number&gt; T Utils.max(T first, T second) {...}</span></dt><dd><p>Declares a generic instance method <code class="literal">max</code> on the class <code class="literal">Util</code>.
            The <code class="literal">max</code> method takes two arguments, <code class="literal">first</code> and <code class="literal">second</code> which must
            both be of the same type (and that type must be Number or a subtype of Number) and returns an instance
            of that type.
            </p></dd><dt><span class="term">static &lt;E&gt; E Utils.first(List&lt;E&gt; elements) {...}</span></dt><dd><p>Declares a static generic method <code class="literal">first</code> on the class <code class="literal">Util</code>.
            The <code class="literal">first</code> method takes a list of elements of some type, and returns an instance
            of that type.
            </p></dd><dt><span class="term">&lt;T&gt; Sorter.new(List&lt;T&gt; elements,Comparator&lt;? super T&gt; comparator) {...}</span></dt><dd><p>Declares a constructor on the class <code class="literal">Sorter</code>.
            The constructor takes a list of elements of some type, and a comparator that can compare instances
            of the element type.
            </p></dd></dl></div><p>
         A generic type may be the target of an inter-type declaration, used either in its raw form or with
         type parameters specified. If type parameters are specified, then the number of type parameters given
          must match the number of type parameters in
         the generic type declaration. Type parameter <span class="emphasis"><em>names</em></span> do not have to match.
         For example, given the generic type <code class="literal">Foo&lt;T,S extends Number&gt;</code> then:      
      </p><div class="variablelist"><dl><dt><span class="term">String Foo.getName() {...}</span></dt><dd><p>Declares a <code class="literal">getName</code> method on behalf of the type <code class="literal">Foo</code>. It is
            not possible to refer to the type parameters of Foo in such a declaration.
            </p></dd><dt><span class="term">public R Foo&lt;Q, R&gt;.getMagnitude() {...}</span></dt><dd><p>Declares a method <code class="literal">getMagnitude</code> on the generic class <code class="literal">Foo</code>.
            The method returns an instance of the type substituted for the second type parameter in an invocation
            of <code class="literal">Foo</code> If <code class="literal">Foo</code> is declared as 
            <code class="literal">Foo&lt;T,N extends Number&gt; {...}</code> then this inter-type declaration is
            equivalent to the declaration of a method <code class="literal">public N getMagnitude()</code> 
            within the body of <code class="literal">Foo</code>.
            </p></dd><dt><span class="term">R Foo&lt;Q, R extends Number&gt;.getMagnitude() {...}</span></dt><dd><p>Results in a compilation error since a bounds specification is not allowed in this
                form of an inter-type declaration (the bounds are determined from the declaration of the
                target type).
            </p></dd></dl></div><p>A parameterized type may not be the target of an inter-type declaration. This is because
      there is only one type (the generic type) regardless of how many different invocations (parameterizations) of
      that generic type are made in a program. Therefore it does not make sense to try and declare a member
      on behalf of (say) <code class="literal">Bar&lt;String&gt;</code>, you can only declare members on the generic
      type <code class="literal">Bar&lt;T&gt;</code>. 
      </p></div><div class="sect2" title="Declare Parents"><div class="titlepage"><div><div><h3 class="title"><a name="declare-parents"></a>Declare Parents</h3></div></div></div><p>Both generic and parameterized types can be used as the parent type in a <code class="literal">declare parents</code>
          statement (as long as the resulting type hierarchy would be well-formed in accordance with Java's sub-typing
          rules). Generic types may also be used as the target type of a <code class="literal">declare parents</code> statement.</p><div class="variablelist"><dl><dt><span class="term">declare parents: Foo implements List&lt;String&gt;</span></dt><dd><p>The <code class="literal">Foo</code> type implements the <code class="literal">List&lt;String&gt;</code> interface. If
            <code class="literal">Foo</code> already implements some other parameterization of the <code class="literal">List</code>
            interface (for example, <code class="literal">List&lt;Integer&gt;</code> then a compilation error will result since a 
            type cannot implement multiple parameterizations of the same generic interface type. 
            </p></dd></dl></div></div><div class="sect2" title="Declare Soft"><div class="titlepage"><div><div><h3 class="title"><a name="declare-soft"></a>Declare Soft</h3></div></div></div><p>It is an error to use a generic or parameterized type as the softened exception type in a declare soft statement. Java 5 does
          not permit a generic class to be a direct or indirect subtype of <code class="literal">Throwable</code> (JLS 8.1.2).</p></div><div class="sect2" title="Generic Aspects"><div class="titlepage"><div><div><h3 class="title"><a name="generic-aspects"></a>Generic Aspects</h3></div></div></div><p>
            AspectJ 5 allows an <span class="emphasis"><em>abstract</em></span> aspect to be declared as a generic type. Any concrete
            aspect extending a generic abstract aspect must extend a parameterized version of the abstract aspect.
            Wildcards are not permitted in this parameterization.     
          </p><p>Given the aspect declaration:</p><pre class="programlisting">
            public abstract aspect ParentChildRelationship&lt;P,C&gt; {
                ...
            }
		</pre><p>then</p><div class="variablelist"><dl><dt><span class="term">public aspect FilesInFolders extends ParentChildRelationship&lt;Folder,File&gt; {...</span></dt><dd><p>declares a concrete sub-aspect, <code class="literal">FilesInFolders</code> which extends the
            parameterized abstract aspect <code class="literal">ParentChildRelationship&lt;Folder,File&gt;</code>.
            </p></dd><dt><span class="term">public aspect FilesInFolders extends ParentChildRelationship {...</span></dt><dd><p>results in a compilation error since the <code class="literal">ParentChildRelationship</code> aspect must
            be fully parameterized.
            </p></dd><dt><span class="term">public aspect ThingsInFolders&lt;T&gt; extends ParentChildRelationship&lt;Folder,T&gt;</span></dt><dd><p>results in a compilation error since concrete aspects may not have type parameters.
            </p></dd><dt><span class="term">public abstract aspect ThingsInFolders&lt;T&gt; extends ParentChildRelationship&lt;Folder,T&gt;</span></dt><dd><p>declares a sub-aspect of <code class="literal">ParentChildRelationship</code> in which <code class="literal">Folder</code>
            plays the role of parent (is bound to the type variable <code class="literal">P</code>).
            </p></dd></dl></div><p>The type parameter variables from a generic aspect declaration may be used in place of a type within any
        member of the aspect, <span class="emphasis"><em>except for within inter-type declarations</em></span>. 
        For example, we can declare a <code class="literal">ParentChildRelationship</code> aspect to
        manage the bi-directional relationship between parent and child nodes as follows:
        </p><pre class="programlisting">
          /** 
           * a generic aspect, we've used descriptive role names for the type variables
           * (Parent and Child) but you could use anything of course
           */
          public abstract aspect ParentChildRelationship&lt;Parent,Child&gt; {

            /** generic interface implemented by parents */   
            interface ParentHasChildren&lt;C extends ChildHasParent&gt;{
              List&lt;C&gt; getChildren();
              void addChild(C child);
              void removeChild(C child);
            }

            /** generic interface implemented by children */
            interface ChildHasParent&lt;P extends ParentHasChildren&gt;{
              P getParent();
              void setParent(P parent);
            }
          
            /** ensure the parent type implements ParentHasChildren&lt;child type&gt; */
            declare parents: Parent implements ParentHasChildren&lt;Child&gt;;
          
            /** ensure the child type implements ChildHasParent&lt;parent type&gt; */
            declare parents: Child implements ChildHasParent&lt;Parent&gt;;
          
            // Inter-type declarations made on the *generic* interface types to provide 
            // default implementations.
          
            /** list of children maintained by parent */
            private List&lt;C&gt; ParentHasChildren&lt;C&gt;.children = new ArrayList&lt;C&gt;();
          
            /** reference to parent maintained by child */        
            private P ChildHasParent&lt;P&gt;.parent;
          
            /** Default implementation of getChildren for the generic type ParentHasChildren */
            public List&lt;C&gt; ParentHasChildren&lt;C&gt;.getChildren() {
                  return Collections.unmodifiableList(children);  
            }
          
            /** Default implementation of getParent for the generic type ChildHasParent */    
            public P ChildHasParent&lt;P&gt;.getParent() {
                 return parent;
            }
          
            /** 
              * Default implementation of addChild, ensures that parent of child is
              * also updated.
              */ 
            public void ParentHasChildren&lt;C&gt;.addChild(C child) {
                 if (child.parent != null) {
                   child.parent.removeChild(child);
                 }
                 children.add(child);
                 child.parent = this;
              }
          
             /**
               * Default implementation of removeChild, ensures that parent of
               * child is also updated.
               */
             public void ParentHasChildren&lt;C&gt;.removeChild(C child) {
                 if (children.remove(child)) {
                   child.parent = null;
                 }
              }
          
              /**
                * Default implementation of setParent for the generic type ChildHasParent.
                * Ensures that this child is added to the children of the parent too.
                */
              public void ChildHasParent&lt;P&gt;.setParent(P parent) {
                 parent.addChild(this);
              }
          
              /**
                * Matches at an addChild join point for the parent type P and child type C
                */    
              public pointcut addingChild(Parent p, Child c) :
                execution(* ParentHasChildren.addChild(ChildHasParent)) &amp;&amp; this(p) &amp;&amp; args(c);
                
              /**
                * Matches at a removeChild join point for the parent type P and child type C
                */    
              public pointcut removingChild(Parent p, Child c) :
                execution(* ParentHasChildren.removeChild(ChildHasParent)) &amp;&amp; this(p) &amp;&amp; args(c);

          }
          
		</pre><p>
          The example aspect captures the protocol for managing a bi-directional parent-child relationship between
          any two types playing the role of parent and child. In a compiler implementation managing an abstract syntax
          tree (AST) in which AST nodes may contain other AST nodes we could declare the concrete aspect:
        </p><pre class="programlisting">
            public aspect ASTNodeContainment extends ParentChildRelationship&lt;ASTNode,ASTNode&gt; {
                
                before(ASTNode parent, ASTNode child) : addingChild(parent, child) {
                  ...
                }
                
            }
		</pre><p>
           As a result of this declaration, <code class="literal">ASTNode</code> gains members:
         </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="literal">List&lt;ASTNode&gt; children</code></td></tr><tr><td><code class="literal">ASTNode parent</code></td></tr><tr><td><code class="literal">List&lt;ASTNode&gt;getChildren()</code></td></tr><tr><td><code class="literal">ASTNode getParent()</code></td></tr><tr><td><code class="literal">void addChild(ASTNode child)</code></td></tr><tr><td><code class="literal">void removeChild(ASTNode child)</code></td></tr><tr><td><code class="literal">void setParent(ASTNode parent)</code></td></tr></table><p>
           In a system managing orders, we could declare the concrete aspect:
         </p><pre class="programlisting">
            public aspect OrderItemsInOrders extends ParentChildRelationship&lt;Order,OrderItem&gt; {
                                
            }
		</pre><p>
           As a result of this declaration, <code class="literal">Order</code> gains members:
         </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="literal">List&lt;OrderItem&gt; children</code></td></tr><tr><td><code class="literal">List&lt;OrderItem&gt; getChildren()</code></td></tr><tr><td><code class="literal">void addChild(OrderItem child)</code></td></tr><tr><td><code class="literal">void removeChild(OrderItem child)</code></td></tr></table><p>and <code class="literal">OrderItem</code> gains members:</p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="literal">Order parent</code></td></tr><tr><td><code class="literal">Order getParent()</code></td></tr><tr><td><code class="literal">void setParent(Order parent)</code></td></tr></table><p>A second example of an abstract aspect, this time for handling exceptions in a uniform
         manner, is shown below:</p><pre class="programlisting">
       abstract aspect ExceptionHandling&lt;T extends Throwable&gt; {
	
	        /**
	         * method to be implemented by sub-aspects to handle thrown exceptions
	         */
        	protected abstract void onException(T anException);
        	
        	/**
        	 * to be defined by sub-aspects to specify the scope of exception handling
        	 */
        	protected abstract pointcut inExceptionHandlingScope();
        	
        	/**
        	 * soften T within the scope of the aspect
        	 */
        	declare soft: T : inExceptionHandlingScope();
        	
        	/**
        	 * bind an exception thrown in scope and pass it to the handler
        	 */
        	after() throwing (T anException) : inExceptionHandlingScope() {
        		onException(anException);
        	}
        	
      }
      </pre><p>Notice how the type variable <code class="literal">T extends Throwable</code> allows the
      components of the aspect to be designed to work together in a type-safe manner. The
      following concrete sub-aspect shows how the abstract aspect might be extended to 
      handle <code class="literal">IOExceptions</code>.</p><pre class="programlisting">
        public aspect IOExceptionHandling extends ExceptionHandling&lt;IOException&gt;{
        	
        	protected pointcut inExceptionHandlingScope() :
        		call(* doIO*(..)) &amp;&amp; within(org.xyz..*);
        	
        	/**
        	 * called whenever an IOException is thrown in scope.
        	 */
        	protected void onException(IOException ex) {
        		System.err.println("handled exception: " + ex.getMessage());
        		throw new MyDomainException(ex);
        	}
         }
      </pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="generics.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="generics.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="autoboxing.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. Generics </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 4. Autoboxing and Unboxing</td></tr></table></div></body></html>
