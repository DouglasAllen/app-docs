<html lang="en">
<head>
<title>graph - Asymptote: the Vector Graphics Language</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Asymptote: the Vector Graphics Language">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Base-modules.html#Base-modules" title="Base modules">
<link rel="prev" href="CAD.html#CAD" title="CAD">
<link rel="next" href="palette.html#palette" title="palette">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This file documents `Asymptote', version 2.15.

`http://asymptote.sourceforge.net'

Copyright (C) 2004-11 Andy Hammerlindl, John Bowman, and Tom Prince.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Lesser General Public License.
     On Debian systems, the LGPL can be found at
     /usr/share/common-licenses/LGPL.

   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="graph"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="palette.html#palette">palette</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="CAD.html#CAD">CAD</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Base-modules.html#Base-modules">Base modules</a>
<hr>
</div>

<h3 class="section">8.27 <code>graph</code></h3>

<p><a name="index-g_t_0040code_007bgraph_007d-904"></a><a name="index-g_t2D-graphs-905"></a>This package implements two-dimensional linear and logarithmic graphs,
including automatic scale and tick selection (with the ability to
override manually). A graph is a <code>guide</code> (that can be drawn with
the draw command, with an optional legend) constructed with one of
the following routines:

     <ul>
<li><pre class="verbatim">     guide graph(picture pic=currentpicture, real f(real), real a, real b,
                 int n=ngraph, real T(real)=identity,
                 interpolate join=operator --);
     guide[] graph(picture pic=currentpicture, real f(real), real a, real b,
                  int n=ngraph, real T(real)=identity, bool3 cond(real),
                  interpolate join=operator --);
</pre>

     <p>Returns a graph using the scaling information for picture <code>pic</code>
(see <a href="automatic-scaling.html#automatic-scaling">automatic scaling</a>) of the function <code>f</code> on the interval
[<code>T</code>(<code>a</code>),<code>T</code>(<code>b</code>)], sampling at <code>n</code> points
evenly spaced in [<code>a</code>,<code>b</code>], optionally restricted by the
bool3 function <code>cond</code> on [<code>a</code>,<code>b</code>]. If <code>cond</code> is:
          <ul>
<li><code>true</code>, the point is added to the existing guide;
<li><code>default</code>, the point is added to a new guide;
<li><code>false</code>, the point is omitted and a new guide is begun. 
</ul>
     The points are connected using the interpolation specified by <code>join</code>:
          
<a name="index-g_t_0040code_007boperator-_002d_002d_007d-906"></a>
<a name="index-g_t_0040code_007bStraight_007d-907"></a>
<ul><li><code>operator --</code> (linear interpolation; the abbreviation
<code>Straight</code> is also accepted);

          <p><a name="index-g_t_0040code_007boperator-_002e_002e_007d-908"></a><a name="index-g_t_0040code_007bSpline_007d-909"></a><li><code>operator ..</code> (piecewise Bezier cubic spline interpolation;
the abbreviation <code>Spline</code> is also accepted);

          <p><a name="index-g_t_0040code_007bHermite_007d-910"></a><a name="index-g_t_0040code_007bnotaknot_007d-911"></a><a name="index-g_t_0040code_007bnatural_007d-912"></a><a name="index-g_t_0040code_007bperiodic_007d-913"></a><a name="index-g_t_0040code_007bclamped_007d-914"></a><a name="index-g_t_0040code_007bmonotonic_007d-915"></a><a name="index-g_t_0040code_007bHermite_0028splinetype-splinetype_007d-916"></a><li><code>Hermite</code> (standard cubic spline interpolation using boundary
condition <code>notaknot</code>, <code>natural</code>,  <code>periodic</code>,
<code>clamped(real slopea, real slopeb)</code>), or <code>monotonic</code>. 
The abbreviation <code>Hermite</code> is equivalent to
<code>Hermite(notaknot)</code> for nonperiodic data and
<code>Hermite(periodic)</code> for periodic data).

     </ul>

     <li><pre class="verbatim">     guide graph(picture pic=currentpicture, real x(real), real y(real),
                 real a, real b, int n=ngraph, real T(real)=identity,
                 interpolate join=operator --);
     guide[] graph(picture pic=currentpicture, real x(real), real y(real),
                   real a, real b, int n=ngraph, real T(real)=identity,
                   bool3 cond(real), interpolate join=operator --);
</pre>

     <p>Returns a graph using the scaling information for picture <code>pic</code>
of the parametrized function
(<code>x</code>(t),<code>y</code>(t)) for t in the interval
[<code>T</code>(<code>a</code>),<code>T</code>(<code>b</code>)], sampling at <code>n</code> points
evenly spaced in [<code>a</code>,<code>b</code>], optionally restricted by the
bool3 function <code>cond</code> on [<code>a</code>,<code>b</code>], using the given
interpolation type.

     <li><pre class="verbatim">     guide graph(picture pic=currentpicture, pair z(real), real a, real b,
                 int n=ngraph, real T(real)=identity,
                 interpolate join=operator --);
     guide[] graph(picture pic=currentpicture, pair z(real), real a, real b,
                   int n=ngraph, real T(real)=identity, bool3 cond(real),
                   interpolate join=operator --);
</pre>

     <p>Returns a graph using the scaling information for picture <code>pic</code>
of the parametrized function
<code>z</code>(t) for t in the interval
[<code>T</code>(<code>a</code>),<code>T</code>(<code>b</code>)], sampling at <code>n</code> points
evenly spaced in [<code>a</code>,<code>b</code>], optionally restricted by the
bool3 function <code>cond</code> on [<code>a</code>,<code>b</code>], using the given
interpolation type.

     <li><pre class="verbatim">     guide graph(picture pic=currentpicture, pair[] z,
                 interpolate join=operator --);
     guide[] graph(picture pic=currentpicture, pair[] z, bool3[] cond,
                   interpolate join=operator --);
</pre>

     <p>Returns a graph using the scaling information for picture <code>pic</code>
of the elements of the array <code>z</code>, optionally restricted to
those indices for which the elements of the boolean array <code>cond</code> are
<code>true</code>, using the given interpolation type.

     <li><pre class="verbatim">     guide graph(picture pic=currentpicture, real[] x, real[] y,
                 interpolate join=operator --);
     guide[] graph(picture pic=currentpicture, real[] x, real[] y,
                   bool3[] cond, interpolate join=operator --);
</pre>

     <p>Returns a graph using the scaling information for picture <code>pic</code>
of the elements of the arrays (<code>x</code>,<code>y</code>), optionally
restricted to those indices for which the elements of the boolean
array <code>cond</code> are <code>true</code>, using the given interpolation type.

     <li><a name="index-g_t_0040code_007bpolargraph_007d-917"></a><pre class="verbatim">     guide polargraph(picture pic=currentpicture, real f(real), real a,
                      real b, int n=ngraph, interpolate join=operator --);
</pre>

     <p>Returns a polar-coordinate graph using the scaling information for
picture <code>pic</code> of the function <code>f</code> on the interval
[<code>a</code>,<code>b</code>], sampling at <code>n</code> evenly spaced points, with
the given interpolation type.

     <li><pre class="verbatim">     guide polargraph(picture pic=currentpicture, real[] r, real[] theta,
                      interpolate join=operator--);
</pre>
Returns a polar-coordinate graph using the scaling information for
picture <code>pic</code> of the elements of the arrays (<code>r</code>,<code>theta</code>),
using the given interpolation type.

   </ul>

<pre class="verbatim">

</pre>

   <p>An axis can be drawn on a picture with one of the following commands:

     <ul>
<li><pre class="verbatim">     void xaxis(picture pic=currentpicture, Label L="", axis axis=YZero,
                real xmin=-infinity, real xmax=infinity, pen p=currentpen, 
                ticks ticks=NoTicks, arrowbar arrow=None, bool above=false);
</pre>

     <p>Draw an x axis on picture <code>pic</code> from x=<code>xmin</code> to
x=<code>xmax</code> using pen <code>p</code>, optionally labelling it with
Label <code>L</code>. The relative label location along the axis (a real number from
[0,1]) defaults to 1 (see <a href="Label.html#Label">Label</a>), so that the label is drawn at the
end of the axis. An infinite value of <code>xmin</code>
or <code>xmax</code> specifies that the corresponding axis limit will be
automatically determined from the picture limits. 
The optional <code>arrow</code> argument takes the same values as in the
<code>draw</code> command (see <a href="arrows.html#arrows">arrows</a>). The axis is drawn before any
existing objects in <code>pic</code> unless <code>above=true</code>. 
The axis placement is determined by one of the following <code>axis</code> types:

          
<a name="index-g_t_0040code_007bYZero_007d-918"></a>
<dl><dt><code>YZero(bool extend=true)</code><dd>Request an x axis at y=0 (or y=1 on a logarithmic axis)
extending to the full dimensions of the picture, unless <code>extend</code>=false.

          <p><a name="index-g_t_0040code_007bYEquals_007d-919"></a><br><dt><code>YEquals(real Y, bool extend=true)</code><dd>Request an x axis at y=<code>Y</code> extending to the full
dimensions of the picture, unless <code>extend</code>=false.

          <p><a name="index-g_t_0040code_007bBottom_007d-920"></a><br><dt><code>Bottom(bool extend=false)</code><dd>Request a bottom axis.

          <p><a name="index-g_t_0040code_007bTop_007d-921"></a><br><dt><code>Top(bool extend=false)</code><dd>Request a top axis.

          <p><a name="index-g_t_0040code_007bBottomTop_007d-922"></a><br><dt><code>BottomTop(bool extend=false)</code><dd>Request a bottom and top axis.

     </dl>

     <p><a name="index-custom-axis-types-923"></a>Custom axis types can be created by following the examples in <code>graph.asy</code>. 
One can easily override the default values for the standard axis types:
<pre class="verbatim">     import graph;
     
     YZero=new axis(bool extend=true) {
       return new void(picture pic, axisT axis) {
         real y=pic.scale.x.scale.logarithmic ? 1 : 0;
         axis.value=I*pic.scale.y.T(y);
         axis.position=1;
         axis.side=right;
         axis.align=2.5E;
         axis.value2=Infinity;
         axis.extend=extend;
       };
     };
     YZero=YZero();
     
</pre>

     <p><a name="ticks"></a><a name="index-g_t_0040code_007bticks_007d-924"></a><a name="index-g_t_0040code_007bNoTicks_007d-925"></a><a name="index-g_t_0040code_007bLeftTicks_007d-926"></a><a name="index-g_t_0040code_007bRightTicks_007d-927"></a><a name="index-g_t_0040code_007bTicks_007d-928"></a>The default tick option is <code>NoTicks</code>. 
The options <code>LeftTicks</code>, <code>RightTicks</code>, or <code>Ticks</code> can be
used to draw ticks on the left, right, or both sides of the path,
relative to the direction in which the path is drawn. 
These tick routines accept a number of optional arguments:
<pre class="verbatim">     ticks LeftTicks(Label format="", ticklabel ticklabel=null,
                     bool beginlabel=true, bool endlabel=true,
                     int N=0, int n=0, real Step=0, real step=0,
                     bool begin=true, bool end=true, tickmodifier modify=None,
                     real Size=0, real size=0, bool extend=false,
                     pen pTick=nullpen, pen ptick=nullpen);
</pre>

     <p>If any of these parameters are omitted, reasonable defaults will
be chosen:
          <dl>
<dt><code>Label format</code><dd><a name="index-g_t_0040code_007bdefaultformat_007d-929"></a><a name="index-g_t_0040code_007btrailingzero_007d-930"></a>override the default tick label format (<code>defaultformat</code>, initially
"$%.4g$"), rotation, pen, and alignment (for example, <code>LeftSide</code>,
<code>Center</code>, or <code>RightSide</code>) relative to the axis. To enable
<code>LaTeX</code> math mode fonts, the format string should begin and
end with <code>$</code> see <a href="format.html#format">format</a>. If the format string is <code>trailingzero</code>,
trailing zeros will be added to the tick labels; if the format string is
<code>"%"</code>, the tick label will be suppressed;
<br><dt><code>ticklabel</code><dd>is a function <code>string(real x)</code> returning the label (by default,
format(format.s,x)) for each major tick value <code>x</code>;
<br><dt><code>bool beginlabel</code><dd>include the first label;
<br><dt><code>bool endlabel</code><dd>include the last label;
<br><dt><code>int N</code><dd>when automatic scaling is enabled (the default; see <a href="automatic-scaling.html#automatic-scaling">automatic scaling</a>),
divide a linear axis evenly into this many intervals, separated by major ticks;
for a logarithmic axis, this is the number of decades between labelled ticks;
<br><dt><code>int n</code><dd>divide each interval into this many subintervals, separated by minor ticks;
<br><dt><code>real Step</code><dd>the tick value spacing between major ticks
(if <code>N</code>=<code>0</code>);
<br><dt><code>real step</code><dd>the tick value spacing between minor ticks (if <code>n</code>=<code>0</code>);
<br><dt><code>bool begin</code><dd>include the first major tick;
<br><dt><code>bool end</code><dd>include the last major tick;
<br><dt><code>tickmodifier modify;</code><dd>an optional function that takes and returns a <code>tickvalue</code> structure having
real[] members <code>major</code> and <code>minor</code> consisting of the tick values
(to allow modification of the automatically generated tick values);
<br><dt><code>real Size</code><dd>the size of the major ticks (in <code>PostScript</code> coordinates);
<br><dt><code>real size</code><dd>the size of the minor ticks (in <code>PostScript</code> coordinates);
<br><dt><code>bool extend;</code><dd>extend the ticks between two axes (useful for drawing a grid on the graph);
<br><dt><code>pen pTick</code><dd>an optional pen used to draw the major ticks;
<br><dt><code>pen ptick</code><dd>an optional pen used to draw the minor ticks.

     </dl>

     <p><a name="index-g_t_0040code_007bOmitTick_007d-931"></a><a name="index-g_t_0040code_007bOmitTickInterval_007d-932"></a><a name="index-g_t_0040code_007bOmitTickIntervals_007d-933"></a>For convenience, the predefined tickmodifiers <code>OmitTick(... real[] x)</code>,
<code>OmitTickInterval(real a, real b)</code>, and
<code>OmitTickIntervals(real[] a, real[] b)</code>
can be used to remove specific auto-generated ticks and
their labels. The <code>OmitFormat(string s=defaultformat ... real[] x)</code>
ticklabel can be used to remove specific tick labels but not the
corresponding ticks. The tickmodifier <code>NoZero</code> is an abbreviation for
<code>OmitTick(0)</code> and the ticklabel <code>NoZeroFormat</code> is an
abbrevation for <code>OmitFormat(0)</code>.

     <p><a name="index-custom-tick-locations-934"></a><a name="index-g_t_0040code_007bLeftTicks_007d-935"></a><a name="index-g_t_0040code_007bRightTicks_007d-936"></a><a name="index-g_t_0040code_007bTicks_007d-937"></a>It is also possible to specify custom tick locations with
<code>LeftTicks</code>, <code>RightTicks</code>, and <code>Ticks</code> by passing explicit real
arrays <code>Ticks</code> and (optionally) <code>ticks</code> containing the
locations of the major and minor ticks, respectively:
<pre class="verbatim">     ticks LeftTicks(Label format="", ticklabel ticklabel=null, 
                     bool beginlabel=true, bool endlabel=true, 
                     real[] Ticks, real[] ticks=new real[],
                     real Size=0, real size=0, bool extend=false,
                     pen pTick=nullpen, pen ptick=nullpen)
</pre>

     <li><pre class="verbatim">     void yaxis(picture pic=currentpicture, Label L="", axis axis=XZero,
                real ymin=-infinity, real ymax=infinity, pen p=currentpen,
                ticks ticks=NoTicks, arrowbar arrow=None, bool above=false,
                bool autorotate=true);
</pre>

     <p>Draw a y axis on picture <code>pic</code> from y=<code>ymin</code> to
y=<code>ymax</code> using pen <code>p</code>, optionally labelling it with
a Label <code>L</code> that is autorotated unless <code>autorotate=false</code>. 
The relative location of the label (a real number from
[0,1]) defaults to 1 (see <a href="Label.html#Label">Label</a>). An infinite value of <code>ymin</code>
or <code>ymax</code> specifies that the corresponding axis limit will be
automatically determined from the picture limits. 
The optional <code>arrow</code> argument takes the same values as in the
<code>draw</code> command (see <a href="arrows.html#arrows">arrows</a>). The axis is drawn before any
existing objects in <code>pic</code> unless <code>above=true</code>. 
The tick type is specified by <code>ticks</code> and the axis placement is
determined by one of the following <code>axis</code> types:

          
<a name="index-g_t_0040code_007bXZero_007d-938"></a>
<dl><dt><code>XZero(bool extend=true)</code><dd>Request a y axis at x=0 (or x=1 on a logarithmic axis)
extending to the full dimensions of the picture, unless <code>extend</code>=false.

          <p><a name="index-g_t_0040code_007bXEquals_007d-939"></a><br><dt><code>XEquals(real X, bool extend=true)</code><dd>Request a y axis at x=<code>X</code> extending to the full
dimensions of the picture, unless <code>extend</code>=false.

          <p><a name="index-g_t_0040code_007bLeft_007d-940"></a><br><dt><code>Left(bool extend=false)</code><dd>Request a left axis.

          <p><a name="index-g_t_0040code_007bRight_007d-941"></a><br><dt><code>Right(bool extend=false)</code><dd>Request a right axis.

          <p><a name="index-g_t_0040code_007bLeftRight_007d-942"></a><br><dt><code>LeftRight(bool extend=false)</code><dd>Request a left and right axis.

     </dl>

     <li><a name="index-g_t_0040code_007bxequals_007d-943"></a><a name="index-g_t_0040code_007byequals_007d-944"></a>For convenience, the functions
<pre class="verbatim">     void xequals(picture pic=currentpicture, Label L="", real x,
                  bool extend=false, real ymin=-infinity, real ymax=infinity,
                  pen p=currentpen, ticks ticks=NoTicks, bool above=true,
                  arrowbar arrow=None);
</pre>
and
<pre class="verbatim">     void yequals(picture pic=currentpicture, Label L="", real y,
                  bool extend=false, real xmin=-infinity, real xmax=infinity,
                  pen p=currentpen, ticks ticks=NoTicks, bool above=true,
                  arrowbar arrow=None);
</pre>
can be respectively used to call <code>yaxis</code> and
<code>xaxis</code> with the appropriate axis types <code>XEquals(x,extend)</code> and
<code>YEquals(y,extend)</code>. This is the recommended way of drawing vertical
or horizontal lines and axes at arbitrary locations.

     <li><pre class="verbatim">     void axes(picture pic=currentpicture, Label xlabel="", Label ylabel="",
               pair min=(-infinity,-infinity), pair max=(infinity,infinity),
               pen p=currentpen, arrowbar arrow=None, bool above=false);
</pre>
This convenience routine draws both x and y axes
on picture <code>pic</code> from <code>min</code> to <code>max</code>,
with optional labels <code>xlabel</code> and <code>ylabel</code>
and any arrows specified by <code>arrow</code>. The axes are drawn on top of
existing objects in <code>pic</code> only if <code>above=true</code>.

     <li><pre class="verbatim">     void axis(picture pic=currentpicture, Label L="", path g,
               pen p=currentpen, ticks ticks, ticklocate locate,
               arrowbar arrow=None, int[] divisor=new int[],
               bool above=false, bool opposite=false);
</pre>

     <p>This routine can be used to draw on picture <code>pic</code> a general axis
based on an arbitrary path <code>g</code>, using pen <code>p</code>. 
One can optionally label the axis with Label <code>L</code> and add an arrow
<code>arrow</code>. The tick type is given by <code>ticks</code>. 
The optional integer array <code>divisor</code> specifies what tick divisors
to try in the attempt to produce uncrowded tick labels. A <code>true</code>
value for the flag <code>opposite</code> identifies an unlabelled secondary
axis (typically drawn opposite a primary axis). The axis is drawn before
any existing objects in <code>pic</code> unless <code>above=true</code>. 
The tick locator <code>ticklocate</code> is constructed by the routine
<pre class="verbatim">     ticklocate ticklocate(real a, real b, autoscaleT S=defaultS,
                           real tickmin=-infinity, real tickmax=infinity,
                           real time(real)=null, pair dir(real)=zero);
</pre>
     where <code>a</code> and <code>b</code> specify the respective tick values at
<code>point(g,0)</code> and <code>point(g,length(g))</code>, <code>S</code> specifies
the autoscaling transformation, the function <code>real time(real v)</code>
returns the time corresponding to the value <code>v</code>, and
<code>pair dir(real t)</code> returns the absolute tick direction as a
function of <code>t</code> (zero means draw the tick perpendicular to the axis).

     <li>These routines are useful for manually putting ticks and labels on axes
(if the variable <code>Label</code> is given as the <code>Label</code>
argument, the <code>format</code> argument will be used to format a string based on
the tick location):
<a name="index-xtick-945"></a><a name="index-ytick-946"></a><a name="index-labelx-947"></a><a name="index-labely-948"></a><a name="index-tick-949"></a><a name="index-Label-950"></a><pre class="verbatim">     void xtick(picture pic=currentpicture, Label L="", explicit pair z,
                pair dir=N, string format="",
                real size=Ticksize, pen p=currentpen);
     void xtick(picture pic=currentpicture, Label L="", real x,
                pair dir=N, string format="",
                real size=Ticksize, pen p=currentpen);
     void ytick(picture pic=currentpicture, Label L="", explicit pair z,
                pair dir=E, string format="",
                real size=Ticksize, pen p=currentpen);
     void ytick(picture pic=currentpicture, Label L="", real y,
                pair dir=E, string format="",
                real size=Ticksize, pen p=currentpen);
     void tick(picture pic=currentpicture, pair z,
               pair dir, real size=Ticksize, pen p=currentpen);
     void labelx(picture pic=currentpicture, Label L="", explicit pair z,
                 align align=S, string format="", pen p=nullpen);
     void labelx(picture pic=currentpicture, Label L="", real x,
                 align align=S, string format="", pen p=nullpen);
     void labelx(picture pic=currentpicture, Label L,
                 string format="", explicit pen p=currentpen);
     void labely(picture pic=currentpicture, Label L="", explicit pair z,
                 align align=W, string format="", pen p=nullpen);
     void labely(picture pic=currentpicture, Label L="", real y,
                 align align=W, string format="", pen p=nullpen);
     void labely(picture pic=currentpicture, Label L,
                 string format="", explicit pen p=nullpen);
</pre>
</ul>

   <p>Here are some simple examples of two-dimensional graphs:

     <ol type=1 start=1>

     <p><a name="index-textbook-graph-951"></a><li>This example draws a textbook-style graph of
y= exp(x), with the y axis starting at y=0:
<pre class="verbatim">     import graph;
     size(150,0);
     
     real f(real x) {return exp(x);}
     pair F(real x) {return (x,f(x));}
     
     xaxis("$x$");
     yaxis("$y$",0);
     
     draw(graph(f,-4,2,operator ..),red);
     
     labely(1,E);
     label("$e^x$",F(1),SE);
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="exp.png" alt="exp.png"></div>

     <li>The next example draws a scientific-style graph with a legend. 
The position of the legend can be adjusted either explicitly or by using the
graphical user interface <code>xasy</code> (see <a href="GUI.html#GUI">GUI</a>). If an
<code>UnFill(real xmargin=0, real ymargin=xmargin)</code> or
<code>Fill(pen)</code> option is specified to <code>add</code>, the legend will obscure
any underlying objects. Here we illustrate how to clip the portion of
the picture covered by a label:

     <p><a name="index-scientific-graph-952"></a><pre class="verbatim">     import graph;
     
     size(400,200,IgnoreAspect);
     
     real Sin(real t) {return sin(2pi*t);}
     real Cos(real t) {return cos(2pi*t);}
     
     draw(graph(Sin,0,1),red,"$\sin(2\pi x)$");
     draw(graph(Cos,0,1),blue,"$\cos(2\pi x)$");
     
     xaxis("$x$",BottomTop,LeftTicks);
     yaxis("$y$",LeftRight,RightTicks(trailingzero));
     
     label("LABEL",point(0),UnFill(1mm));
     
     add(legend(),point(E),20E,UnFill);
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="lineargraph0.png" alt="lineargraph0.png"></div>

     <p><a name="index-g_t_0040code_007battach_007d-953"></a>To specify a fixed size for the graph proper, use <code>attach</code>:
<pre class="verbatim">     import graph;
     
     size(250,200,IgnoreAspect);
     
     real Sin(real t) {return sin(2pi*t);}
     real Cos(real t) {return cos(2pi*t);}
     
     draw(graph(Sin,0,1),red,"$\sin(2\pi x)$");
     draw(graph(Cos,0,1),blue,"$\cos(2\pi x)$");
     
     xaxis("$x$",BottomTop,LeftTicks);
     yaxis("$y$",LeftRight,RightTicks(trailingzero));
     
     label("LABEL",point(0),UnFill(1mm));
     
     attach(legend(),truepoint(E),20E,UnFill);
</pre>
<a name="index-g_t_0040code_007blegend_007d-954"></a>A legend can have multiple entries per line:
<pre class="verbatim">     import graph; 
     size(8cm,6cm,IgnoreAspect); 
      
     typedef real realfcn(real); 
     realfcn F(real p) { 
       return new real(real x) {return sin(p*x);}; 
     }; 
      
     for(int i=1; i &lt; 5; ++i)
       draw(graph(F(i*pi),0,1),Pen(i),
            "$\sin("+(i == 1 ? "" : (string) i)+"\pi x)$"); 
     xaxis("$x$",BottomTop,LeftTicks); 
     yaxis("$y$",LeftRight,RightTicks(trailingzero)); 
      
     attach(legend(2),(point(S).x,truepoint(S).y),10S,UnFill); 
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="legend.png" alt="legend.png"></div>

     <li>This example draws a graph of one array versus another (both of
the same size) using custom tick locations and a smaller font size for
the tick labels on the y axis. 
<pre class="verbatim">     import graph;
     
     size(200,150,IgnoreAspect);
     
     real[] x={0,1,2,3};
     real[] y=x^2;
     
     draw(graph(x,y),red);
     
     xaxis("$x$",BottomTop,LeftTicks);
     yaxis("$y$",LeftRight,
           RightTicks(Label(fontsize(8pt)),new real[]{0,4,9}));
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="datagraph.png" alt="datagraph.png"></div>

     <li>This example shows how to graph columns of data read from a file. 
<pre class="verbatim">     import graph;
     
     size(200,150,IgnoreAspect);
     
     file in=input("filegraph.dat").line();
     real[][] a=in.dimension(0,0);
     a=transpose(a);
     
     real[] x=a[0];
     real[] y=a[1];
     
     draw(graph(x,y),red);
     
     xaxis("$x$",BottomTop,LeftTicks);
     yaxis("$y$",LeftRight,RightTicks);
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="filegraph.png" alt="filegraph.png"></div>

     <p><a name="index-g_t_0040code_007bpolygon_007d-955"></a><a name="index-g_t_0040code_007bcross_007d-956"></a><a name="index-g_t_0040code_007berrorbars_007d-957"></a><a name="index-g_t_0040code_007bmarker_007d-958"></a><a name="index-g_t_0040code_007bmarknodes_007d-959"></a><a name="index-g_t_0040code_007bmarkuniform_007d-960"></a><a name="index-g_t_0040code_007bmark_007d-961"></a><a name="index-path-markers-962"></a><a name="pathmarkers"></a><li>The next example draws two graphs of an array of coordinate pairs,
using frame alignment and data markers. In the left-hand graph, the
markers, constructed with
<pre class="verbatim">     marker marker(path g, markroutine markroutine=marknodes, 
                   pen p=currentpen, filltype filltype=NoFill,
                   bool above=true);
</pre>
using the path <code>unitcircle</code> (see <a href="filltype.html#filltype">filltype</a>), are drawn
below each node. Any frame can be converted to a marker, using
<a name="marker"></a><pre class="verbatim">     marker marker(frame f, markroutine markroutine=marknodes,
                   bool above=true);
</pre>
In the right-hand graph, the unit n-sided regular polygon
<code>polygon(int n)</code> and the unit n-point cyclic cross
<code>cross(int n, bool round=true, real r=0)</code> (where <code>r</code> is an
optional &ldquo;inner&rdquo; radius) are used to build a custom marker frame. 
<a name="markuniform"></a>Here <code>markuniform(bool centered=false, int n, bool rotated=false)</code>
adds this frame at <code>n</code> uniformly spaced points along the arclength
of the path, optionally rotated by the angle of the local tangent to the path
(if centered is true, the frames will be centered within <code>n</code> evenly
spaced arclength intervals). Alternatively, one can use
markroutine <code>marknodes</code> to request that the marks be placed at each
Bezier node of the path, or
markroutine <code>markuniform(pair z(real t), real a, real b, int n)</code>
to place marks at points <code>z(t)</code> for n evenly spaced values of
<code>t</code> in <code>[a,b]</code>.

     <p>These markers are predefined:
<pre class="verbatim">     marker[] Mark={
       marker(scale(circlescale)*unitcircle),
       marker(polygon(3)),marker(polygon(4)),
       marker(polygon(5)),marker(invert*polygon(3)),
       marker(cross(4)),marker(cross(6))
     };
     
     marker[] MarkFill={
       marker(scale(circlescale)*unitcircle,Fill),marker(polygon(3),Fill),
       marker(polygon(4),Fill),marker(polygon(5),Fill),
       marker(invert*polygon(3),Fill)
     };
</pre>

     <p>The example also illustrates the <code>errorbar</code> routines:

     <pre class="verbatim">     void errorbars(picture pic=currentpicture, pair[] z, pair[] dp,
                    pair[] dm={}, bool[] cond={}, pen p=currentpen,
                    real size=0);
     
     void errorbars(picture pic=currentpicture, real[] x, real[] y,
                    real[] dpx, real[] dpy, real[] dmx={}, real[] dmy={},
                    bool[] cond={}, pen p=currentpen, real size=0);
</pre>

     <p class="noindent">Here, the positive and negative extents of the error are given by the
absolute values of the elements of the pair array <code>dp</code> and the
optional pair array <code>dm</code>. If <code>dm</code> is not specified, the
positive and negative extents of the error are assumed to be equal. 
<a name="errorbars"></a><a name="index-error-bars-963"></a><pre class="verbatim">     import graph;
     
     picture pic;
     real xsize=200, ysize=140;
     size(pic,xsize,ysize,IgnoreAspect);
     
     pair[] f={(5,5),(50,20),(90,90)};
     pair[] df={(0,0),(5,7),(0,5)};
     
     errorbars(pic,f,df,red);
     draw(pic,graph(pic,f),"legend",
          marker(scale(0.8mm)*unitcircle,red,FillDraw(blue),above=false));
     
     scale(pic,true);
     
     xaxis(pic,"$x$",BottomTop,LeftTicks);
     yaxis(pic,"$y$",LeftRight,RightTicks);
     add(pic,legend(pic),point(pic,NW),20SE,UnFill);
     
     picture pic2;
     size(pic2,xsize,ysize,IgnoreAspect);
     
     frame mark;
     filldraw(mark,scale(0.8mm)*polygon(6),green,green);
     draw(mark,scale(0.8mm)*cross(6),blue);
     
     draw(pic2,graph(pic2,f),marker(mark,markuniform(5)));
     
     scale(pic2,true);
     
     xaxis(pic2,"$x$",BottomTop,LeftTicks);
     yaxis(pic2,"$y$",LeftRight,RightTicks);
     
     yequals(pic2,55.0,red+Dotted);
     xequals(pic2,70.0,red+Dotted);
     
     // Fit pic to W of origin:
     add(pic.fit(),(0,0),W);
     
     // Fit pic2 to E of (5mm,0):
     add(pic2.fit(),(5mm,0),E);
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="errorbars.png" alt="errorbars.png"></div>

     <p><a name="index-custom-mark-routine-964"></a><li>A custom mark routine can be also be specified:
<pre class="verbatim">     import graph;
     
     size(200,100,IgnoreAspect);
     
     markroutine marks() {
       return new void(picture pic=currentpicture, frame f, path g) {
         path p=scale(1mm)*unitcircle;
         for(int i=0; i &lt;= length(g); ++i) {
           pair z=point(g,i);
           frame f;
           if(i % 4 == 0) {
             fill(f,p);
             add(pic,f,z);
           } else {
             if(z.y > 50) {
               pic.add(new void(frame F, transform t) {
                   path q=shift(t*z)*p;
                   unfill(F,q);
                   draw(F,q);
                 });
             } else {
               draw(f,p);
               add(pic,f,z);
             }
           }
         }
       };
     }
     
     pair[] f={(5,5),(40,20),(55,51),(90,30)};
     
     draw(graph(f),marker(marks()));
     
     scale(true);
     
     xaxis("$x$",BottomTop,LeftTicks);
     yaxis("$y$",LeftRight,RightTicks);
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="graphmarkers.png" alt="graphmarkers.png"></div>

     <li>This example shows how to label an axis with arbitrary strings. 
<pre class="verbatim">     import graph;
     
     size(400,150,IgnoreAspect);
     
     real[] x=sequence(12);
     real[] y=sin(2pi*x/12);
     
     scale(false);
     
     string[] month={"Jan","Feb","Mar","Apr","May","Jun",
                     "Jul","Aug","Sep","Oct","Nov","Dec"};
     
     draw(graph(x,y),red,MarkFill[0]);
     
     xaxis(BottomTop,LeftTicks(new string(real x) {
           return month[round(x % 12)];}));
     yaxis("$y$",LeftRight,RightTicks(4));
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="monthaxis.png" alt="monthaxis.png"></div>

     <li>The next example draws a graph of a parametrized curve. 
<a name="index-parametrized-curve-965"></a><a name="index-cropping-graphs-966"></a><a name="index-g_t_0040code_007bxlimits_007d-967"></a><a name="index-g_t_0040code_007bylimits_007d-968"></a><a name="index-g_t_0040code_007blimits_007d-969"></a><a name="index-g_t_0040code_007bcrop_007d-970"></a>The calls to
<pre class="verbatim">     xlimits(picture pic=currentpicture, real min=-infinity,
             real max=infinity, bool crop=NoCrop);
</pre>
     and the analogous function <code>ylimits</code> can be uncommented
to set the respective axes limits for picture <code>pic</code> to the
specified <code>min</code> and <code>max</code> values. Alternatively, the function
<pre class="verbatim">     void limits(picture pic=currentpicture, pair min, pair max, bool crop=NoCrop);
</pre>
can be used to limit the axes to the box having opposite vertices at
the given pairs). Existing objects in picture <code>pic</code> will be cropped to lie
within the given limits if <code>crop</code>=<code>Crop</code>. The function
<code>crop(picture pic)</code> can be used to crop a graph to the current
graph limits. 
<pre class="verbatim">     import graph;
     
     size(0,200);
     
     real x(real t) {return cos(2pi*t);}
     real y(real t) {return sin(2pi*t);}
     
     draw(graph(x,y,0,1));
     
     //xlimits(0,1,Crop);
     //ylimits(-1,0,Crop);
     
     xaxis("$x$",BottomTop,LeftTicks);
     yaxis("$y$",LeftRight,RightTicks(trailingzero));
     
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="parametricgraph.png" alt="parametricgraph.png"></div>

     <p><a name="index-scaled-graph-971"></a>The next example illustrates how one can extract a common axis scaling
factor. 
<pre class="verbatim">     import graph;
     
     axiscoverage=0.9;
     size(200,IgnoreAspect);
     
     real[] x={-1e-11,1e-11};
     real[] y={0,1e6};
     
     real xscale=round(log10(max(x)));
     real yscale=round(log10(max(y)))-1;
     
     draw(graph(x*10^(-xscale),y*10^(-yscale)),red);
     
     xaxis("$x/10^{"+(string) xscale+"}$",BottomTop,LeftTicks);
     yaxis("$y/10^{"+(string) yscale+"}$",LeftRight,RightTicks(trailingzero));
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="scaledgraph.png" alt="scaledgraph.png"></div>

     <p><a name="automatic-scaling"></a><a name="index-automatic-scaling-972"></a><a name="index-g_t_0040code_007bscale_007d-973"></a><a name="index-g_t_0040code_007bLinear_007d-974"></a><a name="index-g_t_0040code_007bLog_007d-975"></a><a name="index-automatic-scaling-976"></a>Axis scaling can be requested and/or automatic selection of the
axis limits can be inhibited with one of these <code>scale</code> routines:
<pre class="verbatim">     void scale(picture pic=currentpicture, scaleT x, scaleT y);
     
     void scale(picture pic=currentpicture, bool xautoscale=true,
                bool yautoscale=xautoscale, bool zautoscale=yautoscale);
</pre>

     <p>This sets the scalings for picture <code>pic</code>. The <code>graph</code> routines
accept an optional <code>picture</code> argument for determining the appropriate
scalings to use; if none is given, it uses those set for
<code>currentpicture</code>.

     <p>Two frequently used scaling routines
<code>Linear</code> and <code>Log</code> are predefined in <code>graph</code>.

     <p>All picture coordinates (including those in paths and those given
to the <code>label</code> and <code>limits</code> functions) are always treated as linear
(post-scaled) coordinates. Use
<a name="index-g_t_0040code_007bScale_007d-977"></a><pre class="verbatim">     pair Scale(picture pic=currentpicture, pair z);
</pre>
to convert a graph coordinate into a scaled picture coordinate.

     <p>The x and y components can be individually scaled using
the analogous routines
<pre class="verbatim">     real ScaleX(picture pic=currentpicture, real x);
     real ScaleY(picture pic=currentpicture, real y);
</pre>

     <p>The predefined scaling routines can be given two optional boolean arguments:
<code>automin=false</code> and <code>automax=automin</code>. These default to
<code>false</code> but can be respectively set to <code>true</code> to enable
automatic selection of "nice" axis minimum and maximum values. The
<code>Linear</code> scaling can also take as optional final arguments a
multiplicative scaling factor and intercept (e.g. for a depth axis,
<code>Linear(-1)</code> requests axis reversal).

     <p><a name="index-logarithmic-graph-978"></a><a name="index-log_002dlog-graph-979"></a>For example, to draw a log/log graph of a function, use <code>scale(Log,Log)</code>:
<pre class="verbatim">     import graph;
     
     size(200,200,IgnoreAspect);
     
     real f(real t) {return 1/t;}
     
     scale(Log,Log);
     
     draw(graph(f,0.1,10));
     
     //xlimits(1,10,Crop);
     //ylimits(0.1,1,Crop);
     
     dot(Label("(3,5)",align=S),Scale((3,5)));
     
     xaxis("$x$",BottomTop,LeftTicks);
     yaxis("$y$",LeftRight,RightTicks);
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="loggraph.png" alt="loggraph.png"></div>

     <p><a name="index-grid-980"></a>By extending the ticks, one can easily produce a logarithmic grid:
<pre class="verbatim">     import graph;
     size(200,200,IgnoreAspect);
     
     real f(real t) {return 1/t;}
     
     scale(Log,Log);
     draw(graph(f,0.1,10),red);
     pen thin=linewidth(0.5*linewidth());
     xaxis("$x$",BottomTop,LeftTicks(begin=false,end=false,extend=true,
                                     ptick=thin));
     yaxis("$y$",LeftRight,RightTicks(begin=false,end=false,extend=true,
                                      ptick=thin));
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="loggrid.png" alt="loggrid.png"></div>

     <p>One can also specify custom tick locations and formats for logarithmic axes:
<pre class="verbatim">     import graph;
     
     size(300,175,IgnoreAspect);
     scale(Log,Log);
     draw(graph(identity,5,20));
     xlimits(5,20);
     ylimits(1,100);
     xaxis("$M/M_\odot$",BottomTop,LeftTicks(DefaultFormat,
                                             new real[] {6,10,12,14,16,18}));
     yaxis("$\nu_{\rm upp}$ [Hz]",LeftRight,RightTicks(DefaultFormat));
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="logticks.png" alt="logticks.png"></div>

     <p><a name="index-g_t_0040code_007blog2_007d-graph-981"></a>It is easy to draw logarithmic graphs with respect to other bases:
<pre class="verbatim">     import graph;
     size(200,IgnoreAspect);
     
     // Base-2 logarithmic scale on y-axis:
     
     real log2(real x) {static real log2=log(2); return log(x)/log2;}
     real pow2(real x) {return 2^x;}
     
     scaleT yscale=scaleT(log2,pow2,logarithmic=true);
     scale(Linear,yscale);
     
     real f(real x) {return 1+x^2;}
     
     draw(graph(f,-4,4));
     
     yaxis("$y$",ymin=1,ymax=f(5),RightTicks(Label(Fill(white))),EndArrow);
     xaxis("$x$",xmin=-5,xmax=5,LeftTicks,EndArrow);
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="log2graph.png" alt="log2graph.png"></div>

     <p><a name="index-broken-axis-982"></a>Here is an example of "broken" linear x and logarithmic
y axes that omit the segments [3,8] and [100,1000], respectively. 
In the case of a logarithmic axis, the break endpoints are automatically
rounded to the nearest integral power of the base. 
<pre class="verbatim">     import graph;
     
     size(200,150,IgnoreAspect);
     
     // Break the x axis at 3; restart at 8:
     real a=3, b=8;
     
     // Break the y axis at 100; restart at 1000:
     real c=100, d=1000;
     
     scale(Broken(a,b),BrokenLog(c,d));
     
     real[] x={1,2,4,6,10};
     real[] y=x^4;
     
     draw(graph(x,y),red,MarkFill[0]);
     
     xaxis("$x$",BottomTop,LeftTicks(Break(a,b)));
     yaxis("$y$",LeftRight,RightTicks(Break(c,d)));
     
     label(rotate(90)*Break,(a,point(S).y));
     label(rotate(90)*Break,(a,point(N).y));
     label(Break,(point(W).x,ScaleY(c)));
     label(Break,(point(E).x,ScaleY(c)));
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="brokenaxis.png" alt="brokenaxis.png"></div>

     <p><a name="index-secondary-axis-983"></a><a name="index-g_t_0040code_007bsecondaryX_007d-984"></a><a name="index-g_t_0040code_007bsecondaryY_007d-985"></a><li><code>Asymptote</code> can draw secondary axes with the routines
<pre class="verbatim">     picture secondaryX(picture primary=currentpicture, void f(picture));
     picture secondaryY(picture primary=currentpicture, void f(picture));
</pre>

     <p>In this example, <code>secondaryY</code> is used to draw a secondary linear
y axis against a primary logarithmic y axis:
<pre class="verbatim">     import graph;
     texpreamble("\def\Arg{\mathop {\rm Arg}\nolimits}");
     
     size(10cm,5cm,IgnoreAspect);
     
     real ampl(real x) {return 2.5/(1+x^2);}
     real phas(real x) {return -atan(x)/pi;}
     
     scale(Log,Log);
     draw(graph(ampl,0.01,10));
     ylimits(0.001,100);
     
     xaxis("$\omega\tau_0$",BottomTop,LeftTicks);
     yaxis("$|G(\omega\tau_0)|$",Left,RightTicks);
     
     picture q=secondaryY(new void(picture pic) {
         scale(pic,Log,Linear);
         draw(pic,graph(pic,phas,0.01,10),red);
         ylimits(pic,-1.0,1.5);
         yaxis(pic,"$\Arg G/\pi$",Right,red,
               LeftTicks("$% #.1f$",
                         begin=false,end=false));
         yequals(pic,1,Dotted);
       });
     label(q,"(1,0)",Scale(q,(1,0)),red);
     add(q);
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="Bode.png" alt="Bode.png"></div>

     <p>A secondary logarithmic y axis can be drawn like this:
<pre class="verbatim">     import graph;
     
     size(9cm,6cm,IgnoreAspect);
     string data="secondaryaxis.csv";
     
     file in=input(data).line().csv();
     
     string[] titlelabel=in;
     string[] columnlabel=in;
     
     real[][] a=in.dimension(0,0);
     a=transpose(a);
     real[] t=a[0], susceptible=a[1], infectious=a[2], dead=a[3], larvae=a[4];
     real[] susceptibleM=a[5], exposed=a[6],infectiousM=a[7];
     
     scale(true);
     
     draw(graph(t,susceptible,t >= 10 &amp; t &lt;= 15));
     draw(graph(t,dead,t >= 10 &amp; t &lt;= 15),dashed);
     
     xaxis("Time ($\tau$)",BottomTop,LeftTicks);
     yaxis(Left,RightTicks);
     
     picture secondary=secondaryY(new void(picture pic) {
         scale(pic,Linear(true),Log(true));
         draw(pic,graph(pic,t,infectious,t >= 10 &amp; t &lt;= 15),red);
         yaxis(pic,Right,red,LeftTicks(begin=false,end=false));
       });
                                  
     add(secondary);
     label(shift(5mm*N)*"Proportion of crows",point(NW),E);
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="secondaryaxis.png" alt="secondaryaxis.png"></div>

     <li>Here is a histogram example, which uses the <code>stats</code> module. 
<a name="index-g_t_0040code_007baxis_007d-986"></a><pre class="verbatim">     import graph;
     import stats;
     
     size(400,200,IgnoreAspect);
     
     int n=10000;
     real[] a=new real[n];
     for(int i=0; i &lt; n; ++i) a[i]=Gaussrand();
     
     draw(graph(Gaussian,min(a),max(a)),blue);
     
     // Optionally calculate "optimal" number of bins a la Shimazaki and Shinomoto.
     int N=bins(a);
     
     histogram(a,min(a),max(a),N,normalize=true,low=0,lightred,black,bars=false);
     
     xaxis("$x$",BottomTop,LeftTicks);
     yaxis("$dP/dx$",LeftRight,RightTicks(trailingzero));
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="histogram.png" alt="histogram.png"></div>

     <li>Here is an example of reading column data in from a file and a
least-squares fit, using the <code>stats</code> module. 
<a name="index-g_t_0040code_007bleastsquares_007d-987"></a><pre class="verbatim">     size(400,200,IgnoreAspect);
     
     import graph;
     import stats;
     
     file fin=input("leastsquares.dat").line();
     
     real[][] a=fin.dimension(0,0);
     a=transpose(a);
     
     real[] t=a[0], rho=a[1];
     
     // Read in parameters from the keyboard:
     //real first=getreal("first");
     //real step=getreal("step");
     //real last=getreal("last");
     
     real first=100;
     real step=50;
     real last=700;
     
     // Remove negative or zero values of rho:
     t=rho > 0 ? t : null;
     rho=rho > 0 ? rho : null;
         
     scale(Log(true),Linear(true));
     
     int n=step > 0 ? ceil((last-first)/step) : 0;
     
     real[] T,xi,dxi;
     
     for(int i=0; i &lt;= n; ++i) {
       real first=first+i*step;
       real[] logrho=(t >= first &amp; t &lt;= last) ? log(rho) : null;
       real[] logt=(t >= first &amp; t &lt;= last) ? -log(t) : null;
       
       if(logt.length &lt; 2) break;
       
       // Fit to the line logt=L.m*logrho+L.b:
       linefit L=leastsquares(logt,logrho);
         
       T.push(first);
       xi.push(L.m);
       dxi.push(L.dm);
     } 
         
     draw(graph(T,xi),blue);
     errorbars(T,xi,dxi,red);
     
     crop();
     
     ylimits(0);
     
     xaxis("$T$",BottomTop,LeftTicks);
     yaxis("$\xi$",LeftRight,RightTicks);
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="leastsquares.png" alt="leastsquares.png"></div>

     <li>Here is an example that illustrates the general <code>axis</code> routine. 
<a name="index-g_t_0040code_007baxis_007d-988"></a><pre class="verbatim">     import graph;
     size(0,100);
     
     path g=ellipse((0,0),1,2);
     
     scale(true);
     
     axis(Label("C",align=10W),g,LeftTicks(endlabel=false,8,end=false),
          ticklocate(0,360,new real(real v) {
              path h=(0,0)--max(abs(max(g)),abs(min(g)))*dir(v);
              return intersect(g,h)[0];}));
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="generalaxis.png" alt="generalaxis.png"></div>

     <li>To draw a vector field of <code>n</code> arrows evenly spaced along the arclength of a path, use the routine
<a name="index-g_t_0040code_007bvectorfield_007d-989"></a><pre class="verbatim">     picture vectorfield(path vector(real), path g, int n, bool truesize=false,
                         pen p=currentpen, arrowbar arrow=Arrow);
</pre>
as illustrated in this simple example of a flow field:
<pre class="verbatim">     import graph;
     defaultpen(1.0);
     
     size(0,150,IgnoreAspect);
     
     real arrowsize=4mm;
     real arrowlength=2arrowsize;
     
     typedef path vector(real);
     
     // Return a vector interpolated linearly between a and b.
     vector vector(pair a, pair b) {
       return new path(real x) {
         return (0,0)--arrowlength*interp(a,b,x);
       };
     }
     
     real f(real x) {return 1/x;}
     
     real epsilon=0.5;
     path g=graph(f,epsilon,1/epsilon);
     
     int n=3;
     draw(g);
     xaxis("$x$");
     yaxis("$y$");
     
     add(vectorfield(vector(W,W),g,n,true));
     add(vectorfield(vector(NE,NW),(0,0)--(point(E).x,0),n,true));
     add(vectorfield(vector(NE,NE),(0,0)--(0,point(N).y),n,true));
     
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="flow.png" alt="flow.png"></div>

     <li>To draw a vector field of <code>nx</code>\times<code>ny</code> arrows in <code>box(a,b)</code>, use the routine
<a name="index-g_t_0040code_007bvectorfield_007d-990"></a><pre class="verbatim">     picture vectorfield(path vector(pair), pair a, pair b,
                         int nx=nmesh, int ny=nx, bool truesize=false,
                         real maxlength=truesize ? 0 : maxlength(a,b,nx,ny),
                         bool cond(pair z)=null, pen p=currentpen,
                         arrowbar arrow=Arrow, margin margin=PenMargin)
</pre>
as illustrated in this example:
<pre class="verbatim">     import graph;
     size(100);
     
     pair a=(0,0);
     pair b=(2pi,2pi);
     
     path vector(pair z) {return (0,0)--(sin(z.x),cos(z.y));}
     
     add(vectorfield(vector,a,b));
</pre>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="vectorfield.png" alt="vectorfield.png"></div>

     <li>The following scientific graphs, which illustrate many features of
<code>Asymptote</code>'s graphics routines, were generated from the examples
<code>diatom.asy</code> and <code>westnile.asy</code>, using the comma-separated
data in <code>diatom.csv</code> and <code>westnile.csv</code>.

     <pre class="sp">
     
     </pre>
     <div align="center"><img src="diatom.png" alt="diatom.png"></div>
     <pre class="sp">
     
     </pre>
     <div align="center"><img src="westnile.png" alt="westnile.png"></div>
        </ol>

   </body></html>

