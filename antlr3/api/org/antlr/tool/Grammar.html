<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_03) on Sat Jun 23 11:20:42 UTC 2012 -->
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<title>Grammar (ANTLR Master build control POM 3.2 API)</title>
<meta name="date" content="2012-06-23">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Grammar (ANTLR Master build control POM 3.2 API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Grammar.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/antlr/tool/FASerializer.html" title="class in org.antlr.tool"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/antlr/tool/Grammar.html" target="_top">Frames</a></li>
<li><a href="Grammar.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested_class_summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.antlr.tool</div>
<h2 title="Class Grammar" class="title">Class Grammar</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.antlr.tool.Grammar</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">Grammar</span>
extends java.lang.Object</pre>
<div class="block">Represents a grammar in memory.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested_class_summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>class&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.LabelElementPair.html" title="class in org.antlr.tool">Grammar.LabelElementPair</a></strong></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#actions">actions</a></strong></code>
<div class="block">Map a scope to a map of name:action pairs.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#allDecisionDFACreated">allDecisionDFACreated</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String[]</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#ANTLRLiteralCharValueEscape">ANTLRLiteralCharValueEscape</a></strong></code>
<div class="block">Given a char, we need to be able to show as an ANTLR literal.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#ANTLRLiteralEscapedCharValue">ANTLRLiteralEscapedCharValue</a></strong></code>
<div class="block">When converting ANTLR char and string literals, here is the
  value set of escape chars.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#ARTIFICIAL_TOKENS_RULENAME">ARTIFICIAL_TOKENS_RULENAME</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#atLeastOneBacktrackOption">atLeastOneBacktrackOption</a></strong></code>
<div class="block">At least one backtrack=true in rule or decision or grammar.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#atLeastOneRuleMemoizes">atLeastOneRuleMemoizes</a></strong></code>
<div class="block">At least one rule has memoize=true</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#AUTO_GENERATED_TOKEN_NAME_PREFIX">AUTO_GENERATED_TOKEN_NAME_PREFIX</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#blocksWithSemPreds">blocksWithSemPreds</a></strong></code>
<div class="block">Track decisions with syn preds specified for reporting.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#blocksWithSynPreds">blocksWithSynPreds</a></strong></code>
<div class="block">Track decisions with syn preds specified for reporting.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#builtFromString">builtFromString</a></strong></code>
<div class="block">We need a way to detect when a lexer grammar is autogenerated from
  another grammar or we are just sending in a string representing a
  grammar.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#CHAR_LABEL">CHAR_LABEL</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#charVocabulary">charVocabulary</a></strong></code>
<div class="block">TODO: hook this to the charVocabulary option</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#COMBINED">COMBINED</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/CompositeGrammar.html" title="class in org.antlr.tool">CompositeGrammar</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#composite">composite</a></strong></code>
<div class="block">If this grammar is part of a larger composite grammar via delegate
  statement, then this points at the composite.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/CompositeGrammarTree.html" title="class in org.antlr.tool">CompositeGrammarTree</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#compositeTreeNode">compositeTreeNode</a></strong></code>
<div class="block">A pointer back into grammar tree.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#decisionCount">decisionCount</a></strong></code>
<div class="block">Be able to assign a number to every decision in grammar;
  decisions in 1..n</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#decisionsWhoseDFAsUsesSemPreds">decisionsWhoseDFAsUsesSemPreds</a></strong></code>
<div class="block">Track decisions that actually use the syn preds in the DFA.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#decisionsWhoseDFAsUsesSynPreds">decisionsWhoseDFAsUsesSynPreds</a></strong></code>
<div class="block">Track decisions that actually use the syn preds in the DFA.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defaultBlockOptions">defaultBlockOptions</a></strong></code>
<div class="block">What are the default options for a subrule?</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defaultLexerBlockOptions">defaultLexerBlockOptions</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defaultOptions">defaultOptions</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defaultTokenOption">defaultTokenOption</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#delegatedRuleReferences">delegatedRuleReferences</a></strong></code>
<div class="block">The list of all rules referenced in this grammar, not defined here,
  and defined in a delegate grammar.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#DFACreationWallClockTimeInMS">DFACreationWallClockTimeInMS</a></strong></code>
<div class="block">How long in ms did it take to build DFAs for this grammar?
  If this grammar is a combined grammar, it only records time for
  the parser grammar component.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#doNotCopyOptionsToLexer">doNotCopyOptionsToLexer</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#externalAnalysisAbort">externalAnalysisAbort</a></strong></code>
<div class="block">An external tool requests that DFA analysis abort prematurely.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../org/antlr/tool/NFAFactory.html" title="class in org.antlr.tool">NFAFactory</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#factory">factory</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#fileName">fileName</a></strong></code>
<div class="block">What file name holds this grammar?</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#FRAGMENT_RULE_MODIFIER">FRAGMENT_RULE_MODIFIER</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#generator">generator</a></strong></code>
<div class="block">If non-null, this is the code generator we will use to generate
  recognizers in the target language.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#global_k">global_k</a></strong></code>
<div class="block">Is there a global fixed lookahead set for this grammar?
  If 0, nothing specified.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#GRAMMAR_FILE_EXTENSION">GRAMMAR_FILE_EXTENSION</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#grammarTree">grammarTree</a></strong></code>
<div class="block">An AST that records entire input grammar with all rules.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String[]</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#grammarTypeToFileNameSuffix">grammarTypeToFileNameSuffix</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.String[]</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#grammarTypeToString">grammarTypeToString</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#IGNORE_STRING_IN_GRAMMAR_FILE_NAME">IGNORE_STRING_IN_GRAMMAR_FILE_NAME</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#implicitLexer">implicitLexer</a></strong></code>
<div class="block">Was this created from a COMBINED grammar?</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.Vector&lt;<a href="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#indexToDecision">indexToDecision</a></strong></code>
<div class="block">Each subrule/rule is a decision point and we must track them so we
  can go back later and build DFA predictors for them.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#INITIAL_DECISION_LIST_SIZE">INITIAL_DECISION_LIST_SIZE</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#INVALID_RULE_INDEX">INVALID_RULE_INDEX</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#label">label</a></strong></code>
<div class="block">If this is a delegate of another grammar, this is the label used
  as an instance var by that grammar to point at this grammar.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String[]</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#LabelTypeToString">LabelTypeToString</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#leftRecursiveRules">leftRecursiveRules</a></strong></code>
<div class="block">A list of all rules that are in any left-recursive cycle.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#legalBlockOptions">legalBlockOptions</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#legalLexerOptions">legalLexerOptions</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#legalParserOptions">legalParserOptions</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#legalTokenOptions">legalTokenOptions</a></strong></code>
<div class="block">Legal options for terminal refs like ID<node=MyVarNode></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#legalTreeParserOptions">legalTreeParserOptions</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#LEXER">LEXER</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#LEXER_GRAMMAR_FILE_EXTENSION">LEXER_GRAMMAR_FILE_EXTENSION</a></strong></code>
<div class="block">used for generating lexer temp files</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected org.antlr.stringtemplate.StringTemplate</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#lexerGrammarST">lexerGrammarST</a></strong></code>
<div class="block">For merged lexer/parsers, we must construct a separate lexer spec.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#lexerRuleNamesInCombined">lexerRuleNamesInCombined</a></strong></code>
<div class="block">The ANTLRParser tracks lexer rules when reading combined grammars
  so we can build the Tokens rule.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/LL1Analyzer.html" title="class in org.antlr.analysis">LL1Analyzer</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#ll1Analyzer">ll1Analyzer</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#name">name</a></strong></code>
<div class="block">What name did the user provide for this grammar?</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/NameSpaceChecker.html" title="class in org.antlr.tool">NameSpaceChecker</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#nameSpaceChecker">nameSpaceChecker</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.LinkedHashMap&lt;java.lang.String,<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#nameToRuleMap">nameToRuleMap</a></strong></code>
<div class="block">Map a rule to it's Rule object</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.LinkedHashMap</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#nameToSynpredASTMap">nameToSynpredASTMap</a></strong></code>
<div class="block">When we read in a grammar, we track the list of syntactic predicates
  and build faux rules for them later.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/NFA.html" title="class in org.antlr.analysis">NFA</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#nfa">nfa</a></strong></code>
<div class="block">The NFA that represents the grammar with edges labelled with tokens
  or epsilon.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#numberOfManualLookaheadOptions">numberOfManualLookaheadOptions</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#numberOfSemanticPredicates">numberOfSemanticPredicates</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#options">options</a></strong></code>
<div class="block">A list of options specified at the grammar level such as language=Java.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#overriddenRules">overriddenRules</a></strong></code>
<div class="block">If this rule is a delegate, some rules might be overridden; don't
  want to gen code for them.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#PARSER">PARSER</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#RULE_LABEL">RULE_LABEL</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#RULE_LIST_LABEL">RULE_LIST_LABEL</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.Set&lt;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#ruleRefs">ruleRefs</a></strong></code>
<div class="block">The unique set of all rule references in any rule; set of tree node
  objects so two refs to same rule can exist but at different line/position.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Set&lt;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#scopedRuleRefs">scopedRuleRefs</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#scopes">scopes</a></strong></code>
<div class="block">Track the scopes defined outside of rules and the scopes associated
  with all rules (even if empty).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setOfDFAWhoseAnalysisTimedOut">setOfDFAWhoseAnalysisTimedOut</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setOfNondeterministicDecisionNumbers">setOfNondeterministicDecisionNumbers</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setOfNondeterministicDecisionNumbersResolvedWithPredicates">setOfNondeterministicDecisionNumbersResolvedWithPredicates</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#SYNPRED_RULE_PREFIX">SYNPRED_RULE_PREFIX</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#SYNPREDGATE_ACTION_NAME">SYNPREDGATE_ACTION_NAME</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#synPredNamesUsedInDFA">synPredNamesUsedInDFA</a></strong></code>
<div class="block">Track names of preds so we can avoid generating preds that aren't used
  Computed during NFA to DFA conversion.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#TOKEN_LABEL">TOKEN_LABEL</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#TOKEN_LIST_LABEL">TOKEN_LIST_LABEL</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected antlr.TokenStreamRewriteEngine</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#tokenBuffer">tokenBuffer</a></strong></code>
<div class="block">This is the buffer of *all* tokens found in the grammar file
  including whitespace tokens etc...</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.Set&lt;antlr.Token&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#tokenIDRefs">tokenIDRefs</a></strong></code>
<div class="block">The unique set of all token ID references in any rule</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#tool">tool</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#TREE_PARSER">TREE_PARSER</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#type">type</a></strong></code>
<div class="block">What type of grammar is this: lexer, parser, tree walker</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../org/antlr/misc/MultiMap.html" title="class in org.antlr.misc">MultiMap</a>&lt;java.lang.Integer,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#validDelegations">validDelegations</a></strong></code>
<div class="block">Set of valid imports.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#WILDCARD_TREE_LABEL">WILDCARD_TREE_LABEL</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#WILDCARD_TREE_LIST_LABEL">WILDCARD_TREE_LIST_LABEL</a></strong></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../org/antlr/tool/Grammar.html#Grammar()">Grammar</a></strong>()</code>
<div class="block">Useful for when you are sure that you are not part of a composite
  already.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../../org/antlr/tool/Grammar.html#Grammar(java.lang.String)">Grammar</a></strong>(java.lang.String&nbsp;grammarString)</code>
<div class="block">Used for testing; only useful on noncomposite grammars.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../org/antlr/tool/Grammar.html#Grammar(org.antlr.Tool, java.lang.String)">Grammar</a></strong>(<a href="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</a>&nbsp;tool,
       java.lang.String&nbsp;grammarString)</code>
<div class="block">Used for testing and Interp/RandomPhrase.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../../org/antlr/tool/Grammar.html#Grammar(org.antlr.Tool, java.lang.String, org.antlr.tool.CompositeGrammar)">Grammar</a></strong>(<a href="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</a>&nbsp;tool,
       java.lang.String&nbsp;fileName,
       <a href="../../../org/antlr/tool/CompositeGrammar.html" title="class in org.antlr.tool">CompositeGrammar</a>&nbsp;composite)</code>
<div class="block">Create a grammar from file name.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#addArtificialMatchTokensRule(org.antlr.tool.GrammarAST, java.util.List, java.util.List, boolean)">addArtificialMatchTokensRule</a></strong>(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;grammarAST,
                            java.util.List&lt;java.lang.String&gt;&nbsp;ruleNames,
                            java.util.List&lt;java.lang.String&gt;&nbsp;delegateNames,
                            boolean&nbsp;filterMode)</code>
<div class="block">Parse a rule we add artificially that is a list of the other lexer
  rules like this: "Tokens : ID | INT | SEMI ;"  nextToken() will invoke
  this to set the current token.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#addDelegateGrammar(org.antlr.tool.Grammar)">addDelegateGrammar</a></strong>(<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&nbsp;delegateGrammar)</code>
<div class="block">add new delegate to composite tree</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#allDecisionDFAHaveBeenCreated()">allDecisionDFAHaveBeenCreated</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#altReferencesRule(java.lang.String, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, int)">altReferencesRule</a></strong>(java.lang.String&nbsp;enclosingRuleName,
                 <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;refScopeAST,
                 <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;refAST,
                 int&nbsp;outerAltNum)</code>
<div class="block">Track a rule reference within an outermost alt of a rule.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#altReferencesTokenID(java.lang.String, org.antlr.tool.GrammarAST, int)">altReferencesTokenID</a></strong>(java.lang.String&nbsp;ruleName,
                    <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;refAST,
                    int&nbsp;outerAltNum)</code>
<div class="block">Track a token reference within an outermost alt of a rule.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#assignDecisionNumber(org.antlr.analysis.NFAState)">assignDecisionNumber</a></strong>(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;state)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#buildAST()">buildAST</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#buildNFA()">buildNFA</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#buildTemplate()">buildTemplate</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.List</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#checkAllRulesForLeftRecursion()">checkAllRulesForLeftRecursion</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#checkAllRulesForUselessLabels()">checkAllRulesForUselessLabels</a></strong>()</code>
<div class="block">Remove all labels on rule refs whose target rules have no return value.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#checkNameSpaceAndActions()">checkNameSpaceAndActions</a></strong>()</code>
<div class="block">ANALYZE ACTIONS, LOOKING FOR LABEL AND ATTR REFS, sanity check</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#checkRuleReference(org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, java.lang.String)">checkRuleReference</a></strong>(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;scopeAST,
                  <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;refAST,
                  <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;argsAST,
                  java.lang.String&nbsp;currentRuleName)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#complement(int)">complement</a></strong>(int&nbsp;atom)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#complement(org.antlr.misc.IntSet)">complement</a></strong>(<a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a>&nbsp;set)</code>
<div class="block">For lexer grammars, return everything in unicode not in set.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#computeTokenNameFromLiteral(int, java.lang.String)">computeTokenNameFromLiteral</a></strong>(int&nbsp;tokenType,
                           java.lang.String&nbsp;literal)</code>
<div class="block">given a token type and the text of the literal, come up with a
  decent token type label.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#createDecision(int)">createDecision</a></strong>(int&nbsp;decision)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#createLL_1_LookaheadDFA(int)">createLL_1_LookaheadDFA</a></strong>(int&nbsp;decision)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#createLookaheadDFA(int, boolean)">createLookaheadDFA</a></strong>(int&nbsp;decision,
                  boolean&nbsp;wackTempStructures)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#createLookaheadDFAs()">createLookaheadDFAs</a></strong>()</code>
<div class="block">For each decision in this grammar, compute a single DFA using the
  NFA states associated with the decision.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#createLookaheadDFAs(boolean)">createLookaheadDFAs</a></strong>(boolean&nbsp;wackTempStructures)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#createParameterScope(java.lang.String, antlr.Token)">createParameterScope</a></strong>(java.lang.String&nbsp;ruleName,
                    antlr.Token&nbsp;argAction)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#createReturnScope(java.lang.String, antlr.Token)">createReturnScope</a></strong>(java.lang.String&nbsp;ruleName,
                 antlr.Token&nbsp;retAction)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#createRuleScope(java.lang.String, antlr.Token)">createRuleScope</a></strong>(java.lang.String&nbsp;ruleName,
               antlr.Token&nbsp;scopeAction)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#createRuleStartAndStopNFAStates()">createRuleStartAndStopNFAStates</a></strong>()</code>
<div class="block">Define all the rule begin/end NFAStates to solve forward reference
  issues.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#dealWithTreeFilterMode()">dealWithTreeFilterMode</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineGlobalScope(java.lang.String, antlr.Token)">defineGlobalScope</a></strong>(java.lang.String&nbsp;name,
                 antlr.Token&nbsp;scopeAction)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineGrammarSymbols()">defineGrammarSymbols</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineLabel(org.antlr.tool.Rule, antlr.Token, org.antlr.tool.GrammarAST, int)">defineLabel</a></strong>(<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&nbsp;r,
           antlr.Token&nbsp;label,
           <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;element,
           int&nbsp;type)</code>
<div class="block">Define a label defined in a rule r; check the validity then ask the
  Rule object to actually define it.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineLexerRuleForAliasedStringLiteral(java.lang.String, java.lang.String, int)">defineLexerRuleForAliasedStringLiteral</a></strong>(java.lang.String&nbsp;tokenID,
                                      java.lang.String&nbsp;literal,
                                      int&nbsp;tokenType)</code>
<div class="block">If someone does PLUS='+' in the parser, must make sure we get
  "PLUS : '+' ;" in lexer not "T73 : '+';"</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineLexerRuleForStringLiteral(java.lang.String, int)">defineLexerRuleForStringLiteral</a></strong>(java.lang.String&nbsp;literal,
                               int&nbsp;tokenType)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineLexerRuleFoundInParser(antlr.Token, org.antlr.tool.GrammarAST)">defineLexerRuleFoundInParser</a></strong>(antlr.Token&nbsp;ruleToken,
                            <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;ruleAST)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineNamedAction(org.antlr.tool.GrammarAST, java.lang.String, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST)">defineNamedAction</a></strong>(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;ampersandAST,
                 java.lang.String&nbsp;scope,
                 <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;nameAST,
                 <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;actionAST)</code>
<div class="block">Given @scope::name {action} define it for this grammar.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineRule(antlr.Token, java.lang.String, java.util.Map, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, int)">defineRule</a></strong>(antlr.Token&nbsp;ruleToken,
          java.lang.String&nbsp;modifier,
          java.util.Map&nbsp;options,
          <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;tree,
          <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;argActionAST,
          int&nbsp;numAlts)</code>
<div class="block">Define a new rule.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineRuleListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineRuleListLabel</a></strong>(java.lang.String&nbsp;ruleName,
                   antlr.Token&nbsp;label,
                   <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;element)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineRuleRefLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineRuleRefLabel</a></strong>(java.lang.String&nbsp;ruleName,
                  antlr.Token&nbsp;label,
                  <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;ruleRef)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineSyntacticPredicate(org.antlr.tool.GrammarAST, java.lang.String)">defineSyntacticPredicate</a></strong>(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;blockAST,
                        java.lang.String&nbsp;currentRuleName)</code>
<div class="block">Define a new predicate and get back its name for use in building
  a semantic predicate reference to the syn pred.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineToken(java.lang.String, int)">defineToken</a></strong>(java.lang.String&nbsp;text,
           int&nbsp;tokenType)</code>
<div class="block">Define a token at a particular token type value.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineTokenListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineTokenListLabel</a></strong>(java.lang.String&nbsp;ruleName,
                    antlr.Token&nbsp;label,
                    <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;element)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineTokenRefLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineTokenRefLabel</a></strong>(java.lang.String&nbsp;ruleName,
                   antlr.Token&nbsp;label,
                   <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;tokenRef)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineWildcardTreeLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineWildcardTreeLabel</a></strong>(java.lang.String&nbsp;ruleName,
                       antlr.Token&nbsp;label,
                       <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;tokenRef)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#defineWildcardTreeListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">defineWildcardTreeListLabel</a></strong>(java.lang.String&nbsp;ruleName,
                           antlr.Token&nbsp;label,
                           <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;tokenRef)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#examineAllExecutableActions()">examineAllExecutableActions</a></strong>()</code>
<div class="block">Before generating code, we examine all actions that can have
  $x.y and $y stuff in them because some code generation depends on
  Rule.referencedPredefinedRuleAttributes.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#externallyAbortNFAToDFAConversion()">externallyAbortNFAToDFAConversion</a></strong>()</code>
<div class="block">Terminate DFA creation (grammar analysis).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/LookaheadSet.html" title="class in org.antlr.analysis">LookaheadSet</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#FIRST(org.antlr.analysis.NFAState)">FIRST</a></strong>(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;s)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#generateMethodForRule(java.lang.String)">generateMethodForRule</a></strong>(java.lang.String&nbsp;ruleName)</code>
<div class="block">Should codegen.g gen rule for ruleName?
        If synpred, only gen if used in a DFA.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getActions()">getActions</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getAllCharValues()">getAllCharValues</a></strong>()</code>
<div class="block">If there is a char vocabulary, use it; else return min to max char
  as defined by the target.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getAllImportedRules()">getAllImportedRules</a></strong>()</code>
<div class="block">Get set of all rules imported from all delegate grammars even if
  indirectly delegated.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getANTLRCharLiteralForChar(int)">getANTLRCharLiteralForChar</a></strong>(int&nbsp;c)</code>
<div class="block">Return a string representing the escaped char for code c.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.List</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getArtificialRulesForSyntacticPredicates(org.antlr.grammar.v2.ANTLRParser, java.util.LinkedHashMap)">getArtificialRulesForSyntacticPredicates</a></strong>(<a href="../../../org/antlr/grammar/v2/ANTLRParser.html" title="class in org.antlr.grammar.v2">ANTLRParser</a>&nbsp;parser,
                                        java.util.LinkedHashMap&nbsp;nameToSynpredASTMap)</code>
<div class="block">for any syntactic predicates, we need to define rules for them; they will get
  defined automatically like any other rule.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getAutoBacktrackMode(int)">getAutoBacktrackMode</a></strong>(int&nbsp;decision)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getBlockOption(org.antlr.tool.GrammarAST, java.lang.String)">getBlockOption</a></strong>(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;blockAST,
              java.lang.String&nbsp;key)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getCharValueFromGrammarCharLiteral(java.lang.String)">getCharValueFromGrammarCharLiteral</a></strong>(java.lang.String&nbsp;literal)</code>
<div class="block">Given a literal like (the 3 char sequence with single quotes) 'a',
  return the int value of 'a'.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getCodeGenerator()">getCodeGenerator</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDecision(int)">getDecision</a></strong>(int&nbsp;decision)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDecisionBlockAST(int)">getDecisionBlockAST</a></strong>(int&nbsp;decision)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDecisionNFAStartState(int)">getDecisionNFAStartState</a></strong>(int&nbsp;decision)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.List</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDecisionNFAStartStateList()">getDecisionNFAStartStateList</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDefaultActionScope(int)">getDefaultActionScope</a></strong>(int&nbsp;grammarType)</code>
<div class="block">Given a grammar type, what should be the default action scope?
  If I say @members in a COMBINED grammar, for example, the
  default scope should be "parser".</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDelegatedRuleReferences()">getDelegatedRuleReferences</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDelegatedRules()">getDelegatedRules</a></strong>()</code>
<div class="block">Get the set of Rules that need to have manual delegations
  like "void rule() { importedGrammar.rule(); }"

  If this grammar is master, get list of all rule definitions from all
  delegate grammars.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDelegateNames()">getDelegateNames</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDelegates()">getDelegates</a></strong>()</code>
<div class="block">Get list of all delegates from all grammars directly or indirectly
  imported into this grammar.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDelegator()">getDelegator</a></strong>()</code>
<div class="block">Who's my direct parent grammar?</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDelegators()">getDelegators</a></strong>()</code>
<div class="block">Get list of all delegators.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getDirectDelegates()">getDirectDelegates</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getFileName()">getFileName</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getGlobalScope(java.lang.String)">getGlobalScope</a></strong>(java.lang.String&nbsp;name)</code>
<div class="block">Get a global scope</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getGlobalScopes()">getGlobalScopes</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getGrammarIsRoot()">getGrammarIsRoot</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getGrammarMaxLookahead()">getGrammarMaxLookahead</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getGrammarTree()">getGrammarTree</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getGrammarTypeString()">getGrammarTypeString</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getImplicitlyGeneratedLexerFileName()">getImplicitlyGeneratedLexerFileName</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getIndirectDelegates()">getIndirectDelegates</a></strong>()</code>
<div class="block">Get delegates below direct delegates</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getLabels(java.util.Set, int)">getLabels</a></strong>(java.util.Set&lt;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&gt;&nbsp;rewriteElements,
         int&nbsp;labelType)</code>
<div class="block">Given a set of all rewrite elements on right of ->, filter for
  label types such as Grammar.TOKEN_LABEL, Grammar.TOKEN_LIST_LABEL, ...</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getLeftRecursiveRules()">getLeftRecursiveRules</a></strong>()</code>
<div class="block">Return a list of left-recursive rules; no analysis can be done
  successfully on these.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getLexerGrammar()">getLexerGrammar</a></strong>()</code>
<div class="block">If the grammar is a combined grammar, return the text of the implicit
  lexer grammar.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getLineColumnToLookaheadDFAMap()">getLineColumnToLookaheadDFAMap</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getLocallyDefinedOption(java.lang.String)">getLocallyDefinedOption</a></strong>(java.lang.String&nbsp;key)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getLocallyDefinedRule(java.lang.String)">getLocallyDefinedRule</a></strong>(java.lang.String&nbsp;ruleName)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getLookaheadDFA(int)">getLookaheadDFA</a></strong>(int&nbsp;decision)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.List</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getLookaheadDFAColumnsForLineInFile(int)">getLookaheadDFAColumnsForLineInFile</a></strong>(int&nbsp;line)</code>
<div class="block">returns a list of column numbers for all decisions
  on a particular line so ANTLRWorks choose the decision
  depending on the location of the cursor (otherwise,
  ANTLRWorks has to give the *exact* location which
  is not easy from the user point of view).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getLookaheadDFAFromPositionInFile(int, int)">getLookaheadDFAFromPositionInFile</a></strong>(int&nbsp;line,
                                 int&nbsp;col)</code>
<div class="block">Useful for ANTLRWorks to map position in file to the DFA for display</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getMaxCharValue()">getMaxCharValue</a></strong>()</code>
<div class="block">What is the max char value possible for this grammar's target?  Use
  unicode max if no target defined.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getMaxTokenType()">getMaxTokenType</a></strong>()</code>
<div class="block">How many token types have been allocated so far?</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getNewTokenType()">getNewTokenType</a></strong>()</code>
<div class="block">Return a new unique integer in the token type space</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getNFAStateForAltOfDecision(org.antlr.analysis.NFAState, int)">getNFAStateForAltOfDecision</a></strong>(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;decisionState,
                           int&nbsp;alt)</code>
<div class="block">Get the ith alternative (1..n) from a decision; return null when
  an invalid alt is requested.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getNumberOfAltsForDecisionNFA(org.antlr.analysis.NFAState)">getNumberOfAltsForDecisionNFA</a></strong>(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;decisionState)</code>
<div class="block">Decisions are linked together with transition(1).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getNumberOfCyclicDecisions()">getNumberOfCyclicDecisions</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getNumberOfDecisions()">getNumberOfDecisions</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getOption(java.lang.String)">getOption</a></strong>(java.lang.String&nbsp;key)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRecognizerName()">getRecognizerName</a></strong>()</code>
<div class="block">Get the name of the generated recognizer; may or may not be same
  as grammar name.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRule(java.lang.String)">getRule</a></strong>(java.lang.String&nbsp;ruleName)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRule(java.lang.String, java.lang.String)">getRule</a></strong>(java.lang.String&nbsp;scopeName,
       java.lang.String&nbsp;ruleName)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRuleIndex(java.lang.String)">getRuleIndex</a></strong>(java.lang.String&nbsp;ruleName)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRuleIndex(java.lang.String, java.lang.String)">getRuleIndex</a></strong>(java.lang.String&nbsp;scopeName,
            java.lang.String&nbsp;ruleName)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRuleModifier(java.lang.String)">getRuleModifier</a></strong>(java.lang.String&nbsp;ruleName)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRuleName(int)">getRuleName</a></strong>(int&nbsp;ruleIndex)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Collection&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRules()">getRules</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRuleStartState(java.lang.String)">getRuleStartState</a></strong>(java.lang.String&nbsp;ruleName)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRuleStartState(java.lang.String, java.lang.String)">getRuleStartState</a></strong>(java.lang.String&nbsp;scopeName,
                 java.lang.String&nbsp;ruleName)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getRuleStopState(java.lang.String)">getRuleStopState</a></strong>(java.lang.String&nbsp;ruleName)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getSetFromRule(org.antlr.grammar.v2.TreeToNFAConverter, java.lang.String)">getSetFromRule</a></strong>(<a href="../../../org/antlr/grammar/v2/TreeToNFAConverter.html" title="class in org.antlr.grammar.v2">TreeToNFAConverter</a>&nbsp;nfabuilder,
              java.lang.String&nbsp;ruleName)</code>
<div class="block">Get the set equivalent (if any) of the indicated rule from this
  grammar.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getStringLiterals()">getStringLiterals</a></strong>()</code>
<div class="block">Get the list of ANTLR String literals</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getSyntacticPredicate(java.lang.String)">getSyntacticPredicate</a></strong>(java.lang.String&nbsp;name)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.LinkedHashMap</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getSyntacticPredicates()">getSyntacticPredicates</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getTokenDisplayName(int)">getTokenDisplayName</a></strong>(int&nbsp;ttype)</code>
<div class="block">Given a token type, get a meaningful name for it such as the ID
  or string literal.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getTokenDisplayNames()">getTokenDisplayNames</a></strong>()</code>
<div class="block">Get a list of all token IDs and literals that have an associated
  token type.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getTokenIDs()">getTokenIDs</a></strong>()</code>
<div class="block">Get the list of tokens that are IDs like BLOCK and LPAREN</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getTokenType(java.lang.String)">getTokenType</a></strong>(java.lang.String&nbsp;tokenName)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getTokenTypes()">getTokenTypes</a></strong>()</code>
<div class="block">Return a set of all possible token or char types for this grammar</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Collection</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getTokenTypesWithoutID()">getTokenTypesWithoutID</a></strong>()</code>
<div class="block">Return an ordered integer list of token types that have no
  corresponding token ID like INT or KEYWORD_BEGIN; for stuff
  like 'begin'.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getTool()">getTool</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.StringBuffer</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getUnescapedStringFromGrammarStringLiteral(java.lang.String)">getUnescapedStringFromGrammarStringLiteral</a></strong>(java.lang.String&nbsp;literal)</code>
<div class="block">ANTLR does not convert escape sequences during the parse phase because
  it could not know how to print String/char literals back out when
  printing grammars etc...</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#getUserMaxLookahead(int)">getUserMaxLookahead</a></strong>(int&nbsp;decision)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#grammarTreeToString(org.antlr.tool.GrammarAST)">grammarTreeToString</a></strong>(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;t)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#grammarTreeToString(org.antlr.tool.GrammarAST, boolean)">grammarTreeToString</a></strong>(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;t,
                   boolean&nbsp;showActions)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#importGrammar(org.antlr.tool.GrammarAST, java.lang.String)">importGrammar</a></strong>(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;grammarNameAST,
             java.lang.String&nbsp;label)</code>
<div class="block">Import the rules/tokens of a delegate grammar.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#importTokenVocabulary(org.antlr.tool.Grammar)">importTokenVocabulary</a></strong>(<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&nbsp;importFromGr)</code>
<div class="block">Pull your token definitions from an existing grammar in memory.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#importTokenVocabulary(org.antlr.tool.GrammarAST, java.lang.String)">importTokenVocabulary</a></strong>(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;tokenVocabOptionAST,
                     java.lang.String&nbsp;vocabName)</code>
<div class="block">Load a vocab file <vocabName>.tokens and return max token type found.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#isAtomTokenType(int)">isAtomTokenType</a></strong>(int&nbsp;ttype)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#isBuiltFromString()">isBuiltFromString</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#isEmptyRule(org.antlr.tool.GrammarAST)">isEmptyRule</a></strong>(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;block)</code>
<div class="block">Rules like "a : ;" and "a : {...} ;" should not generate
  try/catch blocks for RecognitionException.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#isValidSet(org.antlr.grammar.v2.TreeToNFAConverter, org.antlr.tool.GrammarAST)">isValidSet</a></strong>(<a href="../../../org/antlr/grammar/v2/TreeToNFAConverter.html" title="class in org.antlr.grammar.v2">TreeToNFAConverter</a>&nbsp;nfabuilder,
          <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;t)</code>
<div class="block">Given set tree like ( SET A B ), check that A and B
  are both valid sets themselves, else we must tree like a BLOCK</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#legalOption(java.lang.String)">legalOption</a></strong>(java.lang.String&nbsp;key)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/LookaheadSet.html" title="class in org.antlr.analysis">LookaheadSet</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#LOOK(org.antlr.analysis.NFAState)">LOOK</a></strong>(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;s)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.List&lt;<a href="../../../org/antlr/misc/IntervalSet.html" title="class in org.antlr.misc">IntervalSet</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#makeEdgeSetsDisjoint(java.util.List)">makeEdgeSetsDisjoint</a></strong>(java.util.List&lt;<a href="../../../org/antlr/misc/IntervalSet.html" title="class in org.antlr.misc">IntervalSet</a>&gt;&nbsp;edges)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#NFAToDFAConversionExternallyAborted()">NFAToDFAConversionExternallyAborted</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#optionIsValid(java.lang.String, java.lang.Object)">optionIsValid</a></strong>(java.lang.String&nbsp;key,
             java.lang.Object&nbsp;value)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#parseAndBuildAST()">parseAndBuildAST</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#parseAndBuildAST(java.io.Reader)">parseAndBuildAST</a></strong>(java.io.Reader&nbsp;r)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#printGrammar(java.io.PrintStream)">printGrammar</a></strong>(java.io.PrintStream&nbsp;output)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#referenceRuleLabelPredefinedAttribute(java.lang.String)">referenceRuleLabelPredefinedAttribute</a></strong>(java.lang.String&nbsp;ruleName)</code>
<div class="block">To yield smaller, more readable code, track which rules have their
  predefined attributes accessed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#removeUselessLabels(java.util.Map)">removeUselessLabels</a></strong>(java.util.Map&nbsp;ruleToElementLabelPairMap)</code>
<div class="block">A label on a rule is useless if the rule has no return value, no
  tree or template output, and it is not referenced in an action.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#rewriteMode()">rewriteMode</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setCodeGenerator(org.antlr.codegen.CodeGenerator)">setCodeGenerator</a></strong>(<a href="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</a>&nbsp;generator)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setDecisionBlockAST(int, org.antlr.tool.GrammarAST)">setDecisionBlockAST</a></strong>(int&nbsp;decision,
                   <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;blockAST)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setDecisionNFA(int, org.antlr.analysis.NFAState)">setDecisionNFA</a></strong>(int&nbsp;decision,
              <a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;state)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setFileName(java.lang.String)">setFileName</a></strong>(java.lang.String&nbsp;fileName)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setGrammarContent(java.lang.String)">setGrammarContent</a></strong>(java.lang.String&nbsp;grammarString)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setLookaheadDFA(int, org.antlr.analysis.DFA)">setLookaheadDFA</a></strong>(int&nbsp;decision,
               <a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&nbsp;lookaheadDFA)</code>
<div class="block">Set the lookahead DFA for a particular decision.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setName(java.lang.String)">setName</a></strong>(java.lang.String&nbsp;name)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setOption(java.lang.String, java.lang.Object, antlr.Token)">setOption</a></strong>(java.lang.String&nbsp;key,
         java.lang.Object&nbsp;value,
         antlr.Token&nbsp;optionsStartToken)</code>
<div class="block">Save the option key/value pair and process it; return the key
  or null if invalid option.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setOptions(java.util.Map, antlr.Token)">setOptions</a></strong>(java.util.Map&nbsp;options,
          antlr.Token&nbsp;optionsStartToken)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setRuleAST(java.lang.String, org.antlr.tool.GrammarAST)">setRuleAST</a></strong>(java.lang.String&nbsp;ruleName,
          <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;t)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setSynPredGateIfNotAlready(org.antlr.stringtemplate.StringTemplate)">setSynPredGateIfNotAlready</a></strong>(org.antlr.stringtemplate.StringTemplate&nbsp;gateST)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#setTool(org.antlr.Tool)">setTool</a></strong>(<a href="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</a>&nbsp;tool)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#synPredUsedInDFA(org.antlr.analysis.DFA, org.antlr.analysis.SemanticContext)">synPredUsedInDFA</a></strong>(<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&nbsp;dfa,
                <a href="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</a>&nbsp;semCtx)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#toString()">toString</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/tool/Grammar.html#validImport(org.antlr.tool.Grammar)">validImport</a></strong>(<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&nbsp;delegate)</code>
<div class="block">Many imports are illegal such as lexer into a tree grammar</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="SYNPRED_RULE_PREFIX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SYNPRED_RULE_PREFIX</h4>
<pre>public static final&nbsp;java.lang.String SYNPRED_RULE_PREFIX</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.SYNPRED_RULE_PREFIX">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="GRAMMAR_FILE_EXTENSION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GRAMMAR_FILE_EXTENSION</h4>
<pre>public static final&nbsp;java.lang.String GRAMMAR_FILE_EXTENSION</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.GRAMMAR_FILE_EXTENSION">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="LEXER_GRAMMAR_FILE_EXTENSION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LEXER_GRAMMAR_FILE_EXTENSION</h4>
<pre>public static final&nbsp;java.lang.String LEXER_GRAMMAR_FILE_EXTENSION</pre>
<div class="block">used for generating lexer temp files</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.LEXER_GRAMMAR_FILE_EXTENSION">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="INITIAL_DECISION_LIST_SIZE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INITIAL_DECISION_LIST_SIZE</h4>
<pre>public static final&nbsp;int INITIAL_DECISION_LIST_SIZE</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.INITIAL_DECISION_LIST_SIZE">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="INVALID_RULE_INDEX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INVALID_RULE_INDEX</h4>
<pre>public static final&nbsp;int INVALID_RULE_INDEX</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.INVALID_RULE_INDEX">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="RULE_LABEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RULE_LABEL</h4>
<pre>public static final&nbsp;int RULE_LABEL</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.RULE_LABEL">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="TOKEN_LABEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TOKEN_LABEL</h4>
<pre>public static final&nbsp;int TOKEN_LABEL</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.TOKEN_LABEL">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="RULE_LIST_LABEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RULE_LIST_LABEL</h4>
<pre>public static final&nbsp;int RULE_LIST_LABEL</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.RULE_LIST_LABEL">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="TOKEN_LIST_LABEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TOKEN_LIST_LABEL</h4>
<pre>public static final&nbsp;int TOKEN_LIST_LABEL</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.TOKEN_LIST_LABEL">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="CHAR_LABEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CHAR_LABEL</h4>
<pre>public static final&nbsp;int CHAR_LABEL</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.CHAR_LABEL">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="WILDCARD_TREE_LABEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WILDCARD_TREE_LABEL</h4>
<pre>public static final&nbsp;int WILDCARD_TREE_LABEL</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.WILDCARD_TREE_LABEL">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="WILDCARD_TREE_LIST_LABEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WILDCARD_TREE_LIST_LABEL</h4>
<pre>public static final&nbsp;int WILDCARD_TREE_LIST_LABEL</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.WILDCARD_TREE_LIST_LABEL">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="LabelTypeToString">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LabelTypeToString</h4>
<pre>public static&nbsp;java.lang.String[] LabelTypeToString</pre>
</li>
</ul>
<a name="ARTIFICIAL_TOKENS_RULENAME">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARTIFICIAL_TOKENS_RULENAME</h4>
<pre>public static final&nbsp;java.lang.String ARTIFICIAL_TOKENS_RULENAME</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.ARTIFICIAL_TOKENS_RULENAME">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="FRAGMENT_RULE_MODIFIER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FRAGMENT_RULE_MODIFIER</h4>
<pre>public static final&nbsp;java.lang.String FRAGMENT_RULE_MODIFIER</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.FRAGMENT_RULE_MODIFIER">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="SYNPREDGATE_ACTION_NAME">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SYNPREDGATE_ACTION_NAME</h4>
<pre>public static final&nbsp;java.lang.String SYNPREDGATE_ACTION_NAME</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.SYNPREDGATE_ACTION_NAME">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="ANTLRLiteralEscapedCharValue">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ANTLRLiteralEscapedCharValue</h4>
<pre>public static&nbsp;int[] ANTLRLiteralEscapedCharValue</pre>
<div class="block">When converting ANTLR char and string literals, here is the
  value set of escape chars.</div>
</li>
</ul>
<a name="ANTLRLiteralCharValueEscape">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ANTLRLiteralCharValueEscape</h4>
<pre>public static&nbsp;java.lang.String[] ANTLRLiteralCharValueEscape</pre>
<div class="block">Given a char, we need to be able to show as an ANTLR literal.</div>
</li>
</ul>
<a name="LEXER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LEXER</h4>
<pre>public static final&nbsp;int LEXER</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.LEXER">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="PARSER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PARSER</h4>
<pre>public static final&nbsp;int PARSER</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.PARSER">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="TREE_PARSER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TREE_PARSER</h4>
<pre>public static final&nbsp;int TREE_PARSER</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.TREE_PARSER">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="COMBINED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COMBINED</h4>
<pre>public static final&nbsp;int COMBINED</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.COMBINED">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="grammarTypeToString">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grammarTypeToString</h4>
<pre>public static final&nbsp;java.lang.String[] grammarTypeToString</pre>
</li>
</ul>
<a name="grammarTypeToFileNameSuffix">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grammarTypeToFileNameSuffix</h4>
<pre>public static final&nbsp;java.lang.String[] grammarTypeToFileNameSuffix</pre>
</li>
</ul>
<a name="validDelegations">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validDelegations</h4>
<pre>public static&nbsp;<a href="../../../org/antlr/misc/MultiMap.html" title="class in org.antlr.misc">MultiMap</a>&lt;java.lang.Integer,java.lang.Integer&gt; validDelegations</pre>
<div class="block">Set of valid imports.  E.g., can only import a tree parser into
  another tree parser.  Maps delegate to set of delegator grammar types.
  validDelegations.get(LEXER) gives list of the kinds of delegators
  that can import lexers.</div>
</li>
</ul>
<a name="tokenBuffer">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tokenBuffer</h4>
<pre>protected&nbsp;antlr.TokenStreamRewriteEngine tokenBuffer</pre>
<div class="block">This is the buffer of *all* tokens found in the grammar file
  including whitespace tokens etc...  I use this to extract
  lexer rules from combined grammars.</div>
</li>
</ul>
<a name="IGNORE_STRING_IN_GRAMMAR_FILE_NAME">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IGNORE_STRING_IN_GRAMMAR_FILE_NAME</h4>
<pre>public static final&nbsp;java.lang.String IGNORE_STRING_IN_GRAMMAR_FILE_NAME</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.IGNORE_STRING_IN_GRAMMAR_FILE_NAME">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="AUTO_GENERATED_TOKEN_NAME_PREFIX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>AUTO_GENERATED_TOKEN_NAME_PREFIX</h4>
<pre>public static final&nbsp;java.lang.String AUTO_GENERATED_TOKEN_NAME_PREFIX</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.AUTO_GENERATED_TOKEN_NAME_PREFIX">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="name">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>name</h4>
<pre>public&nbsp;java.lang.String name</pre>
<div class="block">What name did the user provide for this grammar?</div>
</li>
</ul>
<a name="type">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>type</h4>
<pre>public&nbsp;int type</pre>
<div class="block">What type of grammar is this: lexer, parser, tree walker</div>
</li>
</ul>
<a name="options">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>options</h4>
<pre>protected&nbsp;java.util.Map options</pre>
<div class="block">A list of options specified at the grammar level such as language=Java.
  The value can be an AST for complicated values such as character sets.
  There may be code generator specific options in here.  I do no
  interpretation of the key/value pairs...they are simply available for
  who wants them.</div>
</li>
</ul>
<a name="legalLexerOptions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>legalLexerOptions</h4>
<pre>public static final&nbsp;java.util.Set legalLexerOptions</pre>
</li>
</ul>
<a name="legalParserOptions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>legalParserOptions</h4>
<pre>public static final&nbsp;java.util.Set legalParserOptions</pre>
</li>
</ul>
<a name="legalTreeParserOptions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>legalTreeParserOptions</h4>
<pre>public static final&nbsp;java.util.Set legalTreeParserOptions</pre>
</li>
</ul>
<a name="doNotCopyOptionsToLexer">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doNotCopyOptionsToLexer</h4>
<pre>public static final&nbsp;java.util.Set doNotCopyOptionsToLexer</pre>
</li>
</ul>
<a name="defaultOptions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defaultOptions</h4>
<pre>public static final&nbsp;java.util.Map defaultOptions</pre>
</li>
</ul>
<a name="legalBlockOptions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>legalBlockOptions</h4>
<pre>public static final&nbsp;java.util.Set legalBlockOptions</pre>
</li>
</ul>
<a name="defaultBlockOptions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defaultBlockOptions</h4>
<pre>public static final&nbsp;java.util.Map defaultBlockOptions</pre>
<div class="block">What are the default options for a subrule?</div>
</li>
</ul>
<a name="defaultLexerBlockOptions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defaultLexerBlockOptions</h4>
<pre>public static final&nbsp;java.util.Map defaultLexerBlockOptions</pre>
</li>
</ul>
<a name="legalTokenOptions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>legalTokenOptions</h4>
<pre>public static final&nbsp;java.util.Set legalTokenOptions</pre>
<div class="block">Legal options for terminal refs like ID<node=MyVarNode></div>
</li>
</ul>
<a name="defaultTokenOption">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defaultTokenOption</h4>
<pre>public static final&nbsp;java.lang.String defaultTokenOption</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.tool.Grammar.defaultTokenOption">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="global_k">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>global_k</h4>
<pre>protected&nbsp;int global_k</pre>
<div class="block">Is there a global fixed lookahead set for this grammar?
  If 0, nothing specified.  -1 implies we have not looked at
  the options table yet to set k.</div>
</li>
</ul>
<a name="actions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actions</h4>
<pre>protected&nbsp;java.util.Map actions</pre>
<div class="block">Map a scope to a map of name:action pairs.
  Map<String, Map<String,GrammarAST>>
  The code generator will use this to fill holes in the output files.
  I track the AST node for the action in case I need the line number
  for errors.</div>
</li>
</ul>
<a name="nfa">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nfa</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/NFA.html" title="class in org.antlr.analysis">NFA</a> nfa</pre>
<div class="block">The NFA that represents the grammar with edges labelled with tokens
  or epsilon.  It is more suitable to analysis than an AST representation.</div>
</li>
</ul>
<a name="factory">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>factory</h4>
<pre>protected&nbsp;<a href="../../../org/antlr/tool/NFAFactory.html" title="class in org.antlr.tool">NFAFactory</a> factory</pre>
</li>
</ul>
<a name="composite">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>composite</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/CompositeGrammar.html" title="class in org.antlr.tool">CompositeGrammar</a> composite</pre>
<div class="block">If this grammar is part of a larger composite grammar via delegate
  statement, then this points at the composite.  The composite holds
  a global list of rules, token types, decision numbers, etc...</div>
</li>
</ul>
<a name="compositeTreeNode">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compositeTreeNode</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/CompositeGrammarTree.html" title="class in org.antlr.tool">CompositeGrammarTree</a> compositeTreeNode</pre>
<div class="block">A pointer back into grammar tree.  Needed so we can add delegates.</div>
</li>
</ul>
<a name="label">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>label</h4>
<pre>public&nbsp;java.lang.String label</pre>
<div class="block">If this is a delegate of another grammar, this is the label used
  as an instance var by that grammar to point at this grammar. null
  if no label was specified in the delegate statement.</div>
</li>
</ul>
<a name="charVocabulary">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>charVocabulary</h4>
<pre>protected&nbsp;<a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a> charVocabulary</pre>
<div class="block">TODO: hook this to the charVocabulary option</div>
</li>
</ul>
<a name="tool">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tool</h4>
<pre>public&nbsp;<a href="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</a> tool</pre>
</li>
</ul>
<a name="ruleRefs">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ruleRefs</h4>
<pre>protected&nbsp;java.util.Set&lt;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&gt; ruleRefs</pre>
<div class="block">The unique set of all rule references in any rule; set of tree node
  objects so two refs to same rule can exist but at different line/position.</div>
</li>
</ul>
<a name="scopedRuleRefs">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scopedRuleRefs</h4>
<pre>protected&nbsp;java.util.Set&lt;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&gt; scopedRuleRefs</pre>
</li>
</ul>
<a name="tokenIDRefs">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tokenIDRefs</h4>
<pre>protected&nbsp;java.util.Set&lt;antlr.Token&gt; tokenIDRefs</pre>
<div class="block">The unique set of all token ID references in any rule</div>
</li>
</ul>
<a name="decisionCount">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decisionCount</h4>
<pre>protected&nbsp;int decisionCount</pre>
<div class="block">Be able to assign a number to every decision in grammar;
  decisions in 1..n</div>
</li>
</ul>
<a name="leftRecursiveRules">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftRecursiveRules</h4>
<pre>protected&nbsp;java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt; leftRecursiveRules</pre>
<div class="block">A list of all rules that are in any left-recursive cycle.  There
  could be multiple cycles, but this is a flat list of all problematic
  rules.</div>
</li>
</ul>
<a name="externalAnalysisAbort">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>externalAnalysisAbort</h4>
<pre>protected&nbsp;boolean externalAnalysisAbort</pre>
<div class="block">An external tool requests that DFA analysis abort prematurely.  Stops
  at DFA granularity, which are limited to a DFA size and time computation
  as failsafe.</div>
</li>
</ul>
<a name="nameToSynpredASTMap">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nameToSynpredASTMap</h4>
<pre>protected&nbsp;java.util.LinkedHashMap nameToSynpredASTMap</pre>
<div class="block">When we read in a grammar, we track the list of syntactic predicates
  and build faux rules for them later.  See my blog entry Dec 2, 2005:
  http://www.antlr.org/blog/antlr3/lookahead.tml
  This maps the name (we make up) for a pred to the AST grammar fragment.</div>
</li>
</ul>
<a name="atLeastOneRuleMemoizes">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atLeastOneRuleMemoizes</h4>
<pre>public&nbsp;boolean atLeastOneRuleMemoizes</pre>
<div class="block">At least one rule has memoize=true</div>
</li>
</ul>
<a name="atLeastOneBacktrackOption">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atLeastOneBacktrackOption</h4>
<pre>public&nbsp;boolean atLeastOneBacktrackOption</pre>
<div class="block">At least one backtrack=true in rule or decision or grammar.</div>
</li>
</ul>
<a name="implicitLexer">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>implicitLexer</h4>
<pre>public&nbsp;boolean implicitLexer</pre>
<div class="block">Was this created from a COMBINED grammar?</div>
</li>
</ul>
<a name="nameToRuleMap">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nameToRuleMap</h4>
<pre>protected&nbsp;java.util.LinkedHashMap&lt;java.lang.String,<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt; nameToRuleMap</pre>
<div class="block">Map a rule to it's Rule object</div>
</li>
</ul>
<a name="overriddenRules">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>overriddenRules</h4>
<pre>public&nbsp;java.util.Set&lt;java.lang.String&gt; overriddenRules</pre>
<div class="block">If this rule is a delegate, some rules might be overridden; don't
  want to gen code for them.</div>
</li>
</ul>
<a name="delegatedRuleReferences">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delegatedRuleReferences</h4>
<pre>protected&nbsp;java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt; delegatedRuleReferences</pre>
<div class="block">The list of all rules referenced in this grammar, not defined here,
  and defined in a delegate grammar.  Not all of these will be generated
  in the recognizer for this file; only those that are affected by rule
  definitions in this grammar.  I am not sure the Java target will need
  this but I'm leaving in case other targets need it.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>NameSpaceChecker.lookForReferencesToUndefinedSymbols()</code></dd></dl>
</li>
</ul>
<a name="lexerRuleNamesInCombined">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lexerRuleNamesInCombined</h4>
<pre>public&nbsp;java.util.List&lt;java.lang.String&gt; lexerRuleNamesInCombined</pre>
<div class="block">The ANTLRParser tracks lexer rules when reading combined grammars
  so we can build the Tokens rule.</div>
</li>
</ul>
<a name="scopes">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scopes</h4>
<pre>protected&nbsp;java.util.Map scopes</pre>
<div class="block">Track the scopes defined outside of rules and the scopes associated
  with all rules (even if empty).</div>
</li>
</ul>
<a name="grammarTree">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grammarTree</h4>
<pre>protected&nbsp;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a> grammarTree</pre>
<div class="block">An AST that records entire input grammar with all rules.  A simple
  grammar with one rule, "grammar t; a : A | B ;", looks like:
 ( grammar t ( rule a ( BLOCK ( ALT A ) ( ALT B ) ) <end-of-rule> ) )</div>
</li>
</ul>
<a name="indexToDecision">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indexToDecision</h4>
<pre>protected&nbsp;java.util.Vector&lt;<a href="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</a>&gt; indexToDecision</pre>
<div class="block">Each subrule/rule is a decision point and we must track them so we
  can go back later and build DFA predictors for them.  This includes
  all the rules, subrules, optional blocks, ()+, ()* etc...</div>
</li>
</ul>
<a name="generator">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generator</h4>
<pre>protected&nbsp;<a href="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</a> generator</pre>
<div class="block">If non-null, this is the code generator we will use to generate
  recognizers in the target language.</div>
</li>
</ul>
<a name="nameSpaceChecker">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nameSpaceChecker</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/NameSpaceChecker.html" title="class in org.antlr.tool">NameSpaceChecker</a> nameSpaceChecker</pre>
</li>
</ul>
<a name="ll1Analyzer">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ll1Analyzer</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/LL1Analyzer.html" title="class in org.antlr.analysis">LL1Analyzer</a> ll1Analyzer</pre>
</li>
</ul>
<a name="lexerGrammarST">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lexerGrammarST</h4>
<pre>protected&nbsp;org.antlr.stringtemplate.StringTemplate lexerGrammarST</pre>
<div class="block">For merged lexer/parsers, we must construct a separate lexer spec.
  This is the template for lexer; put the literals first then the
  regular rules.  We don't need to specify a token vocab import as
  I make the new grammar import from the old all in memory; don't want
  to force it to read from the disk.  Lexer grammar will have same
  name as original grammar but will be in different filename.  Foo.g
  with combined grammar will have FooParser.java generated and
  Foo__.g with again Foo inside.  It will however generate FooLexer.java
  as it's a lexer grammar.  A bit odd, but autogenerated.  Can tweak
  later if we want.</div>
</li>
</ul>
<a name="fileName">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fileName</h4>
<pre>protected&nbsp;java.lang.String fileName</pre>
<div class="block">What file name holds this grammar?</div>
</li>
</ul>
<a name="DFACreationWallClockTimeInMS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DFACreationWallClockTimeInMS</h4>
<pre>public&nbsp;long DFACreationWallClockTimeInMS</pre>
<div class="block">How long in ms did it take to build DFAs for this grammar?
  If this grammar is a combined grammar, it only records time for
  the parser grammar component.  This only records the time to
  do the LL(*) work; NFA->DFA conversion.</div>
</li>
</ul>
<a name="numberOfSemanticPredicates">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>numberOfSemanticPredicates</h4>
<pre>public&nbsp;int numberOfSemanticPredicates</pre>
</li>
</ul>
<a name="numberOfManualLookaheadOptions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>numberOfManualLookaheadOptions</h4>
<pre>public&nbsp;int numberOfManualLookaheadOptions</pre>
</li>
</ul>
<a name="setOfNondeterministicDecisionNumbers">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOfNondeterministicDecisionNumbers</h4>
<pre>public&nbsp;java.util.Set&lt;java.lang.Integer&gt; setOfNondeterministicDecisionNumbers</pre>
</li>
</ul>
<a name="setOfNondeterministicDecisionNumbersResolvedWithPredicates">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOfNondeterministicDecisionNumbersResolvedWithPredicates</h4>
<pre>public&nbsp;java.util.Set&lt;java.lang.Integer&gt; setOfNondeterministicDecisionNumbersResolvedWithPredicates</pre>
</li>
</ul>
<a name="setOfDFAWhoseAnalysisTimedOut">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOfDFAWhoseAnalysisTimedOut</h4>
<pre>public&nbsp;java.util.Set setOfDFAWhoseAnalysisTimedOut</pre>
</li>
</ul>
<a name="blocksWithSynPreds">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blocksWithSynPreds</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&gt; blocksWithSynPreds</pre>
<div class="block">Track decisions with syn preds specified for reporting.
  This is the a set of BLOCK type AST nodes.</div>
</li>
</ul>
<a name="decisionsWhoseDFAsUsesSynPreds">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decisionsWhoseDFAsUsesSynPreds</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&gt; decisionsWhoseDFAsUsesSynPreds</pre>
<div class="block">Track decisions that actually use the syn preds in the DFA.
  Computed during NFA to DFA conversion.</div>
</li>
</ul>
<a name="synPredNamesUsedInDFA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>synPredNamesUsedInDFA</h4>
<pre>public&nbsp;java.util.Set&lt;java.lang.String&gt; synPredNamesUsedInDFA</pre>
<div class="block">Track names of preds so we can avoid generating preds that aren't used
  Computed during NFA to DFA conversion.  Just walk accept states
  and look for synpreds because that is the only state target whose
  incident edges can have synpreds.  Same is try for
  decisionsWhoseDFAsUsesSynPreds.</div>
</li>
</ul>
<a name="blocksWithSemPreds">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blocksWithSemPreds</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&gt; blocksWithSemPreds</pre>
<div class="block">Track decisions with syn preds specified for reporting.
  This is the a set of BLOCK type AST nodes.</div>
</li>
</ul>
<a name="decisionsWhoseDFAsUsesSemPreds">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decisionsWhoseDFAsUsesSemPreds</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&gt; decisionsWhoseDFAsUsesSemPreds</pre>
<div class="block">Track decisions that actually use the syn preds in the DFA.</div>
</li>
</ul>
<a name="allDecisionDFACreated">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allDecisionDFACreated</h4>
<pre>protected&nbsp;boolean allDecisionDFACreated</pre>
</li>
</ul>
<a name="builtFromString">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>builtFromString</h4>
<pre>protected&nbsp;boolean builtFromString</pre>
<div class="block">We need a way to detect when a lexer grammar is autogenerated from
  another grammar or we are just sending in a string representing a
  grammar.  We don't want to generate a .tokens file, for example,
  in such cases.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Grammar(org.antlr.Tool, java.lang.String, org.antlr.tool.CompositeGrammar)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Grammar</h4>
<pre>public&nbsp;Grammar(<a href="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</a>&nbsp;tool,
       java.lang.String&nbsp;fileName,
       <a href="../../../org/antlr/tool/CompositeGrammar.html" title="class in org.antlr.tool">CompositeGrammar</a>&nbsp;composite)</pre>
<div class="block">Create a grammar from file name.</div>
</li>
</ul>
<a name="Grammar()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Grammar</h4>
<pre>public&nbsp;Grammar()</pre>
<div class="block">Useful for when you are sure that you are not part of a composite
  already.  Used in Interp/RandomPhrase and testing.</div>
</li>
</ul>
<a name="Grammar(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Grammar</h4>
<pre>public&nbsp;Grammar(java.lang.String&nbsp;grammarString)
        throws antlr.RecognitionException,
               antlr.TokenStreamException</pre>
<div class="block">Used for testing; only useful on noncomposite grammars.</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>antlr.RecognitionException</code></dd>
<dd><code>antlr.TokenStreamException</code></dd></dl>
</li>
</ul>
<a name="Grammar(org.antlr.Tool, java.lang.String)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Grammar</h4>
<pre>public&nbsp;Grammar(<a href="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</a>&nbsp;tool,
       java.lang.String&nbsp;grammarString)
        throws antlr.RecognitionException</pre>
<div class="block">Used for testing and Interp/RandomPhrase.  Only useful on
  noncomposite grammars.</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>antlr.RecognitionException</code></dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="setFileName(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFileName</h4>
<pre>public&nbsp;void&nbsp;setFileName(java.lang.String&nbsp;fileName)</pre>
</li>
</ul>
<a name="getFileName()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFileName</h4>
<pre>public&nbsp;java.lang.String&nbsp;getFileName()</pre>
</li>
</ul>
<a name="setName(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setName</h4>
<pre>public&nbsp;void&nbsp;setName(java.lang.String&nbsp;name)</pre>
</li>
</ul>
<a name="setGrammarContent(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setGrammarContent</h4>
<pre>public&nbsp;void&nbsp;setGrammarContent(java.lang.String&nbsp;grammarString)
                       throws antlr.RecognitionException</pre>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>antlr.RecognitionException</code></dd></dl>
</li>
</ul>
<a name="parseAndBuildAST()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parseAndBuildAST</h4>
<pre>public&nbsp;void&nbsp;parseAndBuildAST()
                      throws java.io.IOException</pre>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="parseAndBuildAST(java.io.Reader)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parseAndBuildAST</h4>
<pre>public&nbsp;void&nbsp;parseAndBuildAST(java.io.Reader&nbsp;r)</pre>
</li>
</ul>
<a name="dealWithTreeFilterMode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dealWithTreeFilterMode</h4>
<pre>protected&nbsp;void&nbsp;dealWithTreeFilterMode()</pre>
</li>
</ul>
<a name="defineGrammarSymbols()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineGrammarSymbols</h4>
<pre>public&nbsp;void&nbsp;defineGrammarSymbols()</pre>
</li>
</ul>
<a name="checkNameSpaceAndActions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkNameSpaceAndActions</h4>
<pre>public&nbsp;void&nbsp;checkNameSpaceAndActions()</pre>
<div class="block">ANALYZE ACTIONS, LOOKING FOR LABEL AND ATTR REFS, sanity check</div>
</li>
</ul>
<a name="validImport(org.antlr.tool.Grammar)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validImport</h4>
<pre>public&nbsp;boolean&nbsp;validImport(<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&nbsp;delegate)</pre>
<div class="block">Many imports are illegal such as lexer into a tree grammar</div>
</li>
</ul>
<a name="getLexerGrammar()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLexerGrammar</h4>
<pre>public&nbsp;java.lang.String&nbsp;getLexerGrammar()</pre>
<div class="block">If the grammar is a combined grammar, return the text of the implicit
  lexer grammar.</div>
</li>
</ul>
<a name="getImplicitlyGeneratedLexerFileName()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getImplicitlyGeneratedLexerFileName</h4>
<pre>public&nbsp;java.lang.String&nbsp;getImplicitlyGeneratedLexerFileName()</pre>
</li>
</ul>
<a name="getRecognizerName()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRecognizerName</h4>
<pre>public&nbsp;java.lang.String&nbsp;getRecognizerName()</pre>
<div class="block">Get the name of the generated recognizer; may or may not be same
  as grammar name.
  Recognizer is TParser and TLexer from T if combined, else
  just use T regardless of grammar type.</div>
</li>
</ul>
<a name="addArtificialMatchTokensRule(org.antlr.tool.GrammarAST, java.util.List, java.util.List, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addArtificialMatchTokensRule</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;addArtificialMatchTokensRule(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;grammarAST,
                                      java.util.List&lt;java.lang.String&gt;&nbsp;ruleNames,
                                      java.util.List&lt;java.lang.String&gt;&nbsp;delegateNames,
                                      boolean&nbsp;filterMode)</pre>
<div class="block">Parse a rule we add artificially that is a list of the other lexer
  rules like this: "Tokens : ID | INT | SEMI ;"  nextToken() will invoke
  this to set the current token.  Add char literals before
  the rule references.

  If in filter mode, we want every alt to backtrack and we need to
  do k=1 to force the "first token def wins" rule.  Otherwise, the
  longest-match rule comes into play with LL(*).

  The ANTLRParser antlr.g file now invokes this when parsing a lexer
  grammar, which I think is proper even though it peeks at the info
  that later phases will (re)compute.  It gets a list of lexer rules
  and builds a string representing the rule; then it creates a parser
  and adds the resulting tree to the grammar's tree.</div>
</li>
</ul>
<a name="getArtificialRulesForSyntacticPredicates(org.antlr.grammar.v2.ANTLRParser, java.util.LinkedHashMap)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getArtificialRulesForSyntacticPredicates</h4>
<pre>protected&nbsp;java.util.List&nbsp;getArtificialRulesForSyntacticPredicates(<a href="../../../org/antlr/grammar/v2/ANTLRParser.html" title="class in org.antlr.grammar.v2">ANTLRParser</a>&nbsp;parser,
                                                      java.util.LinkedHashMap&nbsp;nameToSynpredASTMap)</pre>
<div class="block">for any syntactic predicates, we need to define rules for them; they will get
  defined automatically like any other rule. :)</div>
</li>
</ul>
<a name="createRuleStartAndStopNFAStates()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRuleStartAndStopNFAStates</h4>
<pre>public&nbsp;void&nbsp;createRuleStartAndStopNFAStates()</pre>
<div class="block">Define all the rule begin/end NFAStates to solve forward reference
  issues.  Critical for composite grammars too.
  This is normally called on all root/delegates manually and then
  buildNFA() is called afterwards because the NFA construction needs
  to see rule start/stop states from potentially every grammar. Has
  to be have these created a priori.  Testing routines will often
  just call buildNFA(), which forces a call to this method if not
  done already. Works ONLY for single noncomposite grammars.</div>
</li>
</ul>
<a name="buildNFA()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildNFA</h4>
<pre>public&nbsp;void&nbsp;buildNFA()</pre>
</li>
</ul>
<a name="createLookaheadDFAs()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLookaheadDFAs</h4>
<pre>public&nbsp;void&nbsp;createLookaheadDFAs()</pre>
<div class="block">For each decision in this grammar, compute a single DFA using the
  NFA states associated with the decision.  The DFA construction
  determines whether or not the alternatives in the decision are
  separable using a regular lookahead language.

  Store the lookahead DFAs in the AST created from the user's grammar
  so the code generator or whoever can easily access it.

  This is a separate method because you might want to create a
  Grammar without doing the expensive analysis.</div>
</li>
</ul>
<a name="createLookaheadDFAs(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLookaheadDFAs</h4>
<pre>public&nbsp;void&nbsp;createLookaheadDFAs(boolean&nbsp;wackTempStructures)</pre>
</li>
</ul>
<a name="createLL_1_LookaheadDFA(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLL_1_LookaheadDFA</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&nbsp;createLL_1_LookaheadDFA(int&nbsp;decision)</pre>
</li>
</ul>
<a name="makeEdgeSetsDisjoint(java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeEdgeSetsDisjoint</h4>
<pre>protected&nbsp;java.util.List&lt;<a href="../../../org/antlr/misc/IntervalSet.html" title="class in org.antlr.misc">IntervalSet</a>&gt;&nbsp;makeEdgeSetsDisjoint(java.util.List&lt;<a href="../../../org/antlr/misc/IntervalSet.html" title="class in org.antlr.misc">IntervalSet</a>&gt;&nbsp;edges)</pre>
</li>
</ul>
<a name="createLookaheadDFA(int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLookaheadDFA</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&nbsp;createLookaheadDFA(int&nbsp;decision,
                     boolean&nbsp;wackTempStructures)</pre>
</li>
</ul>
<a name="externallyAbortNFAToDFAConversion()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>externallyAbortNFAToDFAConversion</h4>
<pre>public&nbsp;void&nbsp;externallyAbortNFAToDFAConversion()</pre>
<div class="block">Terminate DFA creation (grammar analysis).</div>
</li>
</ul>
<a name="NFAToDFAConversionExternallyAborted()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NFAToDFAConversionExternallyAborted</h4>
<pre>public&nbsp;boolean&nbsp;NFAToDFAConversionExternallyAborted()</pre>
</li>
</ul>
<a name="getNewTokenType()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNewTokenType</h4>
<pre>public&nbsp;int&nbsp;getNewTokenType()</pre>
<div class="block">Return a new unique integer in the token type space</div>
</li>
</ul>
<a name="defineToken(java.lang.String, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineToken</h4>
<pre>public&nbsp;void&nbsp;defineToken(java.lang.String&nbsp;text,
               int&nbsp;tokenType)</pre>
<div class="block">Define a token at a particular token type value.  Blast an
  old value with a new one.  This is called normal grammar processsing
  and during import vocab operations to set tokens with specific values.</div>
</li>
</ul>
<a name="defineRule(antlr.Token, java.lang.String, java.util.Map, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineRule</h4>
<pre>public&nbsp;void&nbsp;defineRule(antlr.Token&nbsp;ruleToken,
              java.lang.String&nbsp;modifier,
              java.util.Map&nbsp;options,
              <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;tree,
              <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;argActionAST,
              int&nbsp;numAlts)</pre>
<div class="block">Define a new rule.  A new rule index is created by incrementing
  ruleIndex.</div>
</li>
</ul>
<a name="defineSyntacticPredicate(org.antlr.tool.GrammarAST, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineSyntacticPredicate</h4>
<pre>public&nbsp;java.lang.String&nbsp;defineSyntacticPredicate(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;blockAST,
                                        java.lang.String&nbsp;currentRuleName)</pre>
<div class="block">Define a new predicate and get back its name for use in building
  a semantic predicate reference to the syn pred.</div>
</li>
</ul>
<a name="getSyntacticPredicates()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSyntacticPredicates</h4>
<pre>public&nbsp;java.util.LinkedHashMap&nbsp;getSyntacticPredicates()</pre>
</li>
</ul>
<a name="getSyntacticPredicate(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSyntacticPredicate</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;getSyntacticPredicate(java.lang.String&nbsp;name)</pre>
</li>
</ul>
<a name="synPredUsedInDFA(org.antlr.analysis.DFA, org.antlr.analysis.SemanticContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>synPredUsedInDFA</h4>
<pre>public&nbsp;void&nbsp;synPredUsedInDFA(<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&nbsp;dfa,
                    <a href="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</a>&nbsp;semCtx)</pre>
</li>
</ul>
<a name="defineNamedAction(org.antlr.tool.GrammarAST, java.lang.String, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineNamedAction</h4>
<pre>public&nbsp;void&nbsp;defineNamedAction(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;ampersandAST,
                     java.lang.String&nbsp;scope,
                     <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;nameAST,
                     <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;actionAST)</pre>
<div class="block">Given @scope::name {action} define it for this grammar.  Later,
  the code generator will ask for the actions table.  For composite
  grammars, make sure header action propogates down to all delegates.</div>
</li>
</ul>
<a name="setSynPredGateIfNotAlready(org.antlr.stringtemplate.StringTemplate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSynPredGateIfNotAlready</h4>
<pre>public&nbsp;void&nbsp;setSynPredGateIfNotAlready(org.antlr.stringtemplate.StringTemplate&nbsp;gateST)</pre>
</li>
</ul>
<a name="getActions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getActions</h4>
<pre>public&nbsp;java.util.Map&nbsp;getActions()</pre>
</li>
</ul>
<a name="getDefaultActionScope(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDefaultActionScope</h4>
<pre>public&nbsp;java.lang.String&nbsp;getDefaultActionScope(int&nbsp;grammarType)</pre>
<div class="block">Given a grammar type, what should be the default action scope?
  If I say @members in a COMBINED grammar, for example, the
  default scope should be "parser".</div>
</li>
</ul>
<a name="defineLexerRuleFoundInParser(antlr.Token, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineLexerRuleFoundInParser</h4>
<pre>public&nbsp;void&nbsp;defineLexerRuleFoundInParser(antlr.Token&nbsp;ruleToken,
                                <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;ruleAST)</pre>
</li>
</ul>
<a name="defineLexerRuleForAliasedStringLiteral(java.lang.String, java.lang.String, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineLexerRuleForAliasedStringLiteral</h4>
<pre>public&nbsp;void&nbsp;defineLexerRuleForAliasedStringLiteral(java.lang.String&nbsp;tokenID,
                                          java.lang.String&nbsp;literal,
                                          int&nbsp;tokenType)</pre>
<div class="block">If someone does PLUS='+' in the parser, must make sure we get
  "PLUS : '+' ;" in lexer not "T73 : '+';"</div>
</li>
</ul>
<a name="defineLexerRuleForStringLiteral(java.lang.String, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineLexerRuleForStringLiteral</h4>
<pre>public&nbsp;void&nbsp;defineLexerRuleForStringLiteral(java.lang.String&nbsp;literal,
                                   int&nbsp;tokenType)</pre>
</li>
</ul>
<a name="getLocallyDefinedRule(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLocallyDefinedRule</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&nbsp;getLocallyDefinedRule(java.lang.String&nbsp;ruleName)</pre>
</li>
</ul>
<a name="getRule(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRule</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&nbsp;getRule(java.lang.String&nbsp;ruleName)</pre>
</li>
</ul>
<a name="getRule(java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRule</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&nbsp;getRule(java.lang.String&nbsp;scopeName,
           java.lang.String&nbsp;ruleName)</pre>
</li>
</ul>
<a name="getRuleIndex(java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRuleIndex</h4>
<pre>public&nbsp;int&nbsp;getRuleIndex(java.lang.String&nbsp;scopeName,
               java.lang.String&nbsp;ruleName)</pre>
</li>
</ul>
<a name="getRuleIndex(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRuleIndex</h4>
<pre>public&nbsp;int&nbsp;getRuleIndex(java.lang.String&nbsp;ruleName)</pre>
</li>
</ul>
<a name="getRuleName(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRuleName</h4>
<pre>public&nbsp;java.lang.String&nbsp;getRuleName(int&nbsp;ruleIndex)</pre>
</li>
</ul>
<a name="generateMethodForRule(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateMethodForRule</h4>
<pre>public&nbsp;boolean&nbsp;generateMethodForRule(java.lang.String&nbsp;ruleName)</pre>
<div class="block">Should codegen.g gen rule for ruleName?
        If synpred, only gen if used in a DFA.
  If regular rule, only gen if not overridden in delegator
  Always gen Tokens rule though.</div>
</li>
</ul>
<a name="defineGlobalScope(java.lang.String, antlr.Token)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineGlobalScope</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</a>&nbsp;defineGlobalScope(java.lang.String&nbsp;name,
                               antlr.Token&nbsp;scopeAction)</pre>
</li>
</ul>
<a name="createReturnScope(java.lang.String, antlr.Token)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createReturnScope</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</a>&nbsp;createReturnScope(java.lang.String&nbsp;ruleName,
                               antlr.Token&nbsp;retAction)</pre>
</li>
</ul>
<a name="createRuleScope(java.lang.String, antlr.Token)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRuleScope</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</a>&nbsp;createRuleScope(java.lang.String&nbsp;ruleName,
                             antlr.Token&nbsp;scopeAction)</pre>
</li>
</ul>
<a name="createParameterScope(java.lang.String, antlr.Token)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createParameterScope</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</a>&nbsp;createParameterScope(java.lang.String&nbsp;ruleName,
                                  antlr.Token&nbsp;argAction)</pre>
</li>
</ul>
<a name="getGlobalScope(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGlobalScope</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/AttributeScope.html" title="class in org.antlr.tool">AttributeScope</a>&nbsp;getGlobalScope(java.lang.String&nbsp;name)</pre>
<div class="block">Get a global scope</div>
</li>
</ul>
<a name="getGlobalScopes()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGlobalScopes</h4>
<pre>public&nbsp;java.util.Map&nbsp;getGlobalScopes()</pre>
</li>
</ul>
<a name="defineLabel(org.antlr.tool.Rule, antlr.Token, org.antlr.tool.GrammarAST, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineLabel</h4>
<pre>protected&nbsp;void&nbsp;defineLabel(<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&nbsp;r,
               antlr.Token&nbsp;label,
               <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;element,
               int&nbsp;type)</pre>
<div class="block">Define a label defined in a rule r; check the validity then ask the
  Rule object to actually define it.</div>
</li>
</ul>
<a name="defineTokenRefLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineTokenRefLabel</h4>
<pre>public&nbsp;void&nbsp;defineTokenRefLabel(java.lang.String&nbsp;ruleName,
                       antlr.Token&nbsp;label,
                       <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;tokenRef)</pre>
</li>
</ul>
<a name="defineWildcardTreeLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineWildcardTreeLabel</h4>
<pre>public&nbsp;void&nbsp;defineWildcardTreeLabel(java.lang.String&nbsp;ruleName,
                           antlr.Token&nbsp;label,
                           <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;tokenRef)</pre>
</li>
</ul>
<a name="defineWildcardTreeListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineWildcardTreeListLabel</h4>
<pre>public&nbsp;void&nbsp;defineWildcardTreeListLabel(java.lang.String&nbsp;ruleName,
                               antlr.Token&nbsp;label,
                               <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;tokenRef)</pre>
</li>
</ul>
<a name="defineRuleRefLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineRuleRefLabel</h4>
<pre>public&nbsp;void&nbsp;defineRuleRefLabel(java.lang.String&nbsp;ruleName,
                      antlr.Token&nbsp;label,
                      <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;ruleRef)</pre>
</li>
</ul>
<a name="defineTokenListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineTokenListLabel</h4>
<pre>public&nbsp;void&nbsp;defineTokenListLabel(java.lang.String&nbsp;ruleName,
                        antlr.Token&nbsp;label,
                        <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;element)</pre>
</li>
</ul>
<a name="defineRuleListLabel(java.lang.String, antlr.Token, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineRuleListLabel</h4>
<pre>public&nbsp;void&nbsp;defineRuleListLabel(java.lang.String&nbsp;ruleName,
                       antlr.Token&nbsp;label,
                       <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;element)</pre>
</li>
</ul>
<a name="getLabels(java.util.Set, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLabels</h4>
<pre>public&nbsp;java.util.Set&lt;java.lang.String&gt;&nbsp;getLabels(java.util.Set&lt;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&gt;&nbsp;rewriteElements,
                                        int&nbsp;labelType)</pre>
<div class="block">Given a set of all rewrite elements on right of ->, filter for
  label types such as Grammar.TOKEN_LABEL, Grammar.TOKEN_LIST_LABEL, ...
  Return a displayable token type name computed from the GrammarAST.</div>
</li>
</ul>
<a name="examineAllExecutableActions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>examineAllExecutableActions</h4>
<pre>protected&nbsp;void&nbsp;examineAllExecutableActions()</pre>
<div class="block">Before generating code, we examine all actions that can have
  $x.y and $y stuff in them because some code generation depends on
  Rule.referencedPredefinedRuleAttributes.  I need to remove unused
  rule labels for example.</div>
</li>
</ul>
<a name="checkAllRulesForUselessLabels()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkAllRulesForUselessLabels</h4>
<pre>public&nbsp;void&nbsp;checkAllRulesForUselessLabels()</pre>
<div class="block">Remove all labels on rule refs whose target rules have no return value.
  Do this for all rules in grammar.</div>
</li>
</ul>
<a name="removeUselessLabels(java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeUselessLabels</h4>
<pre>protected&nbsp;void&nbsp;removeUselessLabels(java.util.Map&nbsp;ruleToElementLabelPairMap)</pre>
<div class="block">A label on a rule is useless if the rule has no return value, no
  tree or template output, and it is not referenced in an action.</div>
</li>
</ul>
<a name="altReferencesRule(java.lang.String, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>altReferencesRule</h4>
<pre>public&nbsp;void&nbsp;altReferencesRule(java.lang.String&nbsp;enclosingRuleName,
                     <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;refScopeAST,
                     <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;refAST,
                     int&nbsp;outerAltNum)</pre>
<div class="block">Track a rule reference within an outermost alt of a rule.  Used
  at the moment to decide if $ruleref refers to a unique rule ref in
  the alt.  Rewrite rules force tracking of all rule AST results.

  This data is also used to verify that all rules have been defined.</div>
</li>
</ul>
<a name="altReferencesTokenID(java.lang.String, org.antlr.tool.GrammarAST, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>altReferencesTokenID</h4>
<pre>public&nbsp;void&nbsp;altReferencesTokenID(java.lang.String&nbsp;ruleName,
                        <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;refAST,
                        int&nbsp;outerAltNum)</pre>
<div class="block">Track a token reference within an outermost alt of a rule.  Used
  to decide if $tokenref refers to a unique token ref in
  the alt. Does not track literals!

  Rewrite rules force tracking of all tokens.</div>
</li>
</ul>
<a name="referenceRuleLabelPredefinedAttribute(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>referenceRuleLabelPredefinedAttribute</h4>
<pre>public&nbsp;void&nbsp;referenceRuleLabelPredefinedAttribute(java.lang.String&nbsp;ruleName)</pre>
<div class="block">To yield smaller, more readable code, track which rules have their
  predefined attributes accessed.  If the rule has no user-defined
  return values, then don't generate the return value scope classes
  etc...  Make the rule have void return value.  Don't track for lexer
  rules.</div>
</li>
</ul>
<a name="checkAllRulesForLeftRecursion()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkAllRulesForLeftRecursion</h4>
<pre>public&nbsp;java.util.List&nbsp;checkAllRulesForLeftRecursion()</pre>
</li>
</ul>
<a name="getLeftRecursiveRules()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLeftRecursiveRules</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;&nbsp;getLeftRecursiveRules()</pre>
<div class="block">Return a list of left-recursive rules; no analysis can be done
  successfully on these.  Useful to skip these rules then and also
  for ANTLRWorks to highlight them.</div>
</li>
</ul>
<a name="checkRuleReference(org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, org.antlr.tool.GrammarAST, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkRuleReference</h4>
<pre>public&nbsp;void&nbsp;checkRuleReference(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;scopeAST,
                      <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;refAST,
                      <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;argsAST,
                      java.lang.String&nbsp;currentRuleName)</pre>
</li>
</ul>
<a name="isEmptyRule(org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isEmptyRule</h4>
<pre>public&nbsp;boolean&nbsp;isEmptyRule(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;block)</pre>
<div class="block">Rules like "a : ;" and "a : {...} ;" should not generate
  try/catch blocks for RecognitionException.  To detect this
  it's probably ok to just look for any reference to an atom
  that can match some input.  W/o that, the rule is unlikey to have
  any else.</div>
</li>
</ul>
<a name="isAtomTokenType(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isAtomTokenType</h4>
<pre>public&nbsp;boolean&nbsp;isAtomTokenType(int&nbsp;ttype)</pre>
</li>
</ul>
<a name="getTokenType(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTokenType</h4>
<pre>public&nbsp;int&nbsp;getTokenType(java.lang.String&nbsp;tokenName)</pre>
</li>
</ul>
<a name="getTokenIDs()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTokenIDs</h4>
<pre>public&nbsp;java.util.Set&nbsp;getTokenIDs()</pre>
<div class="block">Get the list of tokens that are IDs like BLOCK and LPAREN</div>
</li>
</ul>
<a name="getTokenTypesWithoutID()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTokenTypesWithoutID</h4>
<pre>public&nbsp;java.util.Collection&nbsp;getTokenTypesWithoutID()</pre>
<div class="block">Return an ordered integer list of token types that have no
  corresponding token ID like INT or KEYWORD_BEGIN; for stuff
  like 'begin'.</div>
</li>
</ul>
<a name="getTokenDisplayNames()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTokenDisplayNames</h4>
<pre>public&nbsp;java.util.Set&lt;java.lang.String&gt;&nbsp;getTokenDisplayNames()</pre>
<div class="block">Get a list of all token IDs and literals that have an associated
  token type.</div>
</li>
</ul>
<a name="getCharValueFromGrammarCharLiteral(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCharValueFromGrammarCharLiteral</h4>
<pre>public static&nbsp;int&nbsp;getCharValueFromGrammarCharLiteral(java.lang.String&nbsp;literal)</pre>
<div class="block">Given a literal like (the 3 char sequence with single quotes) 'a',
  return the int value of 'a'. Convert escape sequences here also.
  ANTLR's antlr.g parser does not convert escape sequences.

  11/26/2005: I changed literals to always be '...' even for strings.
  This routine still works though.</div>
</li>
</ul>
<a name="getUnescapedStringFromGrammarStringLiteral(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUnescapedStringFromGrammarStringLiteral</h4>
<pre>public static&nbsp;java.lang.StringBuffer&nbsp;getUnescapedStringFromGrammarStringLiteral(java.lang.String&nbsp;literal)</pre>
<div class="block">ANTLR does not convert escape sequences during the parse phase because
  it could not know how to print String/char literals back out when
  printing grammars etc...  Someone in China might use the real unicode
  char in a literal as it will display on their screen; when printing
  back out, I could not know whether to display or use a unicode escape.

  This routine converts a string literal with possible escape sequences
  into a pure string of 16-bit char values.  Escapes and unicode  
  specs are converted to pure chars.  return in a buffer; people may
  want to walk/manipulate further.

  The NFA construction routine must know the actual char values.</div>
</li>
</ul>
<a name="importTokenVocabulary(org.antlr.tool.Grammar)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>importTokenVocabulary</h4>
<pre>public&nbsp;int&nbsp;importTokenVocabulary(<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&nbsp;importFromGr)</pre>
<div class="block">Pull your token definitions from an existing grammar in memory.
  You must use Grammar() ctor then this method then setGrammarContent()
  to make this work.  This was useful primarily for testing and
  interpreting grammars until I added import grammar functionality.
  When you import a grammar you implicitly import its vocabulary as well
  and keep the same token type values.

  Returns the max token type found.</div>
</li>
</ul>
<a name="importGrammar(org.antlr.tool.GrammarAST, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>importGrammar</h4>
<pre>public&nbsp;void&nbsp;importGrammar(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;grammarNameAST,
                 java.lang.String&nbsp;label)</pre>
<div class="block">Import the rules/tokens of a delegate grammar. All delegate grammars are
  read during the ctor of first Grammar created.

  Do not create NFA here because NFA construction needs to hook up with
  overridden rules in delegation root grammar.</div>
</li>
</ul>
<a name="addDelegateGrammar(org.antlr.tool.Grammar)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addDelegateGrammar</h4>
<pre>protected&nbsp;void&nbsp;addDelegateGrammar(<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&nbsp;delegateGrammar)</pre>
<div class="block">add new delegate to composite tree</div>
</li>
</ul>
<a name="importTokenVocabulary(org.antlr.tool.GrammarAST, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>importTokenVocabulary</h4>
<pre>public&nbsp;int&nbsp;importTokenVocabulary(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;tokenVocabOptionAST,
                        java.lang.String&nbsp;vocabName)</pre>
<div class="block">Load a vocab file <vocabName>.tokens and return max token type found.</div>
</li>
</ul>
<a name="getTokenDisplayName(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTokenDisplayName</h4>
<pre>public&nbsp;java.lang.String&nbsp;getTokenDisplayName(int&nbsp;ttype)</pre>
<div class="block">Given a token type, get a meaningful name for it such as the ID
  or string literal.  If this is a lexer and the ttype is in the
  char vocabulary, compute an ANTLR-valid (possibly escaped) char literal.</div>
</li>
</ul>
<a name="getStringLiterals()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStringLiterals</h4>
<pre>public&nbsp;java.util.Set&lt;java.lang.String&gt;&nbsp;getStringLiterals()</pre>
<div class="block">Get the list of ANTLR String literals</div>
</li>
</ul>
<a name="getGrammarTypeString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGrammarTypeString</h4>
<pre>public&nbsp;java.lang.String&nbsp;getGrammarTypeString()</pre>
</li>
</ul>
<a name="getGrammarMaxLookahead()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGrammarMaxLookahead</h4>
<pre>public&nbsp;int&nbsp;getGrammarMaxLookahead()</pre>
</li>
</ul>
<a name="setOption(java.lang.String, java.lang.Object, antlr.Token)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOption</h4>
<pre>public&nbsp;java.lang.String&nbsp;setOption(java.lang.String&nbsp;key,
                         java.lang.Object&nbsp;value,
                         antlr.Token&nbsp;optionsStartToken)</pre>
<div class="block">Save the option key/value pair and process it; return the key
  or null if invalid option.</div>
</li>
</ul>
<a name="legalOption(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>legalOption</h4>
<pre>public&nbsp;boolean&nbsp;legalOption(java.lang.String&nbsp;key)</pre>
</li>
</ul>
<a name="setOptions(java.util.Map, antlr.Token)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOptions</h4>
<pre>public&nbsp;void&nbsp;setOptions(java.util.Map&nbsp;options,
              antlr.Token&nbsp;optionsStartToken)</pre>
</li>
</ul>
<a name="getOption(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOption</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getOption(java.lang.String&nbsp;key)</pre>
</li>
</ul>
<a name="getLocallyDefinedOption(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLocallyDefinedOption</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getLocallyDefinedOption(java.lang.String&nbsp;key)</pre>
</li>
</ul>
<a name="getBlockOption(org.antlr.tool.GrammarAST, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBlockOption</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getBlockOption(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;blockAST,
                              java.lang.String&nbsp;key)</pre>
</li>
</ul>
<a name="getUserMaxLookahead(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUserMaxLookahead</h4>
<pre>public&nbsp;int&nbsp;getUserMaxLookahead(int&nbsp;decision)</pre>
</li>
</ul>
<a name="getAutoBacktrackMode(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAutoBacktrackMode</h4>
<pre>public&nbsp;boolean&nbsp;getAutoBacktrackMode(int&nbsp;decision)</pre>
</li>
</ul>
<a name="optionIsValid(java.lang.String, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>optionIsValid</h4>
<pre>public&nbsp;boolean&nbsp;optionIsValid(java.lang.String&nbsp;key,
                    java.lang.Object&nbsp;value)</pre>
</li>
</ul>
<a name="buildAST()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildAST</h4>
<pre>public&nbsp;boolean&nbsp;buildAST()</pre>
</li>
</ul>
<a name="rewriteMode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rewriteMode</h4>
<pre>public&nbsp;boolean&nbsp;rewriteMode()</pre>
</li>
</ul>
<a name="isBuiltFromString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isBuiltFromString</h4>
<pre>public&nbsp;boolean&nbsp;isBuiltFromString()</pre>
</li>
</ul>
<a name="buildTemplate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildTemplate</h4>
<pre>public&nbsp;boolean&nbsp;buildTemplate()</pre>
</li>
</ul>
<a name="getRules()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRules</h4>
<pre>public&nbsp;java.util.Collection&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;&nbsp;getRules()</pre>
</li>
</ul>
<a name="getDelegatedRules()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDelegatedRules</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;&nbsp;getDelegatedRules()</pre>
<div class="block">Get the set of Rules that need to have manual delegations
  like "void rule() { importedGrammar.rule(); }"

  If this grammar is master, get list of all rule definitions from all
  delegate grammars.  Only master has complete interface from combined
  grammars...we will generated delegates as helper objects.

  Composite grammars that are not the root/master do not have complete
  interfaces.  It is not my intention that people use subcomposites.
  Only the outermost grammar should be used from outside code.  The
  other grammar components are specifically generated to work only
  with the master/root. 

  delegatedRules = imported - overridden</div>
</li>
</ul>
<a name="getAllImportedRules()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAllImportedRules</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;&nbsp;getAllImportedRules()</pre>
<div class="block">Get set of all rules imported from all delegate grammars even if
  indirectly delegated.</div>
</li>
</ul>
<a name="getDelegates()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDelegates</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&gt;&nbsp;getDelegates()</pre>
<div class="block">Get list of all delegates from all grammars directly or indirectly
  imported into this grammar.</div>
</li>
</ul>
<a name="getDelegateNames()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDelegateNames</h4>
<pre>public&nbsp;java.util.List&lt;java.lang.String&gt;&nbsp;getDelegateNames()</pre>
</li>
</ul>
<a name="getDirectDelegates()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDirectDelegates</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&gt;&nbsp;getDirectDelegates()</pre>
</li>
</ul>
<a name="getIndirectDelegates()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIndirectDelegates</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&gt;&nbsp;getIndirectDelegates()</pre>
<div class="block">Get delegates below direct delegates</div>
</li>
</ul>
<a name="getDelegators()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDelegators</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&gt;&nbsp;getDelegators()</pre>
<div class="block">Get list of all delegators.  This amounts to the grammars on the path
  to the root of the delegation tree.</div>
</li>
</ul>
<a name="getDelegator()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDelegator</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/Grammar.html" title="class in org.antlr.tool">Grammar</a>&nbsp;getDelegator()</pre>
<div class="block">Who's my direct parent grammar?</div>
</li>
</ul>
<a name="getDelegatedRuleReferences()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDelegatedRuleReferences</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../org/antlr/tool/Rule.html" title="class in org.antlr.tool">Rule</a>&gt;&nbsp;getDelegatedRuleReferences()</pre>
</li>
</ul>
<a name="getGrammarIsRoot()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGrammarIsRoot</h4>
<pre>public&nbsp;boolean&nbsp;getGrammarIsRoot()</pre>
</li>
</ul>
<a name="setRuleAST(java.lang.String, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRuleAST</h4>
<pre>public&nbsp;void&nbsp;setRuleAST(java.lang.String&nbsp;ruleName,
              <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;t)</pre>
</li>
</ul>
<a name="getRuleStartState(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRuleStartState</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;getRuleStartState(java.lang.String&nbsp;ruleName)</pre>
</li>
</ul>
<a name="getRuleStartState(java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRuleStartState</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;getRuleStartState(java.lang.String&nbsp;scopeName,
                         java.lang.String&nbsp;ruleName)</pre>
</li>
</ul>
<a name="getRuleModifier(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRuleModifier</h4>
<pre>public&nbsp;java.lang.String&nbsp;getRuleModifier(java.lang.String&nbsp;ruleName)</pre>
</li>
</ul>
<a name="getRuleStopState(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRuleStopState</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;getRuleStopState(java.lang.String&nbsp;ruleName)</pre>
</li>
</ul>
<a name="assignDecisionNumber(org.antlr.analysis.NFAState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>assignDecisionNumber</h4>
<pre>public&nbsp;int&nbsp;assignDecisionNumber(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;state)</pre>
</li>
</ul>
<a name="getDecision(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDecision</h4>
<pre>protected&nbsp;<a href="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</a>&nbsp;getDecision(int&nbsp;decision)</pre>
</li>
</ul>
<a name="createDecision(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDecision</h4>
<pre>protected&nbsp;<a href="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool">Grammar.Decision</a>&nbsp;createDecision(int&nbsp;decision)</pre>
</li>
</ul>
<a name="getDecisionNFAStartStateList()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDecisionNFAStartStateList</h4>
<pre>public&nbsp;java.util.List&nbsp;getDecisionNFAStartStateList()</pre>
</li>
</ul>
<a name="getDecisionNFAStartState(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDecisionNFAStartState</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;getDecisionNFAStartState(int&nbsp;decision)</pre>
</li>
</ul>
<a name="getLookaheadDFA(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLookaheadDFA</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&nbsp;getLookaheadDFA(int&nbsp;decision)</pre>
</li>
</ul>
<a name="getDecisionBlockAST(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDecisionBlockAST</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;getDecisionBlockAST(int&nbsp;decision)</pre>
</li>
</ul>
<a name="getLookaheadDFAColumnsForLineInFile(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLookaheadDFAColumnsForLineInFile</h4>
<pre>public&nbsp;java.util.List&nbsp;getLookaheadDFAColumnsForLineInFile(int&nbsp;line)</pre>
<div class="block">returns a list of column numbers for all decisions
  on a particular line so ANTLRWorks choose the decision
  depending on the location of the cursor (otherwise,
  ANTLRWorks has to give the *exact* location which
  is not easy from the user point of view).

  This is not particularly fast as it walks entire line:col->DFA map
  looking for a prefix of "line:".</div>
</li>
</ul>
<a name="getLookaheadDFAFromPositionInFile(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLookaheadDFAFromPositionInFile</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&nbsp;getLookaheadDFAFromPositionInFile(int&nbsp;line,
                                    int&nbsp;col)</pre>
<div class="block">Useful for ANTLRWorks to map position in file to the DFA for display</div>
</li>
</ul>
<a name="getLineColumnToLookaheadDFAMap()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLineColumnToLookaheadDFAMap</h4>
<pre>public&nbsp;java.util.Map&nbsp;getLineColumnToLookaheadDFAMap()</pre>
</li>
</ul>
<a name="getNumberOfDecisions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumberOfDecisions</h4>
<pre>public&nbsp;int&nbsp;getNumberOfDecisions()</pre>
</li>
</ul>
<a name="getNumberOfCyclicDecisions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumberOfCyclicDecisions</h4>
<pre>public&nbsp;int&nbsp;getNumberOfCyclicDecisions()</pre>
</li>
</ul>
<a name="setLookaheadDFA(int, org.antlr.analysis.DFA)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setLookaheadDFA</h4>
<pre>public&nbsp;void&nbsp;setLookaheadDFA(int&nbsp;decision,
                   <a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&nbsp;lookaheadDFA)</pre>
<div class="block">Set the lookahead DFA for a particular decision.  This means
  that the appropriate AST node must updated to have the new lookahead
  DFA.  This method could be used to properly set the DFAs without
  using the createLookaheadDFAs() method.  You could do this

    Grammar g = new Grammar("...");
    g.setLookahead(1, dfa1);
    g.setLookahead(2, dfa2);
    ...</div>
</li>
</ul>
<a name="setDecisionNFA(int, org.antlr.analysis.NFAState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDecisionNFA</h4>
<pre>public&nbsp;void&nbsp;setDecisionNFA(int&nbsp;decision,
                  <a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;state)</pre>
</li>
</ul>
<a name="setDecisionBlockAST(int, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDecisionBlockAST</h4>
<pre>public&nbsp;void&nbsp;setDecisionBlockAST(int&nbsp;decision,
                       <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;blockAST)</pre>
</li>
</ul>
<a name="allDecisionDFAHaveBeenCreated()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allDecisionDFAHaveBeenCreated</h4>
<pre>public&nbsp;boolean&nbsp;allDecisionDFAHaveBeenCreated()</pre>
</li>
</ul>
<a name="getMaxTokenType()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxTokenType</h4>
<pre>public&nbsp;int&nbsp;getMaxTokenType()</pre>
<div class="block">How many token types have been allocated so far?</div>
</li>
</ul>
<a name="getMaxCharValue()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxCharValue</h4>
<pre>public&nbsp;int&nbsp;getMaxCharValue()</pre>
<div class="block">What is the max char value possible for this grammar's target?  Use
  unicode max if no target defined.</div>
</li>
</ul>
<a name="getTokenTypes()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTokenTypes</h4>
<pre>public&nbsp;<a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a>&nbsp;getTokenTypes()</pre>
<div class="block">Return a set of all possible token or char types for this grammar</div>
</li>
</ul>
<a name="getAllCharValues()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAllCharValues</h4>
<pre>public&nbsp;<a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a>&nbsp;getAllCharValues()</pre>
<div class="block">If there is a char vocabulary, use it; else return min to max char
  as defined by the target.  If no target, use max unicode char value.</div>
</li>
</ul>
<a name="getANTLRCharLiteralForChar(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getANTLRCharLiteralForChar</h4>
<pre>public static&nbsp;java.lang.String&nbsp;getANTLRCharLiteralForChar(int&nbsp;c)</pre>
<div class="block">Return a string representing the escaped char for code c.  E.g., If c
  has value 0x100, you will get "Ā".  ASCII gets the usual
  char (non-hex) representation.  Control characters are spit out
  as unicode.  While this is specially set up for returning Java strings,
  it can be used by any language target that has the same syntax. :)

  11/26/2005: I changed this to use double quotes, consistent with antlr.g
  12/09/2005: I changed so everything is single quotes</div>
</li>
</ul>
<a name="complement(org.antlr.misc.IntSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>complement</h4>
<pre>public&nbsp;<a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a>&nbsp;complement(<a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a>&nbsp;set)</pre>
<div class="block">For lexer grammars, return everything in unicode not in set.
  For parser and tree grammars, return everything in token space
  from MIN_TOKEN_TYPE to last valid token type or char value.</div>
</li>
</ul>
<a name="complement(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>complement</h4>
<pre>public&nbsp;<a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a>&nbsp;complement(int&nbsp;atom)</pre>
</li>
</ul>
<a name="isValidSet(org.antlr.grammar.v2.TreeToNFAConverter, org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isValidSet</h4>
<pre>public&nbsp;boolean&nbsp;isValidSet(<a href="../../../org/antlr/grammar/v2/TreeToNFAConverter.html" title="class in org.antlr.grammar.v2">TreeToNFAConverter</a>&nbsp;nfabuilder,
                 <a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;t)</pre>
<div class="block">Given set tree like ( SET A B ), check that A and B
  are both valid sets themselves, else we must tree like a BLOCK</div>
</li>
</ul>
<a name="getSetFromRule(org.antlr.grammar.v2.TreeToNFAConverter, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSetFromRule</h4>
<pre>public&nbsp;<a href="../../../org/antlr/misc/IntSet.html" title="interface in org.antlr.misc">IntSet</a>&nbsp;getSetFromRule(<a href="../../../org/antlr/grammar/v2/TreeToNFAConverter.html" title="class in org.antlr.grammar.v2">TreeToNFAConverter</a>&nbsp;nfabuilder,
                    java.lang.String&nbsp;ruleName)
                      throws antlr.RecognitionException</pre>
<div class="block">Get the set equivalent (if any) of the indicated rule from this
  grammar.  Mostly used in the lexer to do ~T for some fragment rule
  T.  If the rule AST has a SET use that.  If the rule is a single char
  convert it to a set and return.  If rule is not a simple set (w/o actions)
  then return null.
  Rules have AST form:

                ^( RULE ID modifier ARG RET SCOPE block EOR )</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>antlr.RecognitionException</code></dd></dl>
</li>
</ul>
<a name="getNumberOfAltsForDecisionNFA(org.antlr.analysis.NFAState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumberOfAltsForDecisionNFA</h4>
<pre>public&nbsp;int&nbsp;getNumberOfAltsForDecisionNFA(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;decisionState)</pre>
<div class="block">Decisions are linked together with transition(1).  Count how
  many there are.  This is here rather than in NFAState because
  a grammar decides how NFAs are put together to form a decision.</div>
</li>
</ul>
<a name="getNFAStateForAltOfDecision(org.antlr.analysis.NFAState, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNFAStateForAltOfDecision</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;getNFAStateForAltOfDecision(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;decisionState,
                                   int&nbsp;alt)</pre>
<div class="block">Get the ith alternative (1..n) from a decision; return null when
  an invalid alt is requested.  I must count in to find the right
  alternative number.  For (A|B), you get NFA structure (roughly):

  o->o-A->o
  |
  o->o-B->o

  This routine returns the leftmost state for each alt.  So alt=1, returns
  the upperleft most state in this structure.</div>
</li>
</ul>
<a name="FIRST(org.antlr.analysis.NFAState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FIRST</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/LookaheadSet.html" title="class in org.antlr.analysis">LookaheadSet</a>&nbsp;FIRST(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;s)</pre>
</li>
</ul>
<a name="LOOK(org.antlr.analysis.NFAState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LOOK</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/LookaheadSet.html" title="class in org.antlr.analysis">LookaheadSet</a>&nbsp;LOOK(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;s)</pre>
</li>
</ul>
<a name="setCodeGenerator(org.antlr.codegen.CodeGenerator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCodeGenerator</h4>
<pre>public&nbsp;void&nbsp;setCodeGenerator(<a href="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</a>&nbsp;generator)</pre>
</li>
</ul>
<a name="getCodeGenerator()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCodeGenerator</h4>
<pre>public&nbsp;<a href="../../../org/antlr/codegen/CodeGenerator.html" title="class in org.antlr.codegen">CodeGenerator</a>&nbsp;getCodeGenerator()</pre>
</li>
</ul>
<a name="getGrammarTree()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGrammarTree</h4>
<pre>public&nbsp;<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;getGrammarTree()</pre>
</li>
</ul>
<a name="getTool()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTool</h4>
<pre>public&nbsp;<a href="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</a>&nbsp;getTool()</pre>
</li>
</ul>
<a name="setTool(org.antlr.Tool)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTool</h4>
<pre>public&nbsp;void&nbsp;setTool(<a href="../../../org/antlr/Tool.html" title="class in org.antlr">Tool</a>&nbsp;tool)</pre>
</li>
</ul>
<a name="computeTokenNameFromLiteral(int, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeTokenNameFromLiteral</h4>
<pre>public&nbsp;java.lang.String&nbsp;computeTokenNameFromLiteral(int&nbsp;tokenType,
                                           java.lang.String&nbsp;literal)</pre>
<div class="block">given a token type and the text of the literal, come up with a
  decent token type label.  For now it's just T<type>.  Actually,
  if there is an aliased name from tokens like PLUS='+', use it.</div>
</li>
</ul>
<a name="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="grammarTreeToString(org.antlr.tool.GrammarAST)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grammarTreeToString</h4>
<pre>public&nbsp;java.lang.String&nbsp;grammarTreeToString(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;t)</pre>
</li>
</ul>
<a name="grammarTreeToString(org.antlr.tool.GrammarAST, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grammarTreeToString</h4>
<pre>public&nbsp;java.lang.String&nbsp;grammarTreeToString(<a href="../../../org/antlr/tool/GrammarAST.html" title="class in org.antlr.tool">GrammarAST</a>&nbsp;t,
                                   boolean&nbsp;showActions)</pre>
</li>
</ul>
<a name="printGrammar(java.io.PrintStream)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>printGrammar</h4>
<pre>public&nbsp;void&nbsp;printGrammar(java.io.PrintStream&nbsp;output)</pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Grammar.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/antlr/tool/FASerializer.html" title="class in org.antlr.tool"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../org/antlr/tool/Grammar.Decision.html" title="class in org.antlr.tool"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/antlr/tool/Grammar.html" target="_top">Frames</a></li>
<li><a href="Grammar.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested_class_summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2012. All Rights Reserved.</small></p>
</body>
</html>
