<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_03) on Sat Jun 23 11:20:42 UTC 2012 -->
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<title>NFAContext (ANTLR Master build control POM 3.2 API)</title>
<meta name="date" content="2012-06-23">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="NFAContext (ANTLR Master build control POM 3.2 API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/NFAContext.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../org/antlr/analysis/NFAConversionThread.html" title="class in org.antlr.analysis"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/antlr/analysis/NFAContext.html" target="_top">Frames</a></li>
<li><a href="NFAContext.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.antlr.analysis</div>
<h2 title="Class NFAContext" class="title">Class NFAContext</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.antlr.analysis.NFAContext</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">NFAContext</span>
extends java.lang.Object</pre>
<div class="block">A tree node for tracking the call chains for NFAs that invoke
  other NFAs.  These trees only have to point upwards to their parents
  so we can walk back up the tree (i.e., pop stuff off the stack).  We
  never walk from stack down down through the children.

  Each alt predicted in a decision has its own context tree,
  representing all possible return nodes.  The initial stack has
  EOF ("$") in it.  So, for m alternative productions, the lookahead
  DFA will have m NFAContext trees.

  To "push" a new context, just do "new NFAContext(context-parent, state)"
  which will add itself to the parent.  The root is NFAContext(null, null).

  The complete context for an NFA configuration is the set of invoking states
  on the path from this node thru the parent pointers to the root.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#cachedHashCode">cachedHashCode</a></strong></code>
<div class="block">Computing the hashCode is very expensive and closureBusy()
  uses it to track when it's seen a state|ctx before to avoid
  infinite loops.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#invokingState">invokingState</a></strong></code>
<div class="block">The NFA state that invoked another rule's start state is recorded
  on the rule invocation context stack.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK">MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK</a></strong></code>
<div class="block">This is similar to Bermudez's m constant in his LAR(m) where
  you bound the stack so your states don't explode.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#parent">parent</a></strong></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#NFAContext(org.antlr.analysis.NFAContext, org.antlr.analysis.NFAState)">NFAContext</a></strong>(<a href="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</a>&nbsp;parent,
          <a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;invokingState)</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#conflictsWith(org.antlr.analysis.NFAContext)">conflictsWith</a></strong>(<a href="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</a>&nbsp;other)</code>
<div class="block">Two contexts conflict() if they are equals() or one is a stack suffix
  of the other.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#equals(java.lang.Object)">equals</a></strong>(java.lang.Object&nbsp;o)</code>
<div class="block">Two contexts are equals() if both have
  same call stack; walk upwards to the root.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#hashCode()">hashCode</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#isEmpty()">isEmpty</a></strong>()</code>
<div class="block">A context is empty if there is no parent; meaning nobody pushed
  anything on the call stack.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#recursionDepthEmanatingFromState(int)">recursionDepthEmanatingFromState</a></strong>(int&nbsp;state)</code>
<div class="block">Given an NFA state number, how many times has the NFA-to-DFA
  conversion pushed that state on the stack?  In other words,
  the NFA state must be a rule invocation state and this method
  tells you how many times you've been to this state.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#suffix(org.antlr.analysis.NFAContext)">suffix</a></strong>(<a href="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</a>&nbsp;other)</code>
<div class="block">[$] suffix any context
  [21 $] suffix [21 12 $]
  [21 12 $] suffix [21 $]
  [21 18 $] suffix [21 18 12 9 $]
  [21 18 12 9 $] suffix [21 18 $]
  [21 12 $] not suffix [21 9 $]

  Example "[21 $] suffix [21 12 $]" means: rule r invoked current rule
  from state 21.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/NFAContext.html#toString()">toString</a></strong>()</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK</h4>
<pre>public static&nbsp;int MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK</pre>
<div class="block">This is similar to Bermudez's m constant in his LAR(m) where
  you bound the stack so your states don't explode.  The main difference
  is that I bound only recursion on the stack, not the simple stack size.
  This looser constraint will let the conversion roam further to find
  lookahead to resolve a decision.

  Bermudez's m operates differently as it is his LR stack depth
  I'm pretty sure it therefore includes all stack symbols.  Here I
  restrict the size of an NFA configuration to be finite because a
  stack component may mention the same NFA invocation state at
  most m times.  Hence, the number of DFA states will not grow forever.
  With recursive rules like

    e : '(' e ')' | INT ;

  you could chase your tail forever if somebody said "s : e '.' | e ';' ;"
  This constant prevents new states from being created after a stack gets
  "too big".  Actually (12/14/2007) I realize that this example is
  trapped by the non-LL(*) detector for recursion in > 1 alt.  Here is
  an example that trips stack overflow:

          s : a Y | A A A A A X ; // force recursion past m=4
          a : A a | Q;

  If that were:

          s : a Y | A+ X ;

  it could loop forever.

  Imagine doing a depth-first search on the e DFA...as you chase an input
  sequence you can recurse to same rule such as e above.  You'd have a
  chain of ((((.  When you get do some point, you have to give up.  The
  states in the chain will have longer and longer NFA config stacks.
  Must limit size.

  max=0 implies you cannot ever jump to another rule during closure.
  max=1 implies you can make as many calls as you want--you just
        can't ever visit a state that is on your rule invocation stack.
                  I.e., you cannot ever recurse.
  max=2 implies you are able to recurse once (i.e., call a rule twice
          from the same place).

  This tracks recursion to a rule specific to an invocation site!
  It does not detect multiple calls to a rule from different rule
  invocation states.  We are guaranteed to terminate because the
  stack can only grow as big as the number of NFA states * max.

  I noticed that the Java grammar didn't work with max=1, but did with
  max=4.  Let's set to 4. Recursion is sometimes needed to resolve some
  fixed lookahead decisions.</div>
</li>
</ul>
<a name="parent">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parent</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</a> parent</pre>
</li>
</ul>
<a name="invokingState">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invokingState</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a> invokingState</pre>
<div class="block">The NFA state that invoked another rule's start state is recorded
  on the rule invocation context stack.</div>
</li>
</ul>
<a name="cachedHashCode">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>cachedHashCode</h4>
<pre>protected&nbsp;int cachedHashCode</pre>
<div class="block">Computing the hashCode is very expensive and closureBusy()
  uses it to track when it's seen a state|ctx before to avoid
  infinite loops.  As we add new contexts, record the hash code
  as this.invokingState + parent.cachedHashCode.  Avoids walking
  up the tree for every hashCode().  Note that this caching works
  because a context is a monotonically growing tree of context nodes
  and nothing on the stack is ever modified...ctx just grows
  or shrinks.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="NFAContext(org.antlr.analysis.NFAContext, org.antlr.analysis.NFAState)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>NFAContext</h4>
<pre>public&nbsp;NFAContext(<a href="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</a>&nbsp;parent,
          <a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;invokingState)</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="equals(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre>public&nbsp;boolean&nbsp;equals(java.lang.Object&nbsp;o)</pre>
<div class="block">Two contexts are equals() if both have
  same call stack; walk upwards to the root.
  Recall that the root sentinel node has no invokingStates and no parent.
  Note that you may be comparing contexts in different alt trees.

  The hashCode is now cheap as it's computed once upon each context
  push on the stack.  Use it to make equals() more efficient.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>equals</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="conflictsWith(org.antlr.analysis.NFAContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>conflictsWith</h4>
<pre>public&nbsp;boolean&nbsp;conflictsWith(<a href="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</a>&nbsp;other)</pre>
<div class="block">Two contexts conflict() if they are equals() or one is a stack suffix
  of the other.  For example, contexts [21 12 $] and [21 9 $] do not
  conflict, but [21 $] and [21 12 $] do conflict.  Note that I should
  probably not show the $ in this case.  There is a dummy node for each
  stack that just means empty; $ is a marker that's all.

  This is used in relation to checking conflicts associated with a
  single NFA state's configurations within a single DFA state.
  If there are configurations s and t within a DFA state such that
  s.state=t.state && s.alt != t.alt && s.ctx conflicts t.ctx then
  the DFA state predicts more than a single alt--it's nondeterministic.
  Two contexts conflict if they are the same or if one is a suffix
  of the other.

  When comparing contexts, if one context has a stack and the other
  does not then they should be considered the same context.  The only
  way for an NFA state p to have an empty context and a nonempty context
  is the case when closure falls off end of rule without a call stack
  and re-enters the rule with a context.  This resolves the issue I
  discussed with Sriram Srinivasan Feb 28, 2005 about not terminating
  fast enough upon nondeterminism.</div>
</li>
</ul>
<a name="suffix(org.antlr.analysis.NFAContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>suffix</h4>
<pre>protected&nbsp;boolean&nbsp;suffix(<a href="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</a>&nbsp;other)</pre>
<div class="block">[$] suffix any context
  [21 $] suffix [21 12 $]
  [21 12 $] suffix [21 $]
  [21 18 $] suffix [21 18 12 9 $]
  [21 18 12 9 $] suffix [21 18 $]
  [21 12 $] not suffix [21 9 $]

  Example "[21 $] suffix [21 12 $]" means: rule r invoked current rule
  from state 21.  Rule s invoked rule r from state 12 which then invoked
  current rule also via state 21.  While the context prior to state 21
  is different, the fact that both contexts emanate from state 21 implies
  that they are now going to track perfectly together.  Once they
  converged on state 21, there is no way they can separate.  In other
  words, the prior stack state is not consulted when computing where to
  go in the closure operation.  ?$ and ??$ are considered the same stack.
  If ? is popped off then $ and ?$ remain; they are now an empty and
  nonempty context comparison.  So, if one stack is a suffix of
  another, then it will still degenerate to the simple empty stack
  comparison case.</div>
</li>
</ul>
<a name="recursionDepthEmanatingFromState(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recursionDepthEmanatingFromState</h4>
<pre>public&nbsp;int&nbsp;recursionDepthEmanatingFromState(int&nbsp;state)</pre>
<div class="block">Given an NFA state number, how many times has the NFA-to-DFA
  conversion pushed that state on the stack?  In other words,
  the NFA state must be a rule invocation state and this method
  tells you how many times you've been to this state.  If none,
  then you have not called the target rule from this state before
  (though another NFA state could have called that target rule).
  If n=1, then you've been to this state before during this
  DFA construction and are going to invoke that rule again.

  Note that many NFA states can invoke rule r, but we ignore recursion
  unless you hit the same rule invocation state again.</div>
</li>
</ul>
<a name="hashCode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashCode</h4>
<pre>public&nbsp;int&nbsp;hashCode()</pre>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>hashCode</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="isEmpty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isEmpty</h4>
<pre>public&nbsp;boolean&nbsp;isEmpty()</pre>
<div class="block">A context is empty if there is no parent; meaning nobody pushed
  anything on the call stack.</div>
</li>
</ul>
<a name="toString()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/NFAContext.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../org/antlr/analysis/NFAConversionThread.html" title="class in org.antlr.analysis"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/antlr/analysis/NFAContext.html" target="_top">Frames</a></li>
<li><a href="NFAContext.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2012. All Rights Reserved.</small></p>
</body>
</html>
