<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_03) on Sat Jun 23 11:20:42 UTC 2012 -->
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<title>DFAState (ANTLR Master build control POM 3.2 API)</title>
<meta name="date" content="2012-06-23">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="DFAState (ANTLR Master build control POM 3.2 API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/DFAState.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/antlr/analysis/DFAOptimizer.html" title="class in org.antlr.analysis"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/antlr/analysis/DFAState.html" target="_top">Frames</a></li>
<li><a href="DFAState.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.antlr.analysis</div>
<h2 title="Class DFAState" class="title">Class DFAState</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">org.antlr.analysis.State</a></li>
<li>
<ul class="inheritance">
<li>org.antlr.analysis.DFAState</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">DFAState</span>
extends <a href="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</a></pre>
<div class="block">A DFA state represents a set of possible NFA configurations.
  As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
  to keep track of all possible states the NFA can be in after
  reading each input symbol.  That is to say, after reading
  input a1a2..an, the DFA is in a state that represents the
  subset T of the states of the NFA that are reachable from the
  NFA's start state along some path labeled a1a2..an."
  In conventional NFA->DFA conversion, therefore, the subset T
  would be a bitset representing the set of states the
  NFA could be in.  We need to track the alt predicted by each
  state as well, however.  More importantly, we need to maintain
  a stack of states, tracking the closure operations as they
  jump from rule to rule, emulating rule invocations (method calls).
  Recall that NFAs do not normally have a stack like a pushdown-machine
  so I have to add one to simulate the proper lookahead sequences for
  the underlying LL grammar from which the NFA was derived.

  I use a list of NFAConfiguration objects.  An NFAConfiguration
  is both a state (ala normal conversion) and an NFAContext describing
  the chain of rules (if any) followed to arrive at that state.  There
  is also the semantic context, which is the "set" of predicates found
  on the path to this configuration.

  A DFA state may have multiple references to a particular state,
  but with different NFAContexts (with same or different alts)
  meaning that state was reached via a different set of rule invocations.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#abortedDueToMultipleRecursiveAlts">abortedDueToMultipleRecursiveAlts</a></strong></code>
<div class="block">If we detect recursion on more than one alt, decision is non-LL(*),
  but try to isolate it to only those states whose closure operations
  detect recursion.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#abortedDueToRecursionOverflow">abortedDueToRecursionOverflow</a></strong></code>
<div class="block">If a closure operation finds that we tried to invoke the same
  rule too many times (stack would grow beyond a threshold), it
  marks the state has aborted and notifies the DecisionProbe.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#acceptStateReachable">acceptStateReachable</a></strong></code>
<div class="block">The NFA->DFA algorithm may terminate leaving some states
  without a path to an accept state, implying that upon certain
  input, the decision is not deterministic--no decision about
  predicting a unique alternative can be made.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#atLeastOneConfigurationHasAPredicate">atLeastOneConfigurationHasAPredicate</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#cachedHashCode">cachedHashCode</a></strong></code>
<div class="block">Build up the hash code for this state as NFA configurations
  are added as it's monotonically increasing list of configurations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#cachedUniquelyPredicatedAlt">cachedUniquelyPredicatedAlt</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.Set&lt;<a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#closureBusy">closureBusy</a></strong></code>
<div class="block">Used to prevent the closure operation from looping to itself and
  hence looping forever.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#configurationsWithLabeledEdges">configurationsWithLabeledEdges</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#dfa">dfa</a></strong></code>
<div class="block">We are part of what DFA?  Use this ref to get access to the
  context trees for an alt.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#INITIAL_NUM_TRANSITIONS">INITIAL_NUM_TRANSITIONS</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#k">k</a></strong></code>
<div class="block">When doing an acyclic DFA, this is the number of lookahead symbols
  consumed to reach this state.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#minAltInConfigurations">minAltInConfigurations</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</a>&lt;<a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#nfaConfigurations">nfaConfigurations</a></strong></code>
<div class="block">The set of NFA configurations (state,alt,context) for this DFA state</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#PREDICTED_ALT_UNSET">PREDICTED_ALT_UNSET</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</a>&lt;<a href="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#reachableLabels">reachableLabels</a></strong></code>
<div class="block">As this state is constructed (i.e., as NFA states are added), we
  can easily check for non-epsilon transitions because the only
  transition that could be a valid label is transition(0).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#resolvedWithPredicates">resolvedWithPredicates</a></strong></code>
<div class="block">Rather than recheck every NFA configuration in a DFA state (after
  resolving) in findNewDFAStatesAndAddDFATransitions just check
  this boolean.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.List&lt;<a href="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#transitions">transitions</a></strong></code>
<div class="block">Track the transitions emanating from this DFA state.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="fields_inherited_from_class_org.antlr.analysis.State">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;org.antlr.analysis.<a href="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</a></h3>
<code><a href="../../../org/antlr/analysis/State.html#acceptState">acceptState</a>, <a href="../../../org/antlr/analysis/State.html#INVALID_STATE_NUMBER">INVALID_STATE_NUMBER</a>, <a href="../../../org/antlr/analysis/State.html#stateNumber">stateNumber</a></code></li>
</ul>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#DFAState(org.antlr.analysis.DFA)">DFAState</a></strong>(<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&nbsp;dfa)</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#addNFAConfiguration(org.antlr.analysis.NFAState, int, org.antlr.analysis.NFAContext, org.antlr.analysis.SemanticContext)">addNFAConfiguration</a></strong>(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;state,
                   int&nbsp;alt,
                   <a href="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</a>&nbsp;context,
                   <a href="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</a>&nbsp;semanticContext)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#addNFAConfiguration(org.antlr.analysis.NFAState, org.antlr.analysis.NFAConfiguration)">addNFAConfiguration</a></strong>(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;state,
                   <a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&nbsp;c)</code>
<div class="block">Add an NFA configuration to this DFA node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#addReachableLabel(org.antlr.analysis.Label)">addReachableLabel</a></strong>(<a href="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</a>&nbsp;label)</code>
<div class="block">Add label uniquely and disjointly; intersection with
  another set or int/char forces breaking up the set(s).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#addTransition(org.antlr.analysis.DFAState, org.antlr.analysis.Label)">addTransition</a></strong>(<a href="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</a>&nbsp;target,
             <a href="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</a>&nbsp;label)</code>
<div class="block">Add a transition from this state to target with label.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#addTransition(org.antlr.analysis.Transition)">addTransition</a></strong>(<a href="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</a>&nbsp;t)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#equals(java.lang.Object)">equals</a></strong>(java.lang.Object&nbsp;o)</code>
<div class="block">Two DFAStates are equal if their NFA configuration sets are the
  same.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getAcceptStateReachable()">getAcceptStateReachable</a></strong>()</code>
<div class="block">Is an accept state reachable from this state?</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getAltSet()">getAltSet</a></strong>()</code>
<div class="block">Get the set of all alts mentioned by all NFA configurations in this
  DFA state.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.Set&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getConflictingAlts()">getConflictingAlts</a></strong>()</code>
<div class="block">Walk each NFA configuration in this DFA state looking for a conflict
  where (s|i|ctx) and (s|j|ctx) exist, indicating that state s with
  context conflicting ctx predicts alts i and j.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getDisabledAlternatives()">getDisabledAlternatives</a></strong>()</code>
<div class="block">When more than one alternative can match the same input, the first
  alternative is chosen to resolve the conflict.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getGatedPredicatesInNFAConfigurations()">getGatedPredicatesInNFAConfigurations</a></strong>()</code>
<div class="block">For gated productions, we need an OR'd list of all predicates for the
  target of an edge so we can gate the edge based upon the predicates
  associated with taking that path (if any).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getGatedSyntacticPredicatesInNFAConfigurations()">getGatedSyntacticPredicatesInNFAConfigurations</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getLookaheadDepth()">getLookaheadDepth</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Set</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getNonDeterministicAlts()">getNonDeterministicAlts</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getNumberOfTransitions()">getNumberOfTransitions</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getReachableLabels()">getReachableLabels</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getTransition(int)">getTransition</a></strong>(int&nbsp;trans)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getUniqueAlt()">getUniqueAlt</a></strong>()</code>
<div class="block">Return the uniquely mentioned alt from the NFA configurations;
  Ignore the resolved bit etc...</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#getUniquelyPredictedAlt()">getUniquelyPredictedAlt</a></strong>()</code>
<div class="block">Walk each configuration and if they are all the same alt, return
  that alt else return NFA.INVALID_ALT_NUMBER.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#hashCode()">hashCode</a></strong>()</code>
<div class="block">A decent hash for a DFA state is the sum of the NFA state/alt pairs.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#isResolvedWithPredicates()">isResolvedWithPredicates</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#removeTransition(int)">removeTransition</a></strong>(int&nbsp;trans)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#reset()">reset</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#setAcceptStateReachable(int)">setAcceptStateReachable</a></strong>(int&nbsp;acceptStateReachable)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#setLookaheadDepth(int)">setLookaheadDepth</a></strong>(int&nbsp;k)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#setNFAConfigurations(org.antlr.misc.OrderedHashSet)">setNFAConfigurations</a></strong>(<a href="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</a>&lt;<a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&gt;&nbsp;configs)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#toString()">toString</a></strong>()</code>
<div class="block">Print all NFA states plus what alts they predict</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</a></code></td>
<td class="colLast"><code><strong><a href="../../../org/antlr/analysis/DFAState.html#transition(int)">transition</a></strong>(int&nbsp;i)</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_org.antlr.analysis.State">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;org.antlr.analysis.<a href="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</a></h3>
<code><a href="../../../org/antlr/analysis/State.html#isAcceptState()">isAcceptState</a>, <a href="../../../org/antlr/analysis/State.html#setAcceptState(boolean)">setAcceptState</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="INITIAL_NUM_TRANSITIONS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INITIAL_NUM_TRANSITIONS</h4>
<pre>public static final&nbsp;int INITIAL_NUM_TRANSITIONS</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.analysis.DFAState.INITIAL_NUM_TRANSITIONS">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="PREDICTED_ALT_UNSET">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PREDICTED_ALT_UNSET</h4>
<pre>public static final&nbsp;int PREDICTED_ALT_UNSET</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.antlr.analysis.DFAState.PREDICTED_ALT_UNSET">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="dfa">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dfa</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a> dfa</pre>
<div class="block">We are part of what DFA?  Use this ref to get access to the
  context trees for an alt.</div>
</li>
</ul>
<a name="transitions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transitions</h4>
<pre>protected&nbsp;java.util.List&lt;<a href="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</a>&gt; transitions</pre>
<div class="block">Track the transitions emanating from this DFA state.  The List
  elements are Transition objects.</div>
</li>
</ul>
<a name="k">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>k</h4>
<pre>protected&nbsp;int k</pre>
<div class="block">When doing an acyclic DFA, this is the number of lookahead symbols
  consumed to reach this state.  This value may be nonzero for most
  dfa states, but it is only a valid value if the user has specified
  a max fixed lookahead.</div>
</li>
</ul>
<a name="acceptStateReachable">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>acceptStateReachable</h4>
<pre>protected&nbsp;int acceptStateReachable</pre>
<div class="block">The NFA->DFA algorithm may terminate leaving some states
  without a path to an accept state, implying that upon certain
  input, the decision is not deterministic--no decision about
  predicting a unique alternative can be made.  Recall that an
  accept state is one in which a unique alternative is predicted.</div>
</li>
</ul>
<a name="resolvedWithPredicates">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resolvedWithPredicates</h4>
<pre>protected&nbsp;boolean resolvedWithPredicates</pre>
<div class="block">Rather than recheck every NFA configuration in a DFA state (after
  resolving) in findNewDFAStatesAndAddDFATransitions just check
  this boolean.  Saves a linear walk perhaps DFA state creation.
  Every little bit helps.</div>
</li>
</ul>
<a name="abortedDueToRecursionOverflow">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>abortedDueToRecursionOverflow</h4>
<pre>public&nbsp;boolean abortedDueToRecursionOverflow</pre>
<div class="block">If a closure operation finds that we tried to invoke the same
  rule too many times (stack would grow beyond a threshold), it
  marks the state has aborted and notifies the DecisionProbe.</div>
</li>
</ul>
<a name="abortedDueToMultipleRecursiveAlts">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>abortedDueToMultipleRecursiveAlts</h4>
<pre>protected&nbsp;boolean abortedDueToMultipleRecursiveAlts</pre>
<div class="block">If we detect recursion on more than one alt, decision is non-LL(*),
  but try to isolate it to only those states whose closure operations
  detect recursion.  There may be other alts that are cool:

  a : recur '.'
    | recur ';'
    | X Y  // LL(2) decision; don't abort and use k=1 plus backtracking
    | X Z
    ;

  12/13/2007: Actually this has caused problems.  If k=*, must terminate
  and throw out entire DFA; retry with k=1.  Since recursive, do not
  attempt more closure ops as it may take forever.  Exception thrown
  now and we simply report the problem.  If synpreds exist, I'll retry
  with k=1.</div>
</li>
</ul>
<a name="cachedHashCode">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cachedHashCode</h4>
<pre>protected&nbsp;int cachedHashCode</pre>
<div class="block">Build up the hash code for this state as NFA configurations
  are added as it's monotonically increasing list of configurations.</div>
</li>
</ul>
<a name="cachedUniquelyPredicatedAlt">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cachedUniquelyPredicatedAlt</h4>
<pre>protected&nbsp;int cachedUniquelyPredicatedAlt</pre>
</li>
</ul>
<a name="minAltInConfigurations">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minAltInConfigurations</h4>
<pre>public&nbsp;int minAltInConfigurations</pre>
</li>
</ul>
<a name="atLeastOneConfigurationHasAPredicate">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atLeastOneConfigurationHasAPredicate</h4>
<pre>public&nbsp;boolean atLeastOneConfigurationHasAPredicate</pre>
</li>
</ul>
<a name="nfaConfigurations">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nfaConfigurations</h4>
<pre>public&nbsp;<a href="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</a>&lt;<a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&gt; nfaConfigurations</pre>
<div class="block">The set of NFA configurations (state,alt,context) for this DFA state</div>
</li>
</ul>
<a name="configurationsWithLabeledEdges">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>configurationsWithLabeledEdges</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&gt; configurationsWithLabeledEdges</pre>
</li>
</ul>
<a name="closureBusy">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closureBusy</h4>
<pre>protected&nbsp;java.util.Set&lt;<a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&gt; closureBusy</pre>
<div class="block">Used to prevent the closure operation from looping to itself and
  hence looping forever.  Sensitive to the NFA state, the alt, and
  the stack context.  This just the nfa config set because we want to
  prevent closures only on states contributed by closure not reach
  operations.

  Two configurations identical including semantic context are
  considered the same closure computation.  @see NFAToDFAConverter.closureBusy().</div>
</li>
</ul>
<a name="reachableLabels">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>reachableLabels</h4>
<pre>protected&nbsp;<a href="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</a>&lt;<a href="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</a>&gt; reachableLabels</pre>
<div class="block">As this state is constructed (i.e., as NFA states are added), we
  can easily check for non-epsilon transitions because the only
  transition that could be a valid label is transition(0).  When we
  process this node eventually, we'll have to walk all states looking
  for all possible transitions.  That is of the order: size(label space)
  times size(nfa states), which can be pretty damn big.  It's better
  to simply track possible labels.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="DFAState(org.antlr.analysis.DFA)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>DFAState</h4>
<pre>public&nbsp;DFAState(<a href="../../../org/antlr/analysis/DFA.html" title="class in org.antlr.analysis">DFA</a>&nbsp;dfa)</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="reset()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reset</h4>
<pre>public&nbsp;void&nbsp;reset()</pre>
</li>
</ul>
<a name="transition(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transition</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</a>&nbsp;transition(int&nbsp;i)</pre>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../org/antlr/analysis/State.html#transition(int)">transition</a></code>&nbsp;in class&nbsp;<code><a href="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</a></code></dd>
</dl>
</li>
</ul>
<a name="getNumberOfTransitions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumberOfTransitions</h4>
<pre>public&nbsp;int&nbsp;getNumberOfTransitions()</pre>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../org/antlr/analysis/State.html#getNumberOfTransitions()">getNumberOfTransitions</a></code>&nbsp;in class&nbsp;<code><a href="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</a></code></dd>
</dl>
</li>
</ul>
<a name="addTransition(org.antlr.analysis.Transition)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addTransition</h4>
<pre>public&nbsp;void&nbsp;addTransition(<a href="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</a>&nbsp;t)</pre>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../org/antlr/analysis/State.html#addTransition(org.antlr.analysis.Transition)">addTransition</a></code>&nbsp;in class&nbsp;<code><a href="../../../org/antlr/analysis/State.html" title="class in org.antlr.analysis">State</a></code></dd>
</dl>
</li>
</ul>
<a name="addTransition(org.antlr.analysis.DFAState, org.antlr.analysis.Label)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addTransition</h4>
<pre>public&nbsp;int&nbsp;addTransition(<a href="../../../org/antlr/analysis/DFAState.html" title="class in org.antlr.analysis">DFAState</a>&nbsp;target,
                <a href="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</a>&nbsp;label)</pre>
<div class="block">Add a transition from this state to target with label.  Return
  the transition number from 0..n-1.</div>
</li>
</ul>
<a name="getTransition(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTransition</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/Transition.html" title="class in org.antlr.analysis">Transition</a>&nbsp;getTransition(int&nbsp;trans)</pre>
</li>
</ul>
<a name="removeTransition(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeTransition</h4>
<pre>public&nbsp;void&nbsp;removeTransition(int&nbsp;trans)</pre>
</li>
</ul>
<a name="addNFAConfiguration(org.antlr.analysis.NFAState, org.antlr.analysis.NFAConfiguration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addNFAConfiguration</h4>
<pre>public&nbsp;void&nbsp;addNFAConfiguration(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;state,
                       <a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&nbsp;c)</pre>
<div class="block">Add an NFA configuration to this DFA node.  Add uniquely
  an NFA state/alt/syntactic&semantic context (chain of invoking state(s)
  and semantic predicate contexts).

  I don't see how there could be two configurations with same
  state|alt|synCtx and different semantic contexts because the
  semantic contexts are computed along the path to a particular state
  so those two configurations would have to have the same predicate.
  Nonetheless, the addition of configurations is unique on all
  configuration info.  I guess I'm saying that syntactic context
  implies semantic context as the latter is computed according to the
  former.

  As we add configurations to this DFA state, track the set of all possible
  transition labels so we can simply walk it later rather than doing a
  loop over all possible labels in the NFA.</div>
</li>
</ul>
<a name="addNFAConfiguration(org.antlr.analysis.NFAState, int, org.antlr.analysis.NFAContext, org.antlr.analysis.SemanticContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addNFAConfiguration</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&nbsp;addNFAConfiguration(<a href="../../../org/antlr/analysis/NFAState.html" title="class in org.antlr.analysis">NFAState</a>&nbsp;state,
                                   int&nbsp;alt,
                                   <a href="../../../org/antlr/analysis/NFAContext.html" title="class in org.antlr.analysis">NFAContext</a>&nbsp;context,
                                   <a href="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</a>&nbsp;semanticContext)</pre>
</li>
</ul>
<a name="addReachableLabel(org.antlr.analysis.Label)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addReachableLabel</h4>
<pre>protected&nbsp;void&nbsp;addReachableLabel(<a href="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis">Label</a>&nbsp;label)</pre>
<div class="block">Add label uniquely and disjointly; intersection with
  another set or int/char forces breaking up the set(s).

  Example, if reachable list of labels is [a..z, {k,9}, 0..9],
  the disjoint list will be [{a..j,l..z}, k, 9, 0..8].

  As we add NFA configurations to a DFA state, we might as well track
  the set of all possible transition labels to make the DFA conversion
  more efficient.  W/o the reachable labels, we'd need to check the
  whole vocabulary space (could be 0..￿)!  The problem is that
  labels can be sets, which may overlap with int labels or other sets.
  As we need a deterministic set of transitions from any
  state in the DFA, we must make the reachable labels set disjoint.
  This operation amounts to finding the character classes for this
  DFA state whereas with tools like flex, that need to generate a
  homogeneous DFA, must compute char classes across all states.
  We are going to generate DFAs with heterogeneous states so we
  only care that the set of transitions out of a single state are
  unique. :)

  The idea for adding a new set, t, is to look for overlap with the
  elements of existing list s.  Upon overlap, replace
  existing set s[i] with two new disjoint sets, s[i]-t and s[i]&t.
  (if s[i]-t is nil, don't add).  The remainder is t-s[i], which is
  what you want to add to the set minus what was already there.  The
  remainder must then be compared against the i+1..n elements in s
  looking for another collision.  Each collision results in a smaller
  and smaller remainder.  Stop when you run out of s elements or
  remainder goes to nil.  If remainder is non nil when you run out of
  s elements, then add remainder to the end.

  Single element labels are treated as sets to make the code uniform.</div>
</li>
</ul>
<a name="getReachableLabels()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReachableLabels</h4>
<pre>public&nbsp;<a href="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</a>&nbsp;getReachableLabels()</pre>
</li>
</ul>
<a name="setNFAConfigurations(org.antlr.misc.OrderedHashSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNFAConfigurations</h4>
<pre>public&nbsp;void&nbsp;setNFAConfigurations(<a href="../../../org/antlr/misc/OrderedHashSet.html" title="class in org.antlr.misc">OrderedHashSet</a>&lt;<a href="../../../org/antlr/analysis/NFAConfiguration.html" title="class in org.antlr.analysis">NFAConfiguration</a>&gt;&nbsp;configs)</pre>
</li>
</ul>
<a name="hashCode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashCode</h4>
<pre>public&nbsp;int&nbsp;hashCode()</pre>
<div class="block">A decent hash for a DFA state is the sum of the NFA state/alt pairs.
  This is used when we add DFAState objects to the DFA.states Map and
  when we compare DFA states.  Computed in addNFAConfiguration()</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>hashCode</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="equals(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre>public&nbsp;boolean&nbsp;equals(java.lang.Object&nbsp;o)</pre>
<div class="block">Two DFAStates are equal if their NFA configuration sets are the
  same. This method is used to see if a DFA state already exists.

  Because the number of alternatives and number of NFA configurations are
  finite, there is a finite number of DFA states that can be processed.
  This is necessary to show that the algorithm terminates.

  Cannot test the DFA state numbers here because in DFA.addState we need
  to know if any other state exists that has this exact set of NFA
  configurations.  The DFAState state number is irrelevant.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>equals</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="getUniquelyPredictedAlt()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUniquelyPredictedAlt</h4>
<pre>public&nbsp;int&nbsp;getUniquelyPredictedAlt()</pre>
<div class="block">Walk each configuration and if they are all the same alt, return
  that alt else return NFA.INVALID_ALT_NUMBER.  Ignore resolved
  configurations, but don't ignore resolveWithPredicate configs
  because this state should not be an accept state.  We need to add
  this to the work list and then have semantic predicate edges
  emanating from it.</div>
</li>
</ul>
<a name="getUniqueAlt()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUniqueAlt</h4>
<pre>public&nbsp;int&nbsp;getUniqueAlt()</pre>
<div class="block">Return the uniquely mentioned alt from the NFA configurations;
  Ignore the resolved bit etc...  Return INVALID_ALT_NUMBER
  if there is more than one alt mentioned.</div>
</li>
</ul>
<a name="getDisabledAlternatives()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDisabledAlternatives</h4>
<pre>public&nbsp;java.util.Set&nbsp;getDisabledAlternatives()</pre>
<div class="block">When more than one alternative can match the same input, the first
  alternative is chosen to resolve the conflict.  The other alts
  are "turned off" by setting the "resolved" flag in the NFA
  configurations.  Return the set of disabled alternatives.  For

  a : A | A | A ;

  this method returns {2,3} as disabled.  This does not mean that
  the alternative is totally unreachable, it just means that for this
  DFA state, that alt is disabled.  There may be other accept states
  for that alt.</div>
</li>
</ul>
<a name="getNonDeterministicAlts()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNonDeterministicAlts</h4>
<pre>protected&nbsp;java.util.Set&nbsp;getNonDeterministicAlts()</pre>
</li>
</ul>
<a name="getConflictingAlts()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getConflictingAlts</h4>
<pre>protected&nbsp;java.util.Set&lt;java.lang.Integer&gt;&nbsp;getConflictingAlts()</pre>
<div class="block">Walk each NFA configuration in this DFA state looking for a conflict
  where (s|i|ctx) and (s|j|ctx) exist, indicating that state s with
  context conflicting ctx predicts alts i and j.  Return an Integer set
  of the alternative numbers that conflict.  Two contexts conflict if
  they are equal or one is a stack suffix of the other or one is
  the empty context.

  Use a hash table to record the lists of configs for each state
  as they are encountered.  We need only consider states for which
  there is more than one configuration.  The configurations' predicted
  alt must be different or must have different contexts to avoid a
  conflict.

  Don't report conflicts for DFA states that have conflicting Tokens
  rule NFA states; they will be resolved in favor of the first rule.</div>
</li>
</ul>
<a name="getAltSet()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAltSet</h4>
<pre>public&nbsp;java.util.Set&nbsp;getAltSet()</pre>
<div class="block">Get the set of all alts mentioned by all NFA configurations in this
  DFA state.</div>
</li>
</ul>
<a name="getGatedSyntacticPredicatesInNFAConfigurations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGatedSyntacticPredicatesInNFAConfigurations</h4>
<pre>public&nbsp;java.util.Set&nbsp;getGatedSyntacticPredicatesInNFAConfigurations()</pre>
</li>
</ul>
<a name="getGatedPredicatesInNFAConfigurations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGatedPredicatesInNFAConfigurations</h4>
<pre>public&nbsp;<a href="../../../org/antlr/analysis/SemanticContext.html" title="class in org.antlr.analysis">SemanticContext</a>&nbsp;getGatedPredicatesInNFAConfigurations()</pre>
<div class="block">For gated productions, we need an OR'd list of all predicates for the
  target of an edge so we can gate the edge based upon the predicates
  associated with taking that path (if any).

  For syntactic predicates, we only want to generate predicate
  evaluations as it transitions to an accept state; waste to
  do it earlier.  So, only add gated preds derived from manually-
  specified syntactic predicates if this is an accept state.

  Also, since configurations w/o gated predicates are like true
  gated predicates, finding a configuration whose alt has no gated
  predicate implies we should evaluate the predicate to true. This
  means the whole edge has to be ungated. Consider:

         X : ('a' | {p}?=> 'a')
           | 'a' 'b'
           ;

  Here, you 'a' gets you from s0 to s1 but you can't test p because
  plain 'a' is ok.  It's also ok for starting alt 2.  Hence, you can't
  test p.  Even on the edge going to accept state for alt 1 of X, you
  can't test p.  You can get to the same place with and w/o the context.
  Therefore, it is never ok to test p in this situation. 

  TODO: cache this as it's called a lot; or at least set bit if >1 present in state</div>
</li>
</ul>
<a name="getAcceptStateReachable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAcceptStateReachable</h4>
<pre>public&nbsp;int&nbsp;getAcceptStateReachable()</pre>
<div class="block">Is an accept state reachable from this state?</div>
</li>
</ul>
<a name="setAcceptStateReachable(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setAcceptStateReachable</h4>
<pre>public&nbsp;void&nbsp;setAcceptStateReachable(int&nbsp;acceptStateReachable)</pre>
</li>
</ul>
<a name="isResolvedWithPredicates()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isResolvedWithPredicates</h4>
<pre>public&nbsp;boolean&nbsp;isResolvedWithPredicates()</pre>
</li>
</ul>
<a name="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Print all NFA states plus what alts they predict</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="getLookaheadDepth()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLookaheadDepth</h4>
<pre>public&nbsp;int&nbsp;getLookaheadDepth()</pre>
</li>
</ul>
<a name="setLookaheadDepth(int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>setLookaheadDepth</h4>
<pre>public&nbsp;void&nbsp;setLookaheadDepth(int&nbsp;k)</pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/DFAState.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/antlr/analysis/DFAOptimizer.html" title="class in org.antlr.analysis"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../org/antlr/analysis/Label.html" title="class in org.antlr.analysis"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/antlr/analysis/DFAState.html" target="_top">Frames</a></li>
<li><a href="DFAState.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2012. All Rights Reserved.</small></p>
</body>
</html>
